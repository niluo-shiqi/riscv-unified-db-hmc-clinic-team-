# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `udb` gem.
# Please instead update this file by running `bin/tapioca gem udb`.


# source://udb//lib/udb/eqn_parser.rb#6
module Eqn
  include ::Treetop::Runtime

  # source://udb//lib/udb/eqn_parser.rb#483
  def _nt_conjunction; end

  # source://udb//lib/udb/eqn_parser.rb#603
  def _nt_disjunction; end

  # source://udb//lib/udb/eqn_parser.rb#20
  def _nt_eqn; end

  # source://udb//lib/udb/eqn_parser.rb#720
  def _nt_expression; end

  # source://udb//lib/udb/eqn_parser.rb#86
  def _nt_name; end

  # source://udb//lib/udb/eqn_parser.rb#367
  def _nt_not; end

  # source://udb//lib/udb/eqn_parser.rb#182
  def _nt_one; end

  # source://udb//lib/udb/eqn_parser.rb#236
  def _nt_paren; end

  # source://udb//lib/udb/eqn_parser.rb#774
  def _nt_space; end

  # source://udb//lib/udb/eqn_parser.rb#417
  def _nt_unary_expression; end

  # source://udb//lib/udb/eqn_parser.rb#138
  def _nt_zero; end

  # source://udb//lib/udb/eqn_parser.rb#9
  def root; end
end

# source://udb//lib/udb/eqn_parser.rb#467
module Eqn::Conjunction0
  # source://udb//lib/udb/eqn_parser.rb#468
  def unary_expression; end
end

# source://udb//lib/udb/eqn_parser.rb#473
module Eqn::Conjunction1
  # source://udb//lib/udb/eqn_parser.rb#474
  def first; end

  # source://udb//lib/udb/eqn_parser.rb#478
  def r; end
end

# source://udb//lib/udb/eqn_parser.rb#587
module Eqn::Disjunction0
  # source://udb//lib/udb/eqn_parser.rb#588
  def conjunction; end
end

# source://udb//lib/udb/eqn_parser.rb#593
module Eqn::Disjunction1
  # source://udb//lib/udb/eqn_parser.rb#594
  def first; end

  # source://udb//lib/udb/eqn_parser.rb#598
  def r; end
end

# source://udb//lib/udb/eqn_parser.rb#13
module Eqn::Eqn0
  # source://udb//lib/udb/eqn_parser.rb#14
  def expression; end
end

# source://udb//lib/udb/eqn_parser.rb#707
module Eqn::Expression0
  # source://udb//lib/udb/eqn_parser.rb#708
  def disjunction; end
end

# source://udb//lib/udb/eqn_parser.rb#714
module Eqn::Expression1
  # source://udb//lib/udb/eqn_parser.rb#715
  def to_logic_tree(term_map); end
end

# source://udb//lib/udb/eqn_parser.rb#83
module Eqn::Name0; end

# source://udb//lib/udb/eqn_parser.rb#361
module Eqn::Not0
  # source://udb//lib/udb/eqn_parser.rb#362
  def name; end
end

# source://udb//lib/udb/eqn_parser.rb#226
module Eqn::Paren0; end

# source://udb//lib/udb/eqn_parser.rb#229
module Eqn::Paren1
  # source://udb//lib/udb/eqn_parser.rb#230
  def conjunction; end
end

# source://udb//lib/udb/eqn_parser.rb#802
class EqnParser < ::Treetop::Runtime::CompiledParser
  include ::Eqn
end

# source://udb//lib/udb/z3_loader.rb#19
module FFI; end

class FFI::ArrayType < ::FFI::Type; end
class FFI::Buffer < ::FFI::AbstractMemory; end

# source://udb//lib/udb/z3_loader.rb#20
class FFI::DynamicLibrary
  class << self
    # source://udb//lib/udb/z3_loader.rb#24
    def load_library(name, flags); end

    private

    # source://udb//lib/udb/z3_loader.rb#22
    def orig_load_library(name, flags); end
  end
end

class FFI::DynamicLibrary::Symbol < ::FFI::Pointer; end
class FFI::FunctionType < ::FFI::Type; end
module FFI::LastError; end
class FFI::MemoryPointer < ::FFI::Pointer; end
module FFI::NativeType; end
class FFI::NullPointerError < ::RuntimeError; end
class FFI::StructByValue < ::FFI::Type; end
class FFI::Type; end
class FFI::Type::Builtin < ::FFI::Type; end
class FFI::Type::Mapped < ::FFI::Type; end

# source://udb//lib/udb/idl/condition_to_udb.rb#11
module Idl; end

# source://udb//lib/udb/idl/condition_to_udb.rb#140
class Idl::ArrayIncludesAst < ::Idl::AstNode
  # source://udb//lib/udb/idl/condition_to_udb.rb#142
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end
end

# source://udb//lib/udb/idl/condition_to_udb.rb#111
class Idl::AryElementAccessAst < ::Idl::AstNode
  # source://udb//lib/udb/idl/condition_to_udb.rb#113
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end
end

# source://udb//lib/udb/idl/condition_to_udb.rb#12
class Idl::AstNode
  abstract!

  # source://udb//lib/udb/idl/condition_to_udb.rb#18
  sig { overridable.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end
end

# source://udb//lib/udb/idl/condition_to_udb.rb#15
Idl::AstNode::UdbHashType = T.type_alias { T.any(T::Boolean, T::Hash[::String, T.untyped]) }

# source://udb//lib/udb/idl/condition_to_udb.rb#191
class Idl::BinaryExpressionAst < ::Idl::AstNode
  # source://udb//lib/udb/idl/condition_to_udb.rb#201
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end
end

# source://udb//lib/udb/idl/condition_to_udb.rb#192
Idl::BinaryExpressionAst::OP_TO_KEY = T.let(T.unsafe(nil), Hash)

# source://udb//lib/udb/idl/condition_to_udb.rb#51
class Idl::ConstraintBodyAst < ::Idl::AstNode
  # source://udb//lib/udb/idl/condition_to_udb.rb#53
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end
end

# source://udb//lib/udb/idl/condition_to_udb.rb#69
class Idl::FalseExpressionAst < ::Idl::AstNode
  # source://udb//lib/udb/idl/condition_to_udb.rb#71
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end
end

# source://udb//lib/udb/idl/condition_to_udb.rb#86
class Idl::ForLoopAst < ::Idl::AstNode
  # source://udb//lib/udb/idl/condition_to_udb.rb#88
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end
end

# source://udb//lib/udb/idl/condition_to_udb.rb#161
class Idl::FunctionCallExpressionAst < ::Idl::AstNode
  # source://udb//lib/udb/idl/condition_to_udb.rb#163
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end
end

# source://udb//lib/udb/idl/condition_to_udb.rb#74
class Idl::IdAst < ::Idl::AstNode
  # source://udb//lib/udb/idl/condition_to_udb.rb#76
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end
end

# source://udb//lib/udb/idl/condition_to_udb.rb#23
class Idl::ImplicationExpressionAst < ::Idl::AstNode
  # source://udb//lib/udb/idl/condition_to_udb.rb#25
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end
end

# source://udb//lib/udb/idl/condition_to_udb.rb#44
class Idl::ImplicationStatementAst < ::Idl::AstNode
  # source://udb//lib/udb/idl/condition_to_udb.rb#46
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end
end

# source://udb//lib/udb/idl/condition_to_udb.rb#37
class Idl::ParenExpressionAst < ::Idl::AstNode
  # source://udb//lib/udb/idl/condition_to_udb.rb#39
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end
end

# source://udb//lib/udb/idl/condition_to_udb.rb#64
class Idl::TrueExpressionAst < ::Idl::AstNode
  # source://udb//lib/udb/idl/condition_to_udb.rb#66
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end
end

# source://udb//lib/udb/idl/condition_to_udb.rb#124
class Idl::UnaryOperatorExpressionAst < ::Idl::AstNode
  # source://udb//lib/udb/idl/condition_to_udb.rb#126
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end
end

# source://udb//lib/udb/obj/non_isa_specification.rb#15
class NonIsaSpecificationError < ::StandardError; end

# source://udb//lib/udb/obj/non_isa_specification.rb#16
class NonIsaSpecificationLoadError < ::NonIsaSpecificationError; end

# source://udb//lib/udb/obj/non_isa_specification.rb#17
class NonIsaSpecificationValidationError < ::NonIsaSpecificationError; end

# source://udb//lib/udb.rb#7
module Udb
  class << self
    # source://udb//lib/udb/log.rb#134
    sig { params(fmt: ::String, options: T.untyped).returns(T.any(::TTY::ProgressBar, ::Udb::DummyProgressBar)) }
    def create_progressbar(fmt, **options); end

    # source://udb//lib/udb/log.rb#118
    sig do
      params(
        fmt: T.nilable(::String),
        level: ::Udb::LogLevel,
        clear: T::Boolean
      ).returns(T.any(::TTY::ProgressBar::Multi, ::Udb::DummyMultiProgressBar))
    end
    def create_top_level_progressbar(fmt: T.unsafe(nil), level: T.unsafe(nil), clear: T.unsafe(nil)); end

    # source://udb//lib/udb/resolver.rb#60
    sig { returns(::Pathname) }
    def default_cfgs_path; end

    # source://udb//lib/udb/resolver.rb#50
    sig { returns(::Pathname) }
    def default_custom_isa_path; end

    # source://udb//lib/udb/resolver.rb#55
    sig { returns(::Pathname) }
    def default_gen_path; end

    # source://udb//lib/udb/resolver.rb#45
    sig { returns(::Pathname) }
    def default_std_isa_path; end

    # source://udb//lib/udb/log.rb#105
    sig { void }
    def delete_top_level_progressbar; end

    # source://udb//lib/udb/resolver.rb#17
    sig { returns(::Pathname) }
    def gem_path; end

    # source://udb//lib/udb/log.rb#51
    sig { returns(::Udb::LogLevel) }
    def log_level; end

    # source://udb//lib/udb/log.rb#56
    sig { params(level: ::Udb::LogLevel).void }
    def log_level=(level); end

    # source://udb//lib/udb/log.rb#61
    sig { returns(T.any(::Logger, ::TTY::Logger)) }
    def logger; end

    # source://udb//lib/udb/resolver.rb#34
    sig { returns(::Pathname) }
    def repo_root; end

    # source://udb//lib/udb/log.rb#68
    sig { params(logger: T.any(::Logger, ::TTY::Logger)).returns(T.any(::Logger, ::TTY::Logger)) }
    def set_logger(logger); end

    # source://udb//lib/udb/log.rb#100
    sig { returns(T.nilable(::TTY::ProgressBar::Multi)) }
    def top_level_progressbar; end

    # source://udb//lib/udb/version.rb#7
    def version; end

    private

    # source://udb//lib/udb/resolver.rb#22
    sig { params(from_dir: ::Pathname).returns(::Pathname) }
    def find_udb_root(from_dir); end
  end
end

# source://udb//lib/udb/condition.rb#23
class Udb::AbstractCondition
  abstract!

  # source://udb//lib/udb/condition.rb#361
  sig { abstract.params(other: ::Udb::AbstractCondition).returns(::Udb::AbstractCondition) }
  def &(other); end

  # source://udb//lib/udb/condition.rb#374
  sig { abstract.returns(::Udb::AbstractCondition) }
  def -@; end

  # source://udb//lib/udb/condition.rb#270
  sig { params(other_condition: ::Udb::AbstractCondition).returns(T::Boolean) }
  def always_implies?(other_condition); end

  # source://udb//lib/udb/condition.rb#212
  sig { params(other: ::Udb::AbstractCondition).returns(T::Boolean) }
  def compatible?(other); end

  # source://udb//lib/udb/condition.rb#241
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(T::Boolean) }
  def could_be_satisfied_by_cfg_arch?(cfg_arch); end

  # source://udb//lib/udb/condition.rb#255
  sig { params(other_condition: ::Udb::AbstractCondition).returns(T::Boolean) }
  def covered_by?(other_condition); end

  # source://udb//lib/udb/condition.rb#128
  sig { abstract.returns(T::Boolean) }
  def empty?; end

  # source://udb//lib/udb/condition.rb#249
  sig { params(other: ::Udb::AbstractCondition).returns(T::Boolean) }
  def equivalent?(other); end

  # source://udb//lib/udb/condition.rb#186
  sig { params(expand: T::Boolean).returns(T::Array[::Udb::ExtensionRequirement]) }
  def ext_req_terms(expand:); end

  # source://udb//lib/udb/condition.rb#280
  sig { abstract.returns(T::Boolean) }
  def has_extension_requirement?; end

  # source://udb//lib/udb/condition.rb#276
  sig { abstract.returns(T::Boolean) }
  def has_param?; end

  # source://udb//lib/udb/condition.rb#357
  sig { abstract.params(expand: T::Boolean).returns(T::Array[::Udb::ConditionalExtensionRequirement]) }
  def implied_extension_conflicts(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#353
  sig { abstract.params(expand: T::Boolean).returns(T::Array[::Udb::ConditionalExtensionRequirement]) }
  def implied_extension_requirements(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#382
  sig { params(other: ::Udb::AbstractCondition).returns(::Udb::AbstractCondition) }
  def implies(other); end

  # source://udb//lib/udb/condition.rb#148
  sig do
    params(
      term: T.any(::Symbol, ::Udb::Extension, ::Udb::ExtensionRequirement, ::Udb::ExtensionVersion, ::Udb::Parameter, ::Udb::ParameterWithValue),
      expand: T::Boolean
    ).returns(T::Boolean)
  end
  def mentions?(term, expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#162
  sig { params(expand: T::Boolean).returns(T::Boolean) }
  def mentions_xlen?(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#286
  sig { abstract.params(expand: T::Boolean).returns(::Udb::AbstractCondition) }
  def minimize(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#200
  sig { params(expand: T::Boolean).returns(T::Array[::Udb::Parameter]) }
  def param_terms(expand:); end

  # source://udb//lib/udb/condition.rb#221
  sig do
    abstract
      .params(
        ext_reqs: T::Array[::Udb::ExtensionRequirement],
        expand: T::Boolean
      ).returns(::Udb::AbstractCondition)
  end
  def partial_eval(ext_reqs: T.unsafe(nil), expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#226
  sig do
    abstract
      .params(
        cfg_arch: ::Udb::ConfiguredArchitecture,
        expand: T::Boolean
      ).returns(::Udb::AbstractCondition)
  end
  def partially_evaluate_for_params(cfg_arch, expand:); end

  # source://udb//lib/udb/condition.rb#170
  sig { returns(T::Boolean) }
  def rv32_only?; end

  # source://udb//lib/udb/condition.rb#177
  sig { returns(T::Boolean) }
  def rv64_only?; end

  # source://udb//lib/udb/condition.rb#237
  sig { abstract.params(_ext_req: ::Udb::ExtensionRequirement, include_requirements: T::Boolean).returns(T::Boolean) }
  def satisfiability_depends_on_ext_req?(_ext_req, include_requirements: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#140
  sig { abstract.returns(T::Boolean) }
  def satisfiable?; end

  # source://udb//lib/udb/condition.rb#218
  sig { abstract.params(_cfg_arch: ::Udb::ConfiguredArchitecture).returns(::Udb::SatisfiedResult) }
  def satisfied_by_cfg_arch?(_cfg_arch); end

  # source://udb//lib/udb/condition.rb#232
  sig { abstract.params(ext_req: ::Udb::ExtensionRequirement, include_requirements: T::Boolean).returns(T::Boolean) }
  def satisfied_by_ext_req?(ext_req, include_requirements: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#318
  sig { abstract.returns(::String) }
  def to_asciidoc; end

  # source://udb//lib/udb/condition.rb#290
  sig { abstract.returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_h; end

  # source://udb//lib/udb/condition.rb#300
  sig { abstract.params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(::String) }
  def to_idl(cfg_arch); end

  # source://udb//lib/udb/condition.rb#132
  sig { abstract.params(expand: T::Boolean).returns(::Udb::LogicNode) }
  def to_logic_tree(expand:); end

  # source://udb//lib/udb/condition.rb#136
  sig { abstract.returns(::Udb::LogicNode) }
  def to_logic_tree_internal; end

  # source://udb//lib/udb/condition.rb#305
  sig { abstract.params(expand: T::Boolean).returns(::String) }
  def to_s(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#309
  sig { abstract.returns(::String) }
  def to_s_pretty; end

  # source://udb//lib/udb/condition.rb#314
  sig { abstract.params(cfg_arch: ::Udb::ConfiguredArchitecture, expand: T::Boolean).returns(::String) }
  def to_s_with_value(cfg_arch, expand:); end

  # source://udb//lib/udb/condition.rb#294
  sig { overridable.returns(::String) }
  def to_yaml; end

  # source://udb//lib/udb/condition.rb#144
  sig { abstract.returns(T::Boolean) }
  def unsatisfiable?; end

  # source://udb//lib/udb/condition.rb#365
  sig { abstract.params(other: ::Udb::AbstractCondition).returns(::Udb::AbstractCondition) }
  def |(other); end
end

# source://udb//lib/udb/config.rb#28
class Udb::AbstractConfig
  abstract!

  # source://udb//lib/udb/config.rb#86
  sig { params(data: T::Hash[::String, T.untyped], info: ::Udb::Resolver::ConfigInfo).void }
  def initialize(data, info); end

  # source://udb//lib/udb/config.rb#51
  sig { returns(T.nilable(::String)) }
  def arch_overlay; end

  # source://udb//lib/udb/config.rb#56
  sig { returns(T.nilable(::Pathname)) }
  def arch_overlay_abs; end

  # source://udb//lib/udb/config.rb#102
  sig { returns(T::Boolean) }
  def configured?; end

  # source://udb//lib/udb/config.rb#64
  sig { returns(::String) }
  def description; end

  # source://udb//lib/udb/config.rb#70
  sig { abstract.returns(T::Boolean) }
  def fully_configured?; end

  # source://udb//lib/udb/config.rb#61
  sig { returns(::Udb::Resolver::ConfigInfo) }
  def info; end

  # source://udb//lib/udb/config.rb#67
  sig { abstract.returns(T.nilable(::Integer)) }
  def mxlen; end

  # source://udb//lib/udb/config.rb#99
  sig { returns(::String) }
  def name; end

  # source://udb//lib/udb/config.rb#46
  sig { returns(T::Boolean) }
  def overlay?; end

  # source://udb//lib/udb/config.rb#42
  sig do
    abstract
      .returns(T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)])
  end
  def param_values; end

  # source://udb//lib/udb/config.rb#73
  sig { abstract.returns(T::Boolean) }
  def partially_configured?; end

  # source://udb//lib/udb/config.rb#96
  sig { returns(::Udb::ConfigType) }
  def type; end

  # source://udb//lib/udb/config.rb#76
  sig { abstract.returns(T::Boolean) }
  def unconfigured?; end

  class << self
    # source://udb//lib/udb/config.rb#123
    sig do
      params(
        cfg_file_path_or_portfolio_grp: T.any(::Pathname, ::Udb::PortfolioGroup),
        info: ::Udb::Resolver::ConfigInfo
      ).returns(::Udb::AbstractConfig)
    end
    def create(cfg_file_path_or_portfolio_grp, info); end

    private

    # source://udb//lib/udb/config.rb#105
    sig { params(obj: T.untyped).returns(T.untyped) }
    def freeze_data(obj); end
  end
end

# source://udb//lib/udb/config.rb#33
Udb::AbstractConfig::ParamValueType = T.type_alias { T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean) }

# source://udb//lib/udb/condition.rb#1482
class Udb::AlwaysFalseCondition < ::Udb::AbstractCondition
  # source://udb//lib/udb/condition.rb#1486
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).void }
  def initialize(cfg_arch); end

  # source://udb//lib/udb/condition.rb#1563
  sig { override.params(other: ::Udb::AbstractCondition).returns(::Udb::AbstractCondition) }
  def &(other); end

  # source://udb//lib/udb/condition.rb#1573
  sig { override.returns(::Udb::AbstractCondition) }
  def -@; end

  # source://udb//lib/udb/condition.rb#1507
  sig { override.params(_other: T.untyped).returns(T::Boolean) }
  def compatible?(_other); end

  # source://udb//lib/udb/condition.rb#1491
  sig { override.returns(T::Boolean) }
  def empty?; end

  # source://udb//lib/udb/condition.rb#1530
  sig { override.returns(T::Boolean) }
  def has_extension_requirement?; end

  # source://udb//lib/udb/condition.rb#1536
  sig { override.returns(T::Boolean) }
  def has_param?; end

  # source://udb//lib/udb/condition.rb#1559
  sig { override.params(expand: T::Boolean).returns(T::Array[::Udb::ConditionalExtensionRequirement]) }
  def implied_extension_conflicts(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1556
  sig { override.params(expand: T::Boolean).returns(T::Array[::Udb::ConditionalExtensionRequirement]) }
  def implied_extension_requirements(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1533
  sig { override.params(expand: T::Boolean).returns(::Udb::AbstractCondition) }
  def minimize(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1521
  sig do
    override
      .params(
        ext_reqs: T::Array[::Udb::ExtensionRequirement],
        expand: T::Boolean
      ).returns(::Udb::AbstractCondition)
  end
  def partial_eval(ext_reqs: T.unsafe(nil), expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1518
  sig do
    override
      .params(
        cfg_arch: ::Udb::ConfiguredArchitecture,
        expand: T::Boolean
      ).returns(::Udb::AbstractCondition)
  end
  def partially_evaluate_for_params(cfg_arch, expand:); end

  # source://udb//lib/udb/condition.rb#1527
  sig { override.params(ext_req: ::Udb::ExtensionRequirement, include_requirements: T::Boolean).returns(T::Boolean) }
  def satisfiability_depends_on_ext_req?(ext_req, include_requirements: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1578
  sig { override.returns(T::Boolean) }
  def satisfiable?; end

  # source://udb//lib/udb/condition.rb#1515
  sig { override.params(_cfg_arch: ::Udb::ConfiguredArchitecture).returns(::Udb::SatisfiedResult) }
  def satisfied_by_cfg_arch?(_cfg_arch); end

  # source://udb//lib/udb/condition.rb#1524
  sig { override.params(ext_req: ::Udb::ExtensionRequirement, include_requirements: T::Boolean).returns(T::Boolean) }
  def satisfied_by_ext_req?(ext_req, include_requirements: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1553
  sig { override.returns(::String) }
  def to_asciidoc; end

  # source://udb//lib/udb/condition.rb#1510
  sig { override.returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_h; end

  # source://udb//lib/udb/condition.rb#1539
  sig { override.params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(::String) }
  def to_idl(cfg_arch); end

  # source://udb//lib/udb/condition.rb#1494
  sig { override.params(expand: T::Boolean).returns(::Udb::LogicNode) }
  def to_logic_tree(expand:); end

  # source://udb//lib/udb/condition.rb#1502
  sig { override.returns(::Udb::LogicNode) }
  def to_logic_tree_internal; end

  # source://udb//lib/udb/condition.rb#1542
  sig { override.params(expand: T::Boolean).returns(::String) }
  def to_s(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1545
  sig { override.returns(::String) }
  def to_s_pretty; end

  # source://udb//lib/udb/condition.rb#1550
  sig { override.params(cfg_arch: ::Udb::ConfiguredArchitecture, expand: T::Boolean).returns(::String) }
  def to_s_with_value(cfg_arch, expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1581
  sig { override.returns(T::Boolean) }
  def unsatisfiable?; end

  # source://udb//lib/udb/condition.rb#1568
  sig { override.params(other: ::Udb::AbstractCondition).returns(::Udb::AbstractCondition) }
  def |(other); end
end

# source://udb//lib/udb/condition.rb#1380
class Udb::AlwaysTrueCondition < ::Udb::AbstractCondition
  # source://udb//lib/udb/condition.rb#1384
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).void }
  def initialize(cfg_arch); end

  # source://udb//lib/udb/condition.rb#1461
  sig { override.params(other: ::Udb::AbstractCondition).returns(::Udb::AbstractCondition) }
  def &(other); end

  # source://udb//lib/udb/condition.rb#1471
  sig { override.returns(::Udb::AbstractCondition) }
  def -@; end

  # source://udb//lib/udb/condition.rb#1406
  sig { override.params(_other: T.untyped).returns(T::Boolean) }
  def compatible?(_other); end

  # source://udb//lib/udb/condition.rb#1389
  sig { override.returns(T::Boolean) }
  def empty?; end

  # source://udb//lib/udb/condition.rb#1429
  sig { override.returns(T::Boolean) }
  def has_extension_requirement?; end

  # source://udb//lib/udb/condition.rb#1435
  sig { override.returns(T::Boolean) }
  def has_param?; end

  # source://udb//lib/udb/condition.rb#1458
  sig { override.params(expand: T::Boolean).returns(T::Array[::Udb::ConditionalExtensionRequirement]) }
  def implied_extension_conflicts(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1455
  sig { override.params(expand: T::Boolean).returns(T::Array[::Udb::ConditionalExtensionRequirement]) }
  def implied_extension_requirements(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1432
  sig { override.params(expand: T::Boolean).returns(::Udb::AbstractCondition) }
  def minimize(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1420
  sig do
    override
      .params(
        ext_reqs: T::Array[::Udb::ExtensionRequirement],
        expand: T::Boolean
      ).returns(::Udb::AbstractCondition)
  end
  def partial_eval(ext_reqs: T.unsafe(nil), expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1417
  sig do
    override
      .params(
        cfg_arch: ::Udb::ConfiguredArchitecture,
        expand: T::Boolean
      ).returns(::Udb::AbstractCondition)
  end
  def partially_evaluate_for_params(cfg_arch, expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1426
  sig { override.params(ext_req: ::Udb::ExtensionRequirement, include_requirements: T::Boolean).returns(T::Boolean) }
  def satisfiability_depends_on_ext_req?(ext_req, include_requirements: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1476
  sig { override.returns(T::Boolean) }
  def satisfiable?; end

  # source://udb//lib/udb/condition.rb#1414
  sig { override.params(_cfg_arch: ::Udb::ConfiguredArchitecture).returns(::Udb::SatisfiedResult) }
  def satisfied_by_cfg_arch?(_cfg_arch); end

  # source://udb//lib/udb/condition.rb#1423
  sig { override.params(ext_req: ::Udb::ExtensionRequirement, include_requirements: T::Boolean).returns(T::Boolean) }
  def satisfied_by_ext_req?(ext_req, include_requirements: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1452
  sig { override.returns(::String) }
  def to_asciidoc; end

  # source://udb//lib/udb/condition.rb#1409
  sig { override.returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_h; end

  # source://udb//lib/udb/condition.rb#1438
  sig { override.params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(::String) }
  def to_idl(cfg_arch); end

  # source://udb//lib/udb/condition.rb#1392
  sig { override.params(expand: T::Boolean).returns(::Udb::LogicNode) }
  def to_logic_tree(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1401
  sig { override.returns(::Udb::LogicNode) }
  def to_logic_tree_internal; end

  # source://udb//lib/udb/condition.rb#1441
  sig { override.params(expand: T::Boolean).returns(::String) }
  def to_s(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1444
  sig { override.returns(::String) }
  def to_s_pretty; end

  # source://udb//lib/udb/condition.rb#1449
  sig { override.params(cfg_arch: ::Udb::ConfiguredArchitecture, expand: T::Boolean).returns(::String) }
  def to_s_with_value(cfg_arch, expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1479
  sig { override.returns(T::Boolean) }
  def unsatisfiable?; end

  # source://udb//lib/udb/condition.rb#1466
  sig { override.params(other: ::Udb::AbstractCondition).returns(::Udb::AbstractCondition) }
  def |(other); end
end

# source://udb//lib/udb/condition.rb#18
class Udb::Architecture
  # source://udb//lib/udb/architecture.rb#72
  sig { params(arch_dir: T.any(::Pathname, ::String)).void }
  def initialize(arch_dir); end

  # source://udb//lib/udb/architecture.rb#215
  sig { returns(T::Array[::Udb::ExtensionVersion]) }
  def extension_versions; end

  # source://udb//lib/udb/architecture.rb#203
  sig { returns(T::Array[::Udb::TopLevelDatabaseObject]) }
  def objs; end

  # source://udb//lib/udb/architecture.rb#68
  def path; end

  # source://udb//lib/udb/architecture.rb#263
  def portfolio(name); end

  # source://udb//lib/udb/architecture.rb#241
  def portfolio_class(name); end

  # source://udb//lib/udb/architecture.rb#229
  sig { returns(T::Hash[::String, ::Udb::PortfolioClass]) }
  def portfolio_class_hash; end

  # source://udb//lib/udb/architecture.rb#221
  sig { returns(T::Array[::Udb::PortfolioClass]) }
  def portfolio_classes; end

  # source://udb//lib/udb/architecture.rb#251
  def portfolio_hash; end

  # source://udb//lib/udb/architecture.rb#244
  def portfolios; end

  # source://udb//lib/udb/architecture.rb#272
  sig { params(uri: ::String).returns(T.untyped) }
  def ref(uri); end

  # source://udb//lib/udb/architecture.rb#85
  sig { params(resolver: ::Udb::Resolver, show_progress: T::Boolean).void }
  def validate(resolver, show_progress: T.unsafe(nil)); end
end

# source://udb//lib/udb/architecture.rb#96
Udb::Architecture::OBJS = T.let(T.unsafe(nil), Array)

# source://udb//lib/udb/cert_normative_rule.rb#7
class Udb::CertNormativeRule
  # source://udb//lib/udb/cert_normative_rule.rb#10
  def initialize(data, db_obj); end

  # source://udb//lib/udb/cert_normative_rule.rb#22
  def description; end

  # source://udb//lib/udb/cert_normative_rule.rb#28
  def doc_links; end

  # source://udb//lib/udb/cert_normative_rule.rb#25
  def id; end
end

# source://udb//lib/udb/obj/certifiable_obj.rb#9
module Udb::CertifiableObject
  # source://udb//lib/udb/obj/certifiable_obj.rb#11
  def cert_normative_rules; end
end

# source://udb//lib/udb/obj/exception_code.rb#13
module Udb::Code
  # source://udb//lib/udb/obj/exception_code.rb#18
  sig { returns(::String) }
  def display_name; end

  # source://udb//lib/udb/obj/exception_code.rb#26
  sig { returns(::Integer) }
  def num; end

  # source://udb//lib/udb/obj/exception_code.rb#22
  sig { returns(::String) }
  def var; end
end

# source://udb//lib/udb/obj/database_obj.rb#460
class Udb::Company
  # source://udb//lib/udb/obj/database_obj.rb#464
  sig { params(data: T::Hash[::String, ::String]).void }
  def initialize(data); end

  # source://udb//lib/udb/obj/database_obj.rb#470
  sig { returns(::String) }
  def name; end

  # source://udb//lib/udb/obj/database_obj.rb#477
  sig { override.returns(::String) }
  def to_s; end

  # source://udb//lib/udb/obj/database_obj.rb#474
  sig { returns(::String) }
  def url; end
end

# source://udb//lib/udb/condition.rb#390
class Udb::Condition < ::Udb::AbstractCondition
  # source://udb//lib/udb/condition.rb#424
  sig do
    params(
      yaml: T.any(T::Boolean, T::Hash[::String, T.untyped]),
      cfg_arch: ::Udb::ConfiguredArchitecture,
      input_file: T.nilable(::Pathname),
      input_line: T.nilable(::Integer)
    ).void
  end
  def initialize(yaml, cfg_arch, input_file: T.unsafe(nil), input_line: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1347
  sig { override.params(other: ::Udb::AbstractCondition).returns(::Udb::AbstractCondition) }
  def &(other); end

  # source://udb//lib/udb/condition.rb#1357
  sig { override.returns(::Udb::AbstractCondition) }
  def -@; end

  # source://udb//lib/udb/condition.rb#433
  sig { override.returns(T::Boolean) }
  def empty?; end

  # source://udb//lib/udb/condition.rb#626
  sig do
    params(
      tree: ::Udb::LogicNode,
      expansion_clauses: T::Array[::Udb::LogicNode],
      touched_terms: T::Set[T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)]
    ).returns(T::Array[::Udb::LogicNode])
  end
  def expand_term_requirements(tree, expansion_clauses = T.unsafe(nil), touched_terms = T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#525
  sig { params(tree: ::Udb::LogicNode, expansion_clauses: T::Array[::Udb::LogicNode]).void }
  def expand_to_enforce_single_ext_ver(tree, expansion_clauses); end

  # source://udb//lib/udb/condition.rb#804
  sig { override.returns(T::Boolean) }
  def has_extension_requirement?; end

  # source://udb//lib/udb/condition.rb#799
  sig { override.returns(T::Boolean) }
  def has_param?; end

  # source://udb//lib/udb/condition.rb#1165
  sig { override.params(expand: T::Boolean).returns(T::Array[::Udb::ConditionalExtensionRequirement]) }
  def implied_extension_conflicts(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1091
  sig { override.params(expand: T::Boolean).returns(T::Array[::Udb::ConditionalExtensionRequirement]) }
  def implied_extension_requirements(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#811
  sig do
    params(
      blk: T.proc.params(term: T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)).returns(::Udb::SatisfiedResult)
    ).returns(T.proc.params(term: T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)).returns(::Udb::SatisfiedResult))
  end
  def make_cb_proc(&blk); end

  # source://udb//lib/udb/condition.rb#736
  sig { override.params(expand: T::Boolean).returns(::Udb::AbstractCondition) }
  def minimize(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#996
  sig do
    override
      .params(
        ext_reqs: T::Array[::Udb::ExtensionRequirement],
        expand: T::Boolean
      ).returns(::Udb::AbstractCondition)
  end
  def partial_eval(ext_reqs: T.unsafe(nil), expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#817
  sig { override.params(cfg_arch: ::Udb::ConfiguredArchitecture, expand: T::Boolean).returns(::Udb::Condition) }
  def partially_evaluate_for_params(cfg_arch, expand:); end

  # source://udb//lib/udb/condition.rb#987
  sig { override.params(ext_req: ::Udb::ExtensionRequirement, include_requirements: T::Boolean).returns(T::Boolean) }
  def satisfiability_depends_on_ext_req?(ext_req, include_requirements: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#725
  sig { override.returns(T::Boolean) }
  def satisfiable?; end

  # source://udb//lib/udb/condition.rb#897
  sig { override.params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(::Udb::SatisfiedResult) }
  def satisfied_by_cfg_arch?(cfg_arch); end

  # source://udb//lib/udb/condition.rb#971
  sig { override.params(ext_req: ::Udb::ExtensionRequirement, include_requirements: T::Boolean).returns(T::Boolean) }
  def satisfied_by_ext_req?(ext_req, include_requirements: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#704
  sig do
    type_parameters(:U)
      .params(
        blk: T.proc.params(s: ::Udb::Z3Solver).returns(T.type_parameter(:U))
      ).returns(T.type_parameter(:U))
  end
  def solver(&blk); end

  # source://udb//lib/udb/condition.rb#1086
  sig { override.returns(::String) }
  def to_asciidoc; end

  # source://udb//lib/udb/condition.rb#643
  def to_expanded_logic_tree_shallow; end

  # source://udb//lib/udb/condition.rb#1012
  sig { override.returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_h; end

  # source://udb//lib/udb/condition.rb#1017
  sig { override.params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(::String) }
  def to_idl(cfg_arch); end

  # source://udb//lib/udb/condition.rb#659
  sig { override.params(expand: T::Boolean).returns(::Udb::LogicNode) }
  def to_logic_tree(expand:); end

  # source://udb//lib/udb/condition.rb#745
  sig { override.returns(::Udb::LogicNode) }
  def to_logic_tree_internal; end

  # source://udb//lib/udb/condition.rb#1023
  sig { override.params(expand: T::Boolean).returns(::String) }
  def to_s(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#1029
  sig { override.returns(::String) }
  def to_s_pretty; end

  # source://udb//lib/udb/condition.rb#1034
  sig { override.params(cfg_arch: ::Udb::ConfiguredArchitecture, expand: T::Boolean).returns(::String) }
  def to_s_with_value(cfg_arch, expand: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#731
  sig { override.returns(T::Boolean) }
  def unsatisfiable?; end

  # source://udb//lib/udb/condition.rb#1352
  sig { override.params(other: ::Udb::AbstractCondition).returns(::Udb::AbstractCondition) }
  def |(other); end

  private

  # source://udb//lib/udb/condition.rb#436
  sig do
    params(
      term: ::Udb::ExtensionTerm,
      expansion_clauses: T::Array[::Udb::LogicNode],
      touched_terms: T::Set[T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)]
    ).void
  end
  def expand_extension_term_requirements(term, expansion_clauses, touched_terms); end

  # source://udb//lib/udb/condition.rb#452
  sig { params(tree: ::Udb::LogicNode, expansion_clauses: T::Array[::Udb::LogicNode]).void }
  def expand_extension_version_ranges(tree, expansion_clauses); end

  # source://udb//lib/udb/condition.rb#555
  sig do
    params(
      term: ::Udb::ParameterTerm,
      expansion_clauses: T::Array[::Udb::LogicNode],
      touched_terms: T::Set[T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)]
    ).void
  end
  def expand_parameter_term_requirements(term, expansion_clauses, touched_terms); end

  # source://udb//lib/udb/condition.rb#591
  sig { params(tree: ::Udb::LogicNode, expansion_clauses: T::Array[::Udb::LogicNode]).void }
  def expand_to_enforce_param_relations(tree, expansion_clauses); end

  # source://udb//lib/udb/condition.rb#617
  sig { params(tree: ::Udb::LogicNode, expansion_clauses: T::Array[::Udb::LogicNode]).void }
  def expand_xlen(tree, expansion_clauses); end

  # source://udb//lib/udb/condition.rb#755
  sig { overridable.params(yaml: T.any(T::Boolean, T::Hash[::String, T.untyped])).returns(::Udb::LogicNode) }
  def to_logic_tree_helper(yaml); end

  class << self
    # source://udb//lib/udb/condition.rb#1258
    sig do
      params(
        conditions: T::Array[::Udb::AbstractCondition],
        cfg_arch: ::Udb::ConfiguredArchitecture
      ).returns(::Udb::AbstractCondition)
    end
    def conjunction(conditions, cfg_arch); end

    # source://udb//lib/udb/condition.rb#1282
    sig do
      params(
        conditions: T::Array[::Udb::AbstractCondition],
        cfg_arch: ::Udb::ConfiguredArchitecture
      ).returns(::Udb::AbstractCondition)
    end
    def disjunction(conditions, cfg_arch); end

    # source://udb//lib/udb/condition.rb#401
    sig do
      params(
        cfg_arch: ::Udb::ConfiguredArchitecture,
        conds: T::Array[T.all(::Object, ::Udb::AbstractCondition)]
      ).returns(::Udb::AbstractCondition)
    end
    def join(cfg_arch, conds); end

    # source://udb//lib/udb/condition.rb#1329
    sig do
      params(
        condition: ::Udb::AbstractCondition,
        cfg_arch: ::Udb::ConfiguredArchitecture
      ).returns(::Udb::AbstractCondition)
    end
    def not(condition, cfg_arch); end

    # source://udb//lib/udb/condition.rb#1306
    sig do
      params(
        conditions: T::Array[::Udb::AbstractCondition],
        cfg_arch: ::Udb::ConfiguredArchitecture
      ).returns(::Udb::AbstractCondition)
    end
    def one_of(conditions, cfg_arch); end

    # source://udb//lib/udb/condition.rb#695
    def solver; end
  end
end

# source://udb//lib/udb/condition.rb#808
Udb::Condition::EvalCallbackType = T.type_alias { T.proc.params(term: T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)).returns(::Udb::SatisfiedResult) }

# source://udb//lib/udb/condition.rb#411
class Udb::Condition::MemoizedState < ::T::Struct
  prop :satisfied_by_cfg_arch, T::Hash[::Udb::ConfiguredArchitecture, ::Udb::SatisfiedResult]
end

# source://udb//lib/udb/condition.rb#1744
Udb::Condition::Xlen32 = T.let(T.unsafe(nil), Udb::XlenCondition)

# source://udb//lib/udb/condition.rb#1745
Udb::Condition::Xlen64 = T.let(T.unsafe(nil), Udb::XlenCondition)

# source://udb//lib/udb/condition.rb#26
class Udb::ConditionalExtensionRequirement < ::T::Struct
  prop :ext_req, ::Udb::ExtensionRequirement
  prop :cond, ::Udb::AbstractCondition
end

# source://udb//lib/udb/condition.rb#32
class Udb::ConditionalExtensionVersion < ::T::Struct
  prop :ext_ver, ::Udb::ExtensionVersion
  prop :cond, ::Udb::AbstractCondition
end

# source://udb//lib/udb/config.rb#15
class Udb::ConfigType < ::T::Enum
  enums do
    Full = new
    Partial = new
    UnConfig = new
  end
end

# source://udb//lib/udb/condition.rb#19
class Udb::ConfiguredArchitecture < ::Udb::Architecture
  # source://udb//lib/udb/cfg_arch.rb#548
  sig { params(name: ::String, config: ::Udb::AbstractConfig).void }
  def initialize(name, config); end

  # source://udb//lib/udb/cfg_arch.rb#51
  sig { returns(::Udb::AbstractConfig) }
  def config; end

  # source://udb//lib/udb/cfg_arch.rb#239
  sig { returns(::Udb::ConfigType) }
  def config_type; end

  # source://udb//lib/udb/cfg_arch.rb#1316
  sig { params(adoc: ::String).returns(::String) }
  def convert_monospace_to_links(adoc); end

  # source://udb//lib/udb/cfg_arch.rb#628
  def csr(name); end

  # source://udb//lib/udb/cfg_arch.rb#620
  def csr_hash; end

  # source://udb//lib/udb/cfg_arch.rb#604
  def csrs; end

  # source://udb//lib/udb/cfg_arch.rb#191
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def eql?(other); end

  # source://udb//lib/udb/cfg_arch.rb#628
  def exception_code(name); end

  # source://udb//lib/udb/cfg_arch.rb#620
  def exception_code_hash; end

  # source://udb//lib/udb/cfg_arch.rb#604
  def exception_codes; end

  # source://udb//lib/udb/cfg_arch.rb#830
  sig { params(ext_vers: T::Array[::Udb::ExtensionVersion]).returns(T::Array[::Udb::ExtensionVersion]) }
  def expand_implemented_extension_list(ext_vers); end

  # source://udb//lib/udb/cfg_arch.rb#774
  def explicitly_implemented_extension_versions; end

  # source://udb//lib/udb/cfg_arch.rb#1014
  def ext?(ext_name, ext_version_requirements = T.unsafe(nil)); end

  # source://udb//lib/udb/cfg_arch.rb#628
  def extension(name); end

  # source://udb//lib/udb/cfg_arch.rb#620
  def extension_hash; end

  # source://udb//lib/udb/cfg_arch.rb#780
  sig do
    params(
      name: ::String,
      requirements: T.any(::String, ::Udb::RequirementSpec, T::Array[::String], T::Array[::Udb::RequirementSpec])
    ).returns(::Udb::ExtensionRequirement)
  end
  def extension_requirement(name, requirements); end

  # source://udb//lib/udb/cfg_arch.rb#812
  sig { params(name: ::String, version: T.any(::String, ::Udb::VersionSpec)).returns(::Udb::ExtensionVersion) }
  def extension_version(name, version); end

  # source://udb//lib/udb/cfg_arch.rb#604
  def extensions; end

  # source://udb//lib/udb/cfg_arch.rb#1080
  sig { returns(::Idl::FetchAst) }
  def fetch; end

  # source://udb//lib/udb/cfg_arch.rb#54
  sig { returns(T::Boolean) }
  def fully_configured?; end

  # source://udb//lib/udb/cfg_arch.rb#1074
  sig { params(name: ::String).returns(T.nilable(::Idl::FunctionDefAst)) }
  def function(name); end

  # source://udb//lib/udb/cfg_arch.rb#1069
  sig { returns(T::Hash[::String, ::Idl::FunctionDefAst]) }
  def function_hash; end

  # source://udb//lib/udb/cfg_arch.rb#1064
  sig { returns(T::Array[::Idl::FunctionDefAst]) }
  def functions; end

  # source://udb//lib/udb/cfg_arch.rb#214
  sig { returns(::Idl::IsaAst) }
  def global_ast; end

  # source://udb//lib/udb/cfg_arch.rb#1086
  sig { returns(T::Array[T.any(::Idl::GlobalAst, ::Idl::GlobalWithInitializationAst)]) }
  def globals; end

  # source://udb//lib/udb/cfg_arch.rb#188
  sig { override.returns(::Integer) }
  def hash; end

  # source://udb//lib/udb/cfg_arch.rb#41
  sig { returns(::Idl::Compiler) }
  def idl_compiler; end

  # source://udb//lib/udb/cfg_arch.rb#1094
  sig { returns(T::Array[::Udb::Csr]) }
  def implemented_csrs; end

  # source://udb//lib/udb/cfg_arch.rb#1050
  sig { returns(T::Array[::Udb::ExceptionCode]) }
  def implemented_exception_codes; end

  # source://udb//lib/udb/cfg_arch.rb#850
  sig { params(ext_name: ::String).returns(T.nilable(::Udb::ExtensionVersion)) }
  def implemented_extension_version(ext_name); end

  # source://udb//lib/udb/cfg_arch.rb#760
  sig { returns(T::Array[::Udb::ExtensionVersion]) }
  def implemented_extension_versions; end

  # source://udb//lib/udb/cfg_arch.rb#1202
  sig { returns(T::Array[::Idl::FunctionDefAst]) }
  def implemented_functions; end

  # source://udb//lib/udb/cfg_arch.rb#1133
  sig { returns(T::Array[::Udb::Instruction]) }
  def implemented_instructions; end

  # source://udb//lib/udb/cfg_arch.rb#1057
  sig { returns(T::Array[::Udb::InterruptCode]) }
  def implemented_interrupt_codes; end

  # source://udb//lib/udb/cfg_arch.rb#1457
  sig { returns(T::Array[T.untyped]) }
  def implemented_non_isa_specs; end

  # source://udb//lib/udb/cfg_arch.rb#569
  def inspect; end

  # source://udb//lib/udb/cfg_arch.rb#628
  def instruction(name); end

  # source://udb//lib/udb/cfg_arch.rb#620
  def instruction_hash; end

  # source://udb//lib/udb/cfg_arch.rb#628
  def instruction_subtype(name); end

  # source://udb//lib/udb/cfg_arch.rb#620
  def instruction_subtype_hash; end

  # source://udb//lib/udb/cfg_arch.rb#604
  def instruction_subtypes; end

  # source://udb//lib/udb/cfg_arch.rb#628
  def instruction_type(name); end

  # source://udb//lib/udb/cfg_arch.rb#620
  def instruction_type_hash; end

  # source://udb//lib/udb/cfg_arch.rb#604
  def instruction_types; end

  # source://udb//lib/udb/cfg_arch.rb#604
  def instructions; end

  # source://udb//lib/udb/cfg_arch.rb#628
  def interrupt_code(name); end

  # source://udb//lib/udb/cfg_arch.rb#620
  def interrupt_code_hash; end

  # source://udb//lib/udb/cfg_arch.rb#604
  def interrupt_codes; end

  # source://udb//lib/udb/cfg_arch.rb#1196
  sig { returns(::Integer) }
  def largest_encoding; end

  # source://udb//lib/udb/cfg_arch.rb#859
  sig { returns(T::Array[::Udb::ExtensionRequirement]) }
  def mandatory_extension_reqs; end

  # source://udb//lib/udb/cfg_arch.rb#628
  def manual(name); end

  # source://udb//lib/udb/cfg_arch.rb#620
  def manual_hash; end

  # source://udb//lib/udb/cfg_arch.rb#628
  def manual_version(name); end

  # source://udb//lib/udb/cfg_arch.rb#620
  def manual_version_hash; end

  # source://udb//lib/udb/cfg_arch.rb#604
  def manual_versions; end

  # source://udb//lib/udb/cfg_arch.rb#604
  def manuals; end

  # source://udb//lib/udb/cfg_arch.rb#81
  sig { returns(T::Boolean) }
  def multi_xlen?; end

  # source://udb//lib/udb/cfg_arch.rb#103
  sig { params(mode: ::String).returns(T::Boolean) }
  def multi_xlen_in_mode?(mode); end

  # source://udb//lib/udb/cfg_arch.rb#64
  sig { returns(T.nilable(::Integer)) }
  def mxlen; end

  # source://udb//lib/udb/cfg_arch.rb#48
  sig { returns(::String) }
  def name; end

  # source://udb//lib/udb/cfg_arch.rb#1129
  def not_prohibited_csrs(*args, **_arg1, &blk); end

  # source://udb//lib/udb/cfg_arch.rb#912
  def not_prohibited_extensions(*args, **_arg1, &blk); end

  # source://udb//lib/udb/cfg_arch.rb#1192
  def not_prohibited_instructions(*args, **_arg1, &blk); end

  # source://udb//lib/udb/cfg_arch.rb#879
  sig { returns(T::Array[::Udb::ExtensionRequirement]) }
  def optional_extension_versions; end

  # source://udb//lib/udb/cfg_arch.rb#744
  sig { returns(T::Array[::Udb::Parameter]) }
  def out_of_scope_params; end

  # source://udb//lib/udb/cfg_arch.rb#628
  def param(name); end

  # source://udb//lib/udb/cfg_arch.rb#620
  def param_hash; end

  # source://udb//lib/udb/cfg_arch.rb#68
  sig { returns(T::Hash[::String, T.untyped]) }
  def param_values; end

  # source://udb//lib/udb/cfg_arch.rb#604
  def params; end

  # source://udb//lib/udb/cfg_arch.rb#719
  sig { returns(T::Array[::Udb::ParameterWithValue]) }
  def params_with_value; end

  # source://udb//lib/udb/cfg_arch.rb#734
  sig { returns(T::Array[::Udb::Parameter]) }
  def params_without_value; end

  # source://udb//lib/udb/cfg_arch.rb#57
  sig { returns(T::Boolean) }
  def partially_configured?; end

  # source://udb//lib/udb/cfg_arch.rb#1112
  sig { params(show_progress: T::Boolean).returns(T::Array[::Udb::Csr]) }
  def possible_csrs(show_progress: T.unsafe(nil)); end

  # source://udb//lib/udb/cfg_arch.rb#924
  def possible_extension_versions; end

  # source://udb//lib/udb/cfg_arch.rb#899
  sig { returns(T::Array[::Udb::Extension]) }
  def possible_extensions; end

  # source://udb//lib/udb/cfg_arch.rb#1168
  sig { params(show_progress: T::Boolean).returns(T::Array[::Udb::Instruction]) }
  def possible_instructions(show_progress: T.unsafe(nil)); end

  # source://udb//lib/udb/cfg_arch.rb#1426
  sig { returns(T::Array[T.untyped]) }
  def possible_non_isa_specs; end

  # source://udb//lib/udb/cfg_arch.rb#183
  sig { returns(T::Array[::Integer]) }
  def possible_xlens; end

  # source://udb//lib/udb/cfg_arch.rb#628
  def prm(name); end

  # source://udb//lib/udb/cfg_arch.rb#620
  def prm_hash; end

  # source://udb//lib/udb/cfg_arch.rb#604
  def prms; end

  # source://udb//lib/udb/cfg_arch.rb#628
  def proc_cert_class(name); end

  # source://udb//lib/udb/cfg_arch.rb#620
  def proc_cert_class_hash; end

  # source://udb//lib/udb/cfg_arch.rb#604
  def proc_cert_classes; end

  # source://udb//lib/udb/cfg_arch.rb#628
  def proc_cert_model(name); end

  # source://udb//lib/udb/cfg_arch.rb#620
  def proc_cert_model_hash; end

  # source://udb//lib/udb/cfg_arch.rb#604
  def proc_cert_models; end

  # source://udb//lib/udb/cfg_arch.rb#628
  def profile(name); end

  # source://udb//lib/udb/cfg_arch.rb#604
  def profile_families; end

  # source://udb//lib/udb/cfg_arch.rb#628
  def profile_family(name); end

  # source://udb//lib/udb/cfg_arch.rb#620
  def profile_family_hash; end

  # source://udb//lib/udb/cfg_arch.rb#620
  def profile_hash; end

  # source://udb//lib/udb/cfg_arch.rb#628
  def profile_release(name); end

  # source://udb//lib/udb/cfg_arch.rb#620
  def profile_release_hash; end

  # source://udb//lib/udb/cfg_arch.rb#604
  def profile_releases; end

  # source://udb//lib/udb/cfg_arch.rb#604
  def profiles; end

  # source://udb//lib/udb/cfg_arch.rb#990
  sig { params(ext: T.any(::String, ::Symbol, ::Udb::ExtensionVersion)).returns(T::Boolean) }
  def prohibited_ext?(ext); end

  # source://udb//lib/udb/cfg_arch.rb#918
  sig { returns(T::Array[::Udb::ExtensionVersion]) }
  def prohibited_extension_versions; end

  # source://udb//lib/udb/cfg_arch.rb#1149
  sig { returns(T::Array[::Udb::Instruction]) }
  def prohibited_instructions; end

  # source://udb//lib/udb/cfg_arch.rb#1248
  sig { params(show_progress: T::Boolean).returns(T::Array[::Idl::FunctionDefAst]) }
  def reachable_functions(show_progress: T.unsafe(nil)); end

  # source://udb//lib/udb/cfg_arch.rb#628
  def register_file(name); end

  # source://udb//lib/udb/cfg_arch.rb#620
  def register_file_hash; end

  # source://udb//lib/udb/cfg_arch.rb#604
  def register_files; end

  # source://udb//lib/udb/cfg_arch.rb#1408
  sig { params(erb_template: ::String, what: ::String).returns(::String) }
  def render_erb(erb_template, what = T.unsafe(nil)); end

  # source://udb//lib/udb/cfg_arch.rb#199
  sig { returns(::Idl::SymbolTable) }
  def symtab; end

  # source://udb//lib/udb/cfg_arch.rb#1108
  def transitive_implemented_csrs; end

  # source://udb//lib/udb/cfg_arch.rb#777
  def transitive_implemented_extension_versions; end

  # source://udb//lib/udb/cfg_arch.rb#1145
  def transitive_implemented_instructions; end

  # source://udb//lib/udb/cfg_arch.rb#1468
  def transitive_implemented_non_isa_specs; end

  # source://udb//lib/udb/cfg_arch.rb#1164
  def transitive_prohibited_instructions; end

  # source://udb//lib/udb/cfg_arch.rb#648
  sig { params(show_progress: T::Boolean, io: ::IO).void }
  def type_check(show_progress: T.unsafe(nil), io: T.unsafe(nil)); end

  # source://udb//lib/udb/cfg_arch.rb#60
  sig { returns(T::Boolean) }
  def unconfigured?; end

  # source://udb//lib/udb/cfg_arch.rb#249
  sig { returns(::Udb::ConfiguredArchitecture::ValidationResult) }
  def valid?; end

  private

  # source://udb//lib/udb/cfg_arch.rb#458
  sig { returns(::Idl::SymbolTable) }
  def create_symtab; end

  # source://udb//lib/udb/cfg_arch.rb#1343
  sig { returns(::Object) }
  def erb_env; end

  # source://udb//lib/udb/cfg_arch.rb#261
  sig { returns(::Udb::ConfiguredArchitecture::ValidationResult) }
  def full_config_valid?; end

  # source://udb//lib/udb/cfg_arch.rb#323
  sig { returns(::Udb::ConfiguredArchitecture::ValidationResult) }
  def partial_config_valid?; end

  # source://udb//lib/udb/cfg_arch.rb#381
  sig { returns(::Idl::SymbolTable::BuiltinFunctionCallbacks) }
  def symtab_callbacks; end

  # source://udb//lib/udb/cfg_arch.rb#435
  sig { returns(T::Array[::Idl::SymbolTable::EnumDef]) }
  def symtab_enums; end

  class << self
    # source://udb//lib/udb/cfg_arch.rb#600
    sig { params(fn_name: ::String, arch_dir: ::String, obj_class: T.class_of(Udb::TopLevelDatabaseObject)).void }
    def generate_obj_methods(fn_name, arch_dir, obj_class); end
  end
end

# source://udb//lib/udb/cfg_arch.rb#530
class Udb::ConfiguredArchitecture::MemoizedState < ::T::Struct
  prop :multi_xlen_in_mode, T::Hash[::String, T::Boolean]
  prop :multi_xlen, T.nilable(T::Boolean)
  prop :params_with_value, T.nilable(T::Array[::Udb::ParameterWithValue])
  prop :params_without_value, T.nilable(T::Array[::Udb::Parameter])
  prop :out_of_scope_params, T.nilable(T::Array[::Udb::Parameter])
  prop :implemented_extension_versions, T.nilable(T::Array[::Udb::ExtensionVersion])
  prop :implemented_extension_version_hash, T.nilable(T::Hash[::String, ::Udb::ExtensionVersion])
  prop :extension_requirements_hash, T::Hash[::String, ::Udb::ExtensionRequirement]
  prop :extension_versions_hash, T::Hash[::String, ::Udb::ExtensionVersion]
end

# source://udb//lib/udb/cfg_arch.rb#242
class Udb::ConfiguredArchitecture::ValidationResult < ::T::Struct
  const :valid, T::Boolean
  const :reasons, T::Array[::String]
end

# source://udb//lib/udb/condition.rb#38
class Udb::Constraint
  # source://udb//lib/udb/condition.rb#53
  sig do
    params(
      idl: ::String,
      input_file: T.nilable(::Pathname),
      input_line: T.nilable(::Integer),
      cfg_arch: ::Udb::ConfiguredArchitecture,
      reason: T.nilable(::String)
    ).void
  end
  def initialize(idl, input_file:, input_line:, cfg_arch:, reason: T.unsafe(nil)); end

  # source://udb//lib/udb/condition.rb#67
  sig { params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def eval(symtab); end

  # source://udb//lib/udb/condition.rb#42
  sig { returns(T.nilable(::String)) }
  def reason; end

  # source://udb//lib/udb/condition.rb#73
  sig { returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_h; end

  # source://udb//lib/udb/condition.rb#91
  sig { returns(::Udb::LogicNode) }
  def to_logic_tree_internal; end

  # source://udb//lib/udb/condition.rb#83
  sig { returns(::String) }
  def to_yaml; end
end

# source://udb//lib/udb/obj/csr.rb#16
class Udb::Csr < ::Udb::TopLevelDatabaseObject
  include ::Udb::CertifiableObject
  include ::Idl::Csr

  # source://udb//lib/udb/obj/csr.rb#27
  sig do
    params(
      data: T::Hash[::String, T.untyped],
      data_path: T.any(::Pathname, ::String),
      arch: ::Udb::ConfiguredArchitecture
    ).void
  end
  def initialize(data, data_path, arch); end

  # source://udb//lib/udb/obj/csr.rb#36
  def ==(other); end

  # source://udb//lib/udb/obj/csr.rb#46
  def address; end

  # source://udb//lib/udb/obj/csr.rb#730
  def affected_by?(ext_ver); end

  # source://udb//lib/udb/obj/csr.rb#95
  sig { returns(T.nilable(::Integer)) }
  def base; end

  # source://udb//lib/udb/obj/csr.rb#516
  def bitfield_type(cfg_arch, effective_xlen = T.unsafe(nil)); end

  # source://udb//lib/udb/obj/csr.rb#115
  def defined_in_all_bases?; end

  # source://udb//lib/udb/obj/csr.rb#109
  def defined_in_base32?; end

  # source://udb//lib/udb/obj/csr.rb#112
  def defined_in_base64?; end

  # source://udb//lib/udb/obj/csr.rb#119
  def defined_in_base?(xlen); end

  # source://udb//lib/udb/obj/csr.rb#430
  sig { returns(T::Array[::Udb::ExtensionRequirement]) }
  def defining_extension_requirements; end

  # source://udb//lib/udb/obj/csr.rb#421
  def description_html; end

  # source://udb//lib/udb/obj/csr.rb#170
  def dynamic_length?; end

  # source://udb//lib/udb/obj/csr.rb#713
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(T::Boolean) }
  def exists_in_cfg?(cfg_arch); end

  # source://udb//lib/udb/obj/csr.rb#510
  def field(field_name); end

  # source://udb//lib/udb/obj/csr.rb#505
  def field?(field_name); end

  # source://udb//lib/udb/obj/csr.rb#493
  def field_hash; end

  # source://udb//lib/udb/obj/csr.rb#478
  sig { override.returns(T::Array[::Udb::CsrField]) }
  def fields; end

  # source://udb//lib/udb/obj/csr.rb#488
  sig { params(effective_xlen: T.nilable(::Integer)).returns(T::Array[::Udb::CsrField]) }
  def fields_for(effective_xlen); end

  # source://udb//lib/udb/obj/csr.rb#594
  def fill_symtab(ast, effective_xlen); end

  # source://udb//lib/udb/obj/csr.rb#122
  def format_changes_with_xlen?; end

  # source://udb//lib/udb/obj/csr.rb#526
  def has_custom_sw_read?; end

  # source://udb//lib/udb/obj/csr.rb#51
  def indirect?; end

  # source://udb//lib/udb/obj/csr.rb#56
  def indirect_address; end

  # source://udb//lib/udb/obj/csr.rb#61
  def indirect_slot; end

  # source://udb//lib/udb/obj/csr.rb#216
  sig { override.params(effective_xlen: T.nilable(::Integer)).returns(T.nilable(::Integer)) }
  def length(effective_xlen = T.unsafe(nil)); end

  # source://udb//lib/udb/obj/csr.rb#337
  def length_cond32; end

  # source://udb//lib/udb/obj/csr.rb#353
  def length_cond64; end

  # source://udb//lib/udb/obj/csr.rb#370
  def length_pretty(effective_xlen = T.unsafe(nil)); end

  # source://udb//lib/udb/obj/csr.rb#70
  def long_name; end

  # source://udb//lib/udb/obj/csr.rb#267
  sig { override.returns(::Integer) }
  def max_length; end

  # source://udb//lib/udb/obj/csr.rb#203
  def min_length; end

  # source://udb//lib/udb/obj/csr.rb#401
  def modes_with_access; end

  # source://udb//lib/udb/obj/csr.rb#34
  sig { override.returns(::String) }
  def name; end

  # source://udb//lib/udb/obj/csr.rb#720
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(T::Boolean) }
  def optional_in_cfg?(cfg_arch); end

  # source://udb//lib/udb/obj/csr.rb#470
  sig { returns(T::Array[::Udb::CsrField]) }
  def possible_fields; end

  # source://udb//lib/udb/obj/csr.rb#456
  def possible_fields_for(effective_xlen); end

  # source://udb//lib/udb/obj/csr.rb#66
  def priv_mode; end

  # source://udb//lib/udb/obj/csr.rb#627
  def pruned_sw_read_ast(effective_xlen); end

  # source://udb//lib/udb/obj/csr.rb#131
  sig { params(effective_xlen: T.nilable(::Integer)).returns(T::Array[::Idl::FunctionDefAst]) }
  def reachable_functions(effective_xlen = T.unsafe(nil)); end

  # source://udb//lib/udb/obj/csr.rb#86
  def reset_value(*args, **_arg1, &blk); end

  # source://udb//lib/udb/obj/csr.rb#568
  def sw_read_ast(symtab); end

  # source://udb//lib/udb/obj/csr.rb#532
  sig { params(effective_xlen: T.nilable(::Integer)).returns(::Idl::FunctionBodyAst) }
  def type_checked_sw_read_ast(effective_xlen); end

  # source://udb//lib/udb/obj/csr.rb#81
  sig { override.returns(T.nilable(::Integer)) }
  def value; end

  # source://udb//lib/udb/obj/csr.rb#76
  def virtual_address; end

  # source://udb//lib/udb/obj/csr.rb#665
  def wavedrom_desc(cfg_arch, effective_xlen, exclude_unimplemented: T.unsafe(nil), optional_type: T.unsafe(nil)); end

  # source://udb//lib/udb/obj/csr.rb#88
  def writable; end
end

# source://udb//lib/udb/obj/csr.rb#22
class Udb::Csr::MemoizedState < ::T::Struct
  prop :reachable_functions, T::Hash[T.any(::Integer, ::Symbol), T::Array[::Idl::FunctionDefAst]]
end

# source://udb//lib/udb/obj/csr_field.rb#16
class Udb::CsrField < ::Udb::DatabaseObject
  include ::Udb::CertifiableObject
  include ::Idl::CsrField

  # source://udb//lib/udb/obj/csr_field.rb#57
  sig { params(parent_csr: ::Udb::Csr, field_name: ::String, field_data: T::Hash[::String, T.untyped]).void }
  def initialize(parent_csr, field_name, field_data); end

  # source://udb//lib/udb/obj/csr_field.rb#64
  def __source; end

  # source://udb//lib/udb/obj/csr_field.rb#109
  sig { params(ext_ver: ::Udb::ExtensionVersion).returns(T::Boolean) }
  def affected_by?(ext_ver); end

  # source://udb//lib/udb/obj/csr_field.rb#282
  sig { returns(T.nilable(::Udb::CsrField::Alias)) }
  def alias; end

  # source://udb//lib/udb/obj/csr_field.rb#37
  sig { returns(T.nilable(::Integer)) }
  def base; end

  # source://udb//lib/udb/obj/csr_field.rb#695
  sig { override.returns(T::Boolean) }
  def base32_only?; end

  # source://udb//lib/udb/obj/csr_field.rb#691
  sig { override.returns(T::Boolean) }
  def base64_only?; end

  # source://udb//lib/udb/obj/csr_field.rb#346
  def csr(*args, **_arg1, &blk); end

  # source://udb//lib/udb/obj/csr_field.rb#708
  sig { override.returns(T::Boolean) }
  def defined_in_all_bases?; end

  # source://udb//lib/udb/obj/csr_field.rb#698
  sig { override.returns(T::Boolean) }
  def defined_in_base32?; end

  # source://udb//lib/udb/obj/csr_field.rb#701
  sig { override.returns(T::Boolean) }
  def defined_in_base64?; end

  # source://udb//lib/udb/obj/csr_field.rb#704
  sig { params(xlen: ::Integer).returns(T::Boolean) }
  def defined_in_base?(xlen); end

  # source://udb//lib/udb/obj/csr_field.rb#351
  sig { returns(T::Boolean) }
  def dynamic_location?; end

  # source://udb//lib/udb/obj/csr_field.rb#441
  sig { returns(T::Boolean) }
  def dynamic_reset_value?; end

  # source://udb//lib/udb/obj/csr_field.rb#92
  sig { override.returns(T::Boolean) }
  def exists?; end

  # source://udb//lib/udb/obj/csr_field.rb#77
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(T::Boolean) }
  def exists_in_cfg?(cfg_arch); end

  # source://udb//lib/udb/obj/csr_field.rb#593
  def fill_symtab_for_reset(ast); end

  # source://udb//lib/udb/obj/csr_field.rb#533
  sig { params(effective_xlen: T.nilable(::Integer), ast: ::Idl::AstNode).returns(::Idl::SymbolTable) }
  def fill_symtab_for_sw_write(effective_xlen, ast); end

  # source://udb//lib/udb/obj/csr_field.rb#565
  sig { params(effective_xlen: T.nilable(::Integer), ast: ::Idl::AstNode).returns(::Idl::SymbolTable) }
  def fill_symtab_for_type(effective_xlen, ast); end

  # source://udb//lib/udb/obj/csr_field.rb#465
  sig { returns(T::Boolean) }
  def has_custom_sw_write?; end

  # source://udb//lib/udb/obj/csr_field.rb#644
  sig { override.params(effective_xlen: T.nilable(::Integer)).returns(T::Range[::Integer]) }
  def location(effective_xlen = T.unsafe(nil)); end

  # source://udb//lib/udb/obj/csr_field.rb#732
  sig { returns(::String) }
  def location_cond32; end

  # source://udb//lib/udb/obj/csr_field.rb#748
  sig { returns(::String) }
  def location_cond64; end

  # source://udb//lib/udb/obj/csr_field.rb#766
  sig { params(effective_xlen: T.nilable(::Integer)).returns(::String) }
  def location_pretty(effective_xlen = T.unsafe(nil)); end

  # source://udb//lib/udb/obj/csr_field.rb#718
  sig { returns(::Integer) }
  def max_width; end

  # source://udb//lib/udb/obj/csr_field.rb#96
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(T::Boolean) }
  def optional_in_cfg?(cfg_arch); end

  # source://udb//lib/udb/obj/csr_field.rb#26
  sig { returns(::Udb::Csr) }
  def parent; end

  # source://udb//lib/udb/obj/csr_field.rb#401
  sig { returns(T.nilable(::Idl::FunctionBodyAst)) }
  def pruned_reset_value_ast; end

  # source://udb//lib/udb/obj/csr_field.rb#612
  sig { params(effective_xlen: T.nilable(::Integer)).returns(T.nilable(::Idl::AstNode)) }
  def pruned_sw_write_ast(effective_xlen); end

  # source://udb//lib/udb/obj/csr_field.rb#173
  sig { params(effective_xlen: T.nilable(::Integer)).returns(T.nilable(::Idl::FunctionBodyAst)) }
  def pruned_type_ast(effective_xlen); end

  # source://udb//lib/udb/obj/csr_field.rb#312
  sig { params(effective_xlen: T.nilable(::Integer)).returns(T::Array[::Idl::FunctionDefAst]) }
  def reachable_functions(effective_xlen); end

  # source://udb//lib/udb/obj/csr_field.rb#420
  sig do
    override
      .returns(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)]))
  end
  def reset_value; end

  # source://udb//lib/udb/obj/csr_field.rb#362
  sig { returns(T.nilable(::Idl::FunctionBodyAst)) }
  def reset_value_ast; end

  # source://udb//lib/udb/obj/csr_field.rb#451
  sig { returns(::String) }
  def reset_value_pretty; end

  # source://udb//lib/udb/obj/csr_field.rb#68
  sig { params(path: T::Array[T.any(::Integer, ::String)]).returns(::Integer) }
  def source_line(path); end

  # source://udb//lib/udb/obj/csr_field.rb#512
  sig { params(symtab: ::Idl::SymbolTable).returns(T.nilable(::Idl::FunctionBodyAst)) }
  def sw_write_ast(symtab); end

  # source://udb//lib/udb/obj/csr_field.rb#216
  sig { override.params(effective_xlen: T.nilable(::Integer)).returns(T.nilable(::String)) }
  def type(effective_xlen = T.unsafe(nil)); end

  # source://udb//lib/udb/obj/csr_field.rb#118
  sig { returns(T.nilable(::Idl::FunctionBodyAst)) }
  def type_ast; end

  # source://udb//lib/udb/obj/csr_field.rb#380
  sig { returns(T.nilable(::Idl::FunctionBodyAst)) }
  def type_checked_reset_value_ast; end

  # source://udb//lib/udb/obj/csr_field.rb#473
  sig do
    params(
      symtab: ::Idl::SymbolTable,
      effective_xlen: T.nilable(::Integer)
    ).returns(T.nilable(::Idl::FunctionBodyAst))
  end
  def type_checked_sw_write_ast(symtab, effective_xlen); end

  # source://udb//lib/udb/obj/csr_field.rb#144
  sig { params(effective_xlen: T.nilable(::Integer)).returns(T.nilable(::Idl::FunctionBodyAst)) }
  def type_checked_type_ast(effective_xlen); end

  # source://udb//lib/udb/obj/csr_field.rb#852
  sig { params(effective_xlen: T.nilable(::Integer)).returns(::String) }
  def type_desc(effective_xlen = T.unsafe(nil)); end

  # source://udb//lib/udb/obj/csr_field.rb#271
  sig { params(effective_xlen: T.nilable(::Integer)).returns(::String) }
  def type_pretty(effective_xlen = T.unsafe(nil)); end

  # source://udb//lib/udb/obj/csr_field.rb#713
  sig { override.params(effective_xlen: T.nilable(::Integer)).returns(::Integer) }
  def width(effective_xlen); end
end

# source://udb//lib/udb/obj/csr_field.rb#32
class Udb::CsrField::Alias < ::Struct
  # source://udb//lib/udb/obj/csr_field.rb#32
  def field; end

  # source://udb//lib/udb/obj/csr_field.rb#32
  def field=(_); end

  # source://udb//lib/udb/obj/csr_field.rb#32
  def range; end

  # source://udb//lib/udb/obj/csr_field.rb#32
  def range=(_); end

  class << self
    # source://udb//lib/udb/obj/csr_field.rb#32
    def [](*_arg0); end

    # source://udb//lib/udb/obj/csr_field.rb#32
    def inspect; end

    # source://udb//lib/udb/obj/csr_field.rb#32
    def keyword_init?; end

    # source://udb//lib/udb/obj/csr_field.rb#32
    def members; end

    # source://udb//lib/udb/obj/csr_field.rb#32
    def new(*_arg0); end
  end
end

# source://udb//lib/udb/obj/csr_field.rb#50
class Udb::CsrField::MemoizedState < ::T::Struct
  prop :reachable_functions, T::Hash[T.any(::Integer, ::Symbol), T::Array[::Idl::FunctionDefAst]]
end

# source://udb//lib/udb/obj/csr_field.rb#801
Udb::CsrField::TYPE_DESC_MAP = T.let(T.unsafe(nil), Hash)

# source://udb//lib/udb/condition.rb#16
class Udb::DatabaseObject
  # source://udb//lib/udb/obj/database_obj.rb#89
  sig do
    params(
      data: T::Hash[::String, T.untyped],
      data_path: T.any(::Pathname, ::String),
      arch: ::Udb::ConfiguredArchitecture,
      kind: ::Udb::DatabaseObject::Kind,
      name: T.nilable(::String)
    ).void
  end
  def initialize(data, data_path, arch, kind, name: T.unsafe(nil)); end

  # source://udb//lib/udb/obj/database_obj.rb#117
  sig { override.params(other: T.untyped).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # source://udb//lib/udb/obj/database_obj.rb#127
  sig { returns(T.nilable(::String)) }
  def __source; end

  # source://udb//lib/udb/obj/database_obj.rb#64
  sig { returns(::Udb::ConfiguredArchitecture) }
  def arch; end

  # source://udb//lib/udb/obj/database_obj.rb#69
  sig { returns(::Udb::ConfiguredArchitecture) }
  def cfg_arch; end

  # source://udb//lib/udb/obj/database_obj.rb#76
  sig { returns(T::Boolean) }
  def cfg_arch?; end

  # source://udb//lib/udb/obj/database_obj.rb#110
  sig { params(arch: T.nilable(::Udb::Architecture)).returns(::Udb::DatabaseObject) }
  def clone(arch: T.unsafe(nil)); end

  # source://udb//lib/udb/obj/database_obj.rb#46
  sig { returns(T::Hash[::String, T.untyped]) }
  def data; end

  # source://udb//lib/udb/obj/database_obj.rb#49
  sig { returns(::Pathname) }
  def data_path; end

  # source://udb//lib/udb/obj/database_obj.rb#137
  sig { params(fn_name: ::Symbol, _block: T.proc.void).returns(T.untyped) }
  def defer(fn_name, &_block); end

  # source://udb//lib/udb/obj/database_obj.rb#146
  sig { returns(::Udb::AbstractCondition) }
  def defined_by_condition; end

  # source://udb//lib/udb/obj/database_obj.rb#169
  sig do
    params(
      normative: T::Boolean,
      non_normative: T::Boolean,
      when_cb: T.proc.params(when_ast: ::Idl::AstNode, text: ::String).returns(T::Array[::String])
    ).returns(::String)
  end
  def description(normative: T.unsafe(nil), non_normative: T.unsafe(nil), when_cb: T.unsafe(nil)); end

  # source://udb//lib/udb/obj/database_obj.rb#131
  def inspect; end

  # source://udb//lib/udb/obj/database_obj.rb#58
  sig { returns(::String) }
  def kind; end

  # source://udb//lib/udb/obj/database_obj.rb#55
  sig { returns(::String) }
  def long_name; end

  # source://udb//lib/udb/obj/database_obj.rb#52
  sig { returns(::String) }
  def name; end

  # source://udb//lib/udb/obj/database_obj.rb#245
  sig { params(path: T::Array[T.any(::Integer, ::String)]).returns(::Integer) }
  def source_line(path); end
end

# source://udb//lib/udb/obj/database_obj.rb#21
class Udb::DatabaseObject::Kind < ::T::Enum
  enums do
    Csr = new
    CsrField = new
    ExceptionCode = new
    Extension = new
    Instruction = new
    InstructionSubtype = new
    InstructionType = new
    InterruptCode = new
    Manual = new
    ManualVersion = new
    NonIsaSpec = new
    Parameter = new
    Prm = new
    ProcessorCertificateClass = new
    ProcessorCertificateModel = new
    Profile = new
    ProfileFamily = new
    ProfileRelease = new
    RegisterFile = new
  end
end

# source://udb//lib/udb/doc_link.rb#32
class Udb::DocLink
  # source://udb//lib/udb/doc_link.rb#35
  def initialize(dst_link, db_obj); end

  # source://udb//lib/udb/doc_link.rb#43
  def dst_link; end

  # source://udb//lib/udb/doc_link.rb#46
  def to_adoc; end
end

# source://udb//lib/udb/log.rb#88
class Udb::DummyMultiProgressBar
  # source://udb//lib/udb/log.rb#92
  sig { params(fmt: ::String, options: T.untyped).returns(::Udb::DummyProgressBar) }
  def register(fmt, **options); end
end

# source://udb//lib/udb/log.rb#74
class Udb::DummyProgressBar
  # source://udb//lib/udb/log.rb#78
  sig { void }
  def advance; end

  # source://udb//lib/udb/log.rb#83
  sig { void }
  def finish; end
end

# source://udb//lib/udb/eqn.rb#17
class Udb::Eqn
  # source://udb//lib/udb/eqn.rb#184
  sig { params(eqn: ::String).void }
  def initialize(eqn); end

  # source://udb//lib/udb/eqn.rb#190
  sig do
    params(
      term_map: T::Hash[::String, T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)]
    ).returns(::Udb::LogicNode)
  end
  def to_logic_tree(term_map); end
end

# source://udb//lib/udb/eqn.rb#19
Udb::Eqn::EQN_GRAMMAR = T.let(T.unsafe(nil), String)

# source://udb//lib/udb/eqn.rb#119
class Udb::Eqn::EmptyEqnParen < ::Treetop::Runtime::SyntaxNode
  # source://udb//lib/udb/eqn.rb#122
  sig do
    params(
      term_map: T::Hash[::String, T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)]
    ).returns(::Udb::LogicNode)
  end
  def to_logic_tree(term_map); end
end

# source://udb//lib/udb/eqn.rb#143
class Udb::Eqn::EqnAnd < ::Treetop::Runtime::SyntaxNode
  # source://udb//lib/udb/eqn.rb#146
  sig do
    params(
      term_map: T::Hash[::String, T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)]
    ).returns(::Udb::LogicNode)
  end
  def to_logic_tree(term_map); end
end

# source://udb//lib/udb/eqn.rb#91
class Udb::Eqn::EqnName < ::Treetop::Runtime::SyntaxNode
  # source://udb//lib/udb/eqn.rb#94
  sig do
    params(
      term_map: T::Hash[::String, T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)]
    ).returns(::Udb::LogicNode)
  end
  def to_logic_tree(term_map); end
end

# source://udb//lib/udb/eqn.rb#135
class Udb::Eqn::EqnNot < ::Treetop::Runtime::SyntaxNode
  # source://udb//lib/udb/eqn.rb#138
  sig do
    params(
      term_map: T::Hash[::String, T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)]
    ).returns(::Udb::LogicNode)
  end
  def to_logic_tree(term_map); end
end

# source://udb//lib/udb/eqn.rb#103
class Udb::Eqn::EqnOne < ::Treetop::Runtime::SyntaxNode
  # source://udb//lib/udb/eqn.rb#106
  sig do
    params(
      term_map: T::Hash[::String, T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)]
    ).returns(::Udb::LogicNode)
  end
  def to_logic_tree(term_map); end
end

# source://udb//lib/udb/eqn.rb#156
class Udb::Eqn::EqnOr < ::Treetop::Runtime::SyntaxNode
  # source://udb//lib/udb/eqn.rb#159
  sig do
    params(
      term_map: T::Hash[::String, T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)]
    ).returns(::Udb::LogicNode)
  end
  def to_logic_tree(term_map); end
end

# source://udb//lib/udb/eqn.rb#127
class Udb::Eqn::EqnParen < ::Treetop::Runtime::SyntaxNode
  # source://udb//lib/udb/eqn.rb#130
  sig do
    params(
      term_map: T::Hash[::String, T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)]
    ).returns(::Udb::LogicNode)
  end
  def to_logic_tree(term_map); end
end

# source://udb//lib/udb/eqn.rb#83
class Udb::Eqn::EqnTop < ::Treetop::Runtime::SyntaxNode
  # source://udb//lib/udb/eqn.rb#86
  sig do
    params(
      term_map: T::Hash[::String, T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)]
    ).returns(::Udb::LogicNode)
  end
  def to_logic_tree(term_map); end
end

# source://udb//lib/udb/eqn.rb#111
class Udb::Eqn::EqnZero < ::Treetop::Runtime::SyntaxNode
  # source://udb//lib/udb/eqn.rb#114
  sig do
    params(
      term_map: T::Hash[::String, T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)]
    ).returns(::Udb::LogicNode)
  end
  def to_logic_tree(term_map); end
end

# source://udb//lib/udb/obj/exception_code.rb#30
class Udb::ExceptionCode < ::Udb::TopLevelDatabaseObject
  include ::Udb::Code
  include ::Comparable

  # source://udb//lib/udb/obj/exception_code.rb#49
  sig { override.params(other: ::BasicObject).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # source://udb//lib/udb/obj/exception_code.rb#56
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def eql?(other); end

  # source://udb//lib/udb/obj/exception_code.rb#61
  sig { override.returns(::Integer) }
  def hash; end

  # source://udb//lib/udb/obj/exception_code.rb#36
  sig { override.params(resolver: ::Udb::Resolver).void }
  def validate(resolver); end
end

# source://udb//lib/udb/condition.rb#20
class Udb::Extension < ::Udb::TopLevelDatabaseObject
  include ::Udb::CertifiableObject
  include ::Comparable

  # source://udb//lib/udb/obj/extension.rb#385
  sig { override.params(other_ext: ::Object).returns(T.nilable(::Integer)) }
  def <=>(other_ext); end

  # source://udb//lib/udb/obj/extension.rb#188
  sig { returns(T::Array[::Udb::Parameter]) }
  def all_params_that_must_be_implemented; end

  # source://udb//lib/udb/obj/extension.rb#33
  sig { returns(::String) }
  def compact_priv_type; end

  # source://udb//lib/udb/obj/extension.rb#51
  sig { returns(T.nilable(::Udb::Company)) }
  def company; end

  # source://udb//lib/udb/obj/extension.rb#143
  sig { returns(T::Array[::Udb::Extension::ConditionallyApplicableParameter]) }
  def conditional_params; end

  # source://udb//lib/udb/obj/extension.rb#214
  def conflicting_extensions; end

  # source://udb//lib/udb/obj/extension.rb#300
  sig { returns(T::Array[::Udb::Csr]) }
  def csrs; end

  # source://udb//lib/udb/obj/extension.rb#357
  sig { returns(T::Array[::Udb::Csr]) }
  def csrs_that_must_be_implemented; end

  # source://udb//lib/udb/obj/extension.rb#60
  sig { returns(T.nilable(T::Hash[::String, ::String])) }
  def doc_license; end

  # source://udb//lib/udb/obj/extension.rb#392
  sig { returns(T::Array[::Udb::ExceptionCode]) }
  def exception_codes; end

  # source://udb//lib/udb/obj/extension.rb#200
  sig { returns(::Udb::AbstractCondition) }
  def general_extension_requirements_condition; end

  # source://udb//lib/udb/obj/extension.rb#332
  sig { returns(T::Array[::Udb::Csr]) }
  def implied_csrs; end

  # source://udb//lib/udb/obj/extension.rb#267
  sig { returns(T::Array[::Udb::Instruction]) }
  def implied_instructions; end

  # source://udb//lib/udb/obj/extension.rb#293
  sig { returns(T::Set[::Udb::Instruction]) }
  def implied_instructions_set; end

  # source://udb//lib/udb/obj/extension.rb#167
  sig { returns(T::Array[::Udb::Parameter]) }
  def implied_params; end

  # source://udb//lib/udb/obj/extension.rb#226
  sig { returns(T::Array[::Udb::Instruction]) }
  def instructions; end

  # source://udb//lib/udb/obj/extension.rb#255
  sig { returns(T::Set[::Udb::Instruction]) }
  def instructions_set; end

  # source://udb//lib/udb/obj/extension.rb#406
  sig { returns(T::Array[::Udb::InterruptCode]) }
  def interrupt_codes; end

  # source://udb//lib/udb/obj/extension.rb#25
  sig { returns(::String) }
  def long_name; end

  # source://udb//lib/udb/obj/extension.rb#94
  sig { returns(::Udb::ExtensionVersion) }
  def max_version; end

  # source://udb//lib/udb/obj/extension.rb#100
  sig { returns(T.nilable(::Udb::ExtensionVersion)) }
  def min_ratified_version; end

  # source://udb//lib/udb/obj/extension.rb#88
  sig { returns(::Udb::ExtensionVersion) }
  def min_version; end

  # source://udb//lib/udb/obj/extension.rb#109
  sig { returns(T::Array[::Udb::Parameter]) }
  def params; end

  # source://udb//lib/udb/obj/extension.rb#29
  sig { returns(::String) }
  def priv_type; end

  # source://udb//lib/udb/obj/extension.rb#84
  sig { returns(T::Boolean) }
  def ratified; end

  # source://udb//lib/udb/obj/extension.rb#78
  sig { returns(T::Array[::Udb::ExtensionVersion]) }
  def ratified_versions; end

  # source://udb//lib/udb/obj/extension.rb#365
  sig { returns(T::Array[::Idl::FunctionDefAst]) }
  def reachable_functions; end

  # source://udb//lib/udb/obj/extension.rb#209
  sig { returns(::Udb::AbstractCondition) }
  def requirements_condition; end

  # source://udb//lib/udb/obj/extension.rb#194
  sig { returns(::Udb::Condition) }
  def to_condition; end

  # source://udb//lib/udb/obj/extension.rb#420
  sig { returns(::Udb::ExtensionRequirement) }
  def to_ext_req; end

  # source://udb//lib/udb/obj/extension.rb#66
  sig { returns(T::Array[::Udb::ExtensionVersion]) }
  def versions; end
end

# source://udb//lib/udb/obj/extension.rb#137
class Udb::Extension::ConditionallyApplicableParameter < ::T::Struct
  prop :cond, ::Udb::AbstractCondition
  prop :param, ::Udb::Parameter
end

# source://udb//lib/udb/condition.rb#1642
class Udb::ExtensionCondition < ::Udb::Condition
  # source://udb//lib/udb/condition.rb#1646
  sig { params(yaml: T::Hash[::String, T.untyped], cfg_arch: ::Udb::ConfiguredArchitecture).void }
  def initialize(yaml, cfg_arch); end

  # source://udb//lib/udb/condition.rb#1651
  sig { override.returns(::Udb::LogicNode) }
  def to_logic_tree_internal; end

  private

  # source://udb//lib/udb/condition.rb#1663
  sig { params(yaml: T::Hash[::String, T.untyped], cfg_arch: ::Udb::ConfiguredArchitecture).returns(::Udb::LogicNode) }
  def ext_req_to_logic_node(yaml, cfg_arch); end

  # source://udb//lib/udb/condition.rb#1677
  sig { override.params(yaml: T.any(T::Boolean, T::Hash[::String, T.untyped])).returns(::Udb::LogicNode) }
  def to_logic_tree_helper(yaml); end
end

# source://udb//lib/udb/condition.rb#22
class Udb::ExtensionRequirement
  # source://udb//lib/udb/obj/extension.rb#1332
  sig do
    params(
      name: ::String,
      requirements: T.any(::String, ::Udb::RequirementSpec, T::Array[::String], T::Array[::Udb::RequirementSpec]),
      arch: ::Udb::ConfiguredArchitecture
    ).void
  end
  def initialize(name, requirements, arch:); end

  # source://udb//lib/udb/obj/extension.rb#1681
  sig { override.params(other: T.untyped).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # source://udb//lib/udb/obj/extension.rb#1672
  sig { params(other: ::Object).returns(T::Boolean) }
  def ==(other); end

  # source://udb//lib/udb/obj/extension.rb#1521
  sig { returns(T::Array[::Udb::Instruction]) }
  def all_instructions_that_must_be_implemented; end

  # source://udb//lib/udb/obj/extension.rb#1208
  sig { returns(::Udb::ConfiguredArchitecture) }
  def cfg_arch; end

  # source://udb//lib/udb/obj/extension.rb#1615
  sig { params(other_ext_req: ::Udb::ExtensionRequirement).returns(T::Boolean) }
  def compatible?(other_ext_req); end

  # source://udb//lib/udb/obj/extension.rb#1417
  sig { returns(T.any(::FalseClass, T::Hash[::String, T.untyped])) }
  def condition_hash; end

  # source://udb//lib/udb/obj/extension.rb#1527
  sig { returns(T::Array[::Udb::Csr]) }
  def csrs; end

  # source://udb//lib/udb/obj/extension.rb#1689
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def eql?(other); end

  # source://udb//lib/udb/obj/extension.rb#1248
  sig { returns(::Udb::Extension) }
  def extension; end

  # source://udb//lib/udb/obj/extension.rb#1696
  sig { override.returns(::Integer) }
  def hash; end

  # source://udb//lib/udb/obj/extension.rb#1493
  sig { returns(T::Array[::Udb::Instruction]) }
  def implied_instructions; end

  # source://udb//lib/udb/obj/extension.rb#1514
  sig { returns(T::Set[::Udb::Instruction]) }
  def implied_instructions_set; end

  # source://udb//lib/udb/obj/extension.rb#1461
  def implied_params; end

  # source://udb//lib/udb/obj/extension.rb#1472
  sig { returns(T::Array[::Udb::Instruction]) }
  def instructions; end

  # source://udb//lib/udb/obj/extension.rb#1481
  sig { returns(T::Set[::Udb::Instruction]) }
  def instructions_set; end

  # source://udb//lib/udb/obj/extension.rb#1364
  def invert!; end

  # source://udb//lib/udb/obj/extension.rb#1312
  sig { returns(T::Boolean) }
  def is_ext_ver?; end

  # source://udb//lib/udb/obj/extension.rb#1579
  sig { returns(::Udb::ExtensionVersion) }
  def max_satisfying_ext_ver; end

  # source://udb//lib/udb/obj/extension.rb#1622
  sig { params(other_ext_req: ::Udb::ExtensionRequirement).returns(::Udb::ExtensionRequirement) }
  def merge(other_ext_req); end

  # source://udb//lib/udb/obj/extension.rb#1559
  sig { returns(::Udb::ExtensionVersion) }
  def min_satisfying_ext_ver; end

  # source://udb//lib/udb/obj/extension.rb#1196
  def name; end

  # source://udb//lib/udb/obj/extension.rb#1453
  sig { returns(T::Array[T.any(::Udb::Parameter, ::Udb::ParameterWithValue)]) }
  def params; end

  # source://udb//lib/udb/obj/extension.rb#1535
  sig { returns(T::Array[::Idl::FunctionDefAst]) }
  def reachable_functions; end

  # source://udb//lib/udb/obj/extension.rb#1220
  sig { returns(T::Array[::Udb::RequirementSpec]) }
  def requirement_specs; end

  # source://udb//lib/udb/obj/extension.rb#1223
  def requirement_specs_to_s_pretty; end

  # source://udb//lib/udb/obj/extension.rb#1388
  sig { returns(::Udb::AbstractCondition) }
  def requirements_condition; end

  # source://udb//lib/udb/obj/extension.rb#1212
  sig { returns(T::Boolean) }
  def satified_by_any_version?; end

  # source://udb//lib/udb/obj/extension.rb#1642
  def satisfied_by?(*args); end

  # source://udb//lib/udb/obj/extension.rb#1375
  sig { returns(T::Array[::Udb::ExtensionVersion]) }
  def satisfying_versions; end

  # source://udb//lib/udb/obj/extension.rb#1606
  sig { params(other_ext_req: ::Udb::ExtensionRequirement).returns(T::Boolean) }
  def subset?(other_ext_req); end

  # source://udb//lib/udb/obj/extension.rb#1598
  sig { params(other_ext_req: ::Udb::ExtensionRequirement).returns(T::Boolean) }
  def superset?(other_ext_req); end

  # source://udb//lib/udb/obj/extension.rb#1410
  sig { returns(::Udb::Condition) }
  def to_condition; end

  # source://udb//lib/udb/obj/extension.rb#1317
  sig { returns(::Udb::ExtensionVersion) }
  def to_ext_ver; end

  # source://udb//lib/udb/obj/extension.rb#1701
  sig { returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://udb//lib/udb/obj/extension.rb#1232
  sig { override.returns(::String) }
  def to_s; end

  # source://udb//lib/udb/obj/extension.rb#1238
  sig { returns(::String) }
  def to_s_pretty; end

  # source://udb//lib/udb/obj/extension.rb#1199
  sig { returns(::Udb::ExtensionTerm) }
  def to_term; end

  # source://udb//lib/udb/obj/extension.rb#1371
  sig { returns(T::Boolean) }
  def valid?; end

  class << self
    # source://udb//lib/udb/obj/extension.rb#1276
    sig { params(ext_vers: T::Array[::Udb::ExtensionVersion]).returns(::Udb::ExtensionRequirement) }
    def create_from_ext_vers(ext_vers); end

    # source://udb//lib/udb/obj/extension.rb#1259
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        cfg_arch: ::Udb::ConfiguredArchitecture
      ).returns(::Udb::ExtensionRequirement)
    end
    def create_from_yaml(yaml, cfg_arch); end

    private

    # source://udb//lib/udb/obj/extension.rb#1362
    def new(*_arg0); end
  end
end

# source://udb//lib/udb/condition.rb#1824
class Udb::ExtensionRequirementList
  # source://udb//lib/udb/condition.rb#1835
  sig { params(yaml: T::Hash[::String, T.untyped], cfg_arch: ::Udb::ConfiguredArchitecture).void }
  def initialize(yaml, cfg_arch); end

  # source://udb//lib/udb/condition.rb#1855
  sig { params(yaml: T::Hash[::String, T.untyped], l: T::Array[::Udb::ConditionalExtensionRequirement]).void }
  def do_list(yaml, l); end

  # source://udb//lib/udb/condition.rb#1875
  sig { returns(T::Array[::Udb::ConditionalExtensionVersion]) }
  def implied_extension_versions; end

  # source://udb//lib/udb/condition.rb#1866
  sig { returns(T::Array[::Udb::ConditionalExtensionRequirement]) }
  def list; end

  # source://udb//lib/udb/condition.rb#1843
  sig { params(yaml: T::Hash[::String, T.untyped]).returns(::Udb::ConditionalExtensionRequirement) }
  def make_cond_ext_req(yaml); end
end

# source://udb//lib/udb/condition.rb#1827
class Udb::ExtensionRequirementList::ParseState < ::T::Enum
  enums do
    Condition = new
    ExtensionCondition = new
  end
end

# source://udb//lib/udb/logic.rb#111
class Udb::ExtensionTerm
  include ::Comparable

  # source://udb//lib/udb/logic.rb#144
  sig do
    params(
      name: ::String,
      op: T.any(::String, ::Udb::ExtensionTerm::ComparisonOp),
      ver: T.any(::String, ::Udb::VersionSpec)
    ).void
  end
  def initialize(name, op, ver); end

  # source://udb//lib/udb/logic.rb#257
  sig { override.params(other: T.untyped).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # source://udb//lib/udb/logic.rb#141
  sig { returns(::Udb::ExtensionTerm::ComparisonOp) }
  def comparison; end

  # source://udb//lib/udb/logic.rb#290
  sig { override.params(other: T.untyped).returns(T::Boolean) }
  def eql?(other); end

  # source://udb//lib/udb/logic.rb#282
  sig { override.returns(::Integer) }
  def hash; end

  # source://udb//lib/udb/logic.rb#158
  sig { returns(T::Boolean) }
  def matches_any_version?; end

  # source://udb//lib/udb/logic.rb#234
  sig { returns(::Udb::VersionSpec) }
  def max_possible_version; end

  # source://udb//lib/udb/logic.rb#219
  def min_possible_version; end

  # source://udb//lib/udb/logic.rb#135
  sig { returns(::String) }
  def name; end

  # source://udb//lib/udb/logic.rb#208
  sig { returns(::Udb::RequirementSpec) }
  def requirement_spec; end

  # source://udb//lib/udb/logic.rb#176
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(::Udb::Condition) }
  def to_condition(cfg_arch); end

  # source://udb//lib/udb/logic.rb#163
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(::Udb::ExtensionRequirement) }
  def to_ext_req(cfg_arch); end

  # source://udb//lib/udb/logic.rb#169
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(::Udb::ExtensionVersion) }
  def to_ext_ver(cfg_arch); end

  # source://udb//lib/udb/logic.rb#191
  sig { returns(T::Hash[::String, ::String]) }
  def to_h; end

  # source://udb//lib/udb/logic.rb#199
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(::String) }
  def to_idl(cfg_arch); end

  # source://udb//lib/udb/logic.rb#181
  sig { override.returns(::String) }
  def to_s; end

  # source://udb//lib/udb/logic.rb#186
  sig { returns(::String) }
  def to_s_pretty; end

  # source://udb//lib/udb/logic.rb#213
  sig { params(solver: ::Udb::Z3Solver, cfg_arch: ::Udb::ConfiguredArchitecture).returns(::Z3::BoolExpr) }
  def to_z3(solver, cfg_arch); end

  # source://udb//lib/udb/logic.rb#138
  sig { returns(::Udb::VersionSpec) }
  def version; end
end

# source://udb//lib/udb/logic.rb#115
class Udb::ExtensionTerm::ComparisonOp < ::T::Enum
  include ::Comparable

  enums do
    Compatible = new
    Equal = new
    GreaterThan = new
    GreaterThanOrEqual = new
    LessThan = new
    LessThanOrEqual = new
  end

  # source://udb//lib/udb/logic.rb#118
  def eql?(other); end

  # source://udb//lib/udb/logic.rb#122
  def hash; end
end

# source://udb//lib/udb/condition.rb#21
class Udb::ExtensionVersion
  include ::Comparable

  # source://udb//lib/udb/obj/extension.rb#498
  sig do
    params(
      name: ::String,
      version_spec: ::Udb::VersionSpec,
      arch: ::Udb::ConfiguredArchitecture,
      fail_if_version_does_not_exist: T::Boolean
    ).void
  end
  def initialize(name, version_spec, arch, fail_if_version_does_not_exist: T.unsafe(nil)); end

  # source://udb//lib/udb/obj/extension.rb#1128
  sig { override.params(other: T.untyped).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # source://udb//lib/udb/obj/extension.rb#733
  sig { returns(T::Array[::Udb::Csr]) }
  def all_csrs_that_must_be_implemented; end

  # source://udb//lib/udb/obj/extension.rb#695
  sig { returns(T::Array[::Udb::Instruction]) }
  def all_instructions_that_must_be_implemented; end

  # source://udb//lib/udb/obj/extension.rb#447
  sig { returns(::Udb::ConfiguredArchitecture) }
  def arch; end

  # source://udb//lib/udb/obj/extension.rb#599
  sig { returns(T::Boolean) }
  def breaking?; end

  # source://udb//lib/udb/obj/extension.rb#605
  sig { returns(::String) }
  def canonical_version; end

  # source://udb//lib/udb/obj/extension.rb#629
  sig { returns(T.nilable(T::Array[::String])) }
  def changes; end

  # source://udb//lib/udb/obj/extension.rb#595
  sig { params(other: ::Udb::ExtensionVersion).returns(T::Boolean) }
  def compatible?(other); end

  # source://udb//lib/udb/obj/extension.rb#579
  sig { returns(T::Array[::Udb::ExtensionVersion]) }
  def compatible_versions; end

  # source://udb//lib/udb/obj/extension.rb#567
  sig { returns(T.any(::FalseClass, T::Hash[::String, T.untyped])) }
  def condition_hash; end

  # source://udb//lib/udb/obj/extension.rb#927
  sig { params(expand: T::Boolean).returns(T::Array[::Udb::ConditionalExtensionRequirement]) }
  def conditional_extension_requirements(expand:); end

  # source://udb//lib/udb/obj/extension.rb#636
  sig { returns(T::Array[::Udb::Person]) }
  def contributors; end

  # source://udb//lib/udb/obj/extension.rb#706
  sig { returns(T::Array[::Udb::Csr]) }
  def csrs; end

  # source://udb//lib/udb/obj/extension.rb#788
  sig { returns(T::Array[::Udb::ConditionalExtensionRequirement]) }
  def defining_extension_requirements; end

  # source://udb//lib/udb/obj/extension.rb#658
  sig { returns(T::Array[::Udb::Instruction]) }
  def directly_defined_instructions; end

  # source://udb//lib/udb/obj/extension.rb#667
  sig { returns(T::Set[::Udb::Instruction]) }
  def directly_defined_instructions_set; end

  # source://udb//lib/udb/obj/extension.rb#608
  sig { override.params(other: T.untyped).returns(T::Boolean) }
  def eql?(other); end

  # source://udb//lib/udb/obj/extension.rb#1141
  sig { returns(T::Array[::Udb::ExceptionCode]) }
  def exception_codes; end

  # source://udb//lib/udb/obj/extension.rb#436
  sig { returns(::Udb::Extension) }
  def ext; end

  # source://udb//lib/udb/obj/extension.rb#1115
  sig { params(expand: T::Boolean).returns(T::Array[::Udb::ConditionalExtensionRequirement]) }
  def ext_conflicts(expand:); end

  # source://udb//lib/udb/obj/extension.rb#1101
  sig { params(expand: T::Boolean).returns(T::Array[::Udb::ConditionalExtensionRequirement]) }
  def ext_requirements(expand:); end

  # source://udb//lib/udb/obj/extension.rb#617
  sig { override.returns(::Integer) }
  def hash; end

  # source://udb//lib/udb/obj/extension.rb#714
  sig { returns(T::Array[::Udb::Csr]) }
  def implied_csrs; end

  # source://udb//lib/udb/obj/extension.rb#672
  sig { returns(T::Array[::Udb::Instruction]) }
  def implied_instructions; end

  # source://udb//lib/udb/obj/extension.rb#701
  sig { returns(T::Set[::Udb::Instruction]) }
  def implied_instructions_set; end

  # source://udb//lib/udb/obj/extension.rb#1163
  sig { params(xlens: T::Array[::Integer]).returns(T::Array[::Udb::Csr]) }
  def in_scope_csrs(xlens); end

  # source://udb//lib/udb/obj/extension.rb#1170
  sig { params(xlens: T::Array[::Integer]).returns(T::Array[::Udb::Instruction]) }
  def in_scope_instructions(xlens); end

  # source://udb//lib/udb/obj/extension.rb#530
  def inspect; end

  # source://udb//lib/udb/obj/extension.rb#1154
  sig { returns(T::Array[::Udb::InterruptCode]) }
  def interrupt_codes; end

  # source://udb//lib/udb/obj/extension.rb#432
  sig { returns(::String) }
  def name; end

  # source://udb//lib/udb/obj/extension.rb#648
  sig { returns(T::Array[T.any(::Udb::Parameter, ::Udb::ParameterWithValue)]) }
  def params; end

  # source://udb//lib/udb/obj/extension.rb#626
  sig { returns(T.nilable(::String)) }
  def ratification_date; end

  # source://udb//lib/udb/obj/extension.rb#768
  sig { returns(::Udb::AbstractCondition) }
  def requirements_condition; end

  # source://udb//lib/udb/obj/extension.rb#623
  sig { returns(::String) }
  def state; end

  # source://udb//lib/udb/obj/extension.rb#561
  sig { returns(::Udb::AbstractCondition) }
  def to_condition; end

  # source://udb//lib/udb/obj/extension.rb#1177
  sig { returns(::Udb::ExtensionRequirement) }
  def to_ext_req; end

  # source://udb//lib/udb/obj/extension.rb#1182
  sig { returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://udb//lib/udb/obj/extension.rb#742
  sig { returns(::String) }
  def to_rvi_s; end

  # source://udb//lib/udb/obj/extension.rb#748
  sig { returns(::String) }
  def to_s; end

  # source://udb//lib/udb/obj/extension.rb#556
  sig { returns(::Udb::ExtensionTerm) }
  def to_term; end

  # source://udb//lib/udb/obj/extension.rb#871
  sig { params(expand: T::Boolean).returns(T::Array[::Udb::ExtensionRequirement]) }
  def unconditional_extension_conflicts(expand:); end

  # source://udb//lib/udb/obj/extension.rb#798
  sig { params(expand: T::Boolean).returns(T::Array[::Udb::ExtensionRequirement]) }
  def unconditional_extension_requirements(expand:); end

  # source://udb//lib/udb/obj/extension.rb#856
  sig { returns(T::Array[::Udb::ExtensionVersion]) }
  def unconditional_extension_version_conflicts; end

  # source://udb//lib/udb/obj/extension.rb#632
  sig { returns(T.nilable(::String)) }
  def url; end

  # source://udb//lib/udb/obj/extension.rb#527
  sig { returns(T::Boolean) }
  def valid?; end

  # source://udb//lib/udb/obj/extension.rb#440
  sig { returns(::Udb::VersionSpec) }
  def version_spec; end

  # source://udb//lib/udb/obj/extension.rb#754
  sig { returns(::Udb::AbstractCondition) }
  def version_specific_requirements_condition; end

  # source://udb//lib/udb/obj/extension.rb#444
  sig { returns(::String) }
  def version_str; end

  class << self
    # source://udb//lib/udb/obj/extension.rb#456
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        cfg_arch: ::Udb::ConfiguredArchitecture
      ).returns(::Udb::ExtensionVersion)
    end
    def create(yaml, cfg_arch); end

    # source://udb//lib/udb/obj/extension.rb#542
    sig { params(ext_vers: T::Array[::Udb::ExtensionVersion]).returns(::Udb::ExtensionRequirement) }
    def to_ext_req(ext_vers); end

    private

    # source://udb//lib/udb/obj/extension.rb#523
    def new(*_arg0); end
  end
end

# source://udb//lib/udb/obj/extension.rb#477
class Udb::ExtensionVersion::MemomizedState < ::T::Struct
  prop :unconditional_expanded_ext_reqs, T.nilable(T::Array[::Udb::ExtensionRequirement])
  prop :unconditional_unexpanded_ext_reqs, T.nilable(T::Array[::Udb::ExtensionRequirement])
  prop :unconditional_expanded_ext_conflicts, T.nilable(T::Array[::Udb::ExtensionRequirement])
  prop :unconditional_unexpanded_ext_conflicts, T.nilable(T::Array[::Udb::ExtensionRequirement])
  prop :conditional_expanded_extension_requirements, T.nilable(T::Array[::Udb::ConditionalExtensionRequirement])
  prop :conditional_unexpanded_extension_requirements, T.nilable(T::Array[::Udb::ConditionalExtensionRequirement])
  prop :expanded_ext_requirements, T.nilable(T::Array[::Udb::ConditionalExtensionRequirement])
  prop :unexpanded_ext_requirements, T.nilable(T::Array[::Udb::ConditionalExtensionRequirement])
  prop :expanded_ext_conflicts, T.nilable(T::Array[::Udb::ConditionalExtensionRequirement])
  prop :unexpanded_ext_conflicts, T.nilable(T::Array[::Udb::ConditionalExtensionRequirement])
  prop :term, T.nilable(::Udb::ExtensionTerm)
  prop :condition, T.nilable(::Udb::AbstractCondition)
  prop :compatible_versions, T.nilable(T::Array[::Udb::ExtensionVersion])
  prop :key, T.nilable(::Integer)
end

# source://udb//lib/udb/logic.rb#1094
class Udb::FreeTerm
  include ::Comparable

  # source://udb//lib/udb/logic.rb#1104
  sig { void }
  def initialize; end

  # source://udb//lib/udb/logic.rb#1138
  sig { override.params(other: T.untyped).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # source://udb//lib/udb/logic.rb#1158
  sig { override.params(other: T.untyped).returns(T::Boolean) }
  def eql?(other); end

  # source://udb//lib/udb/logic.rb#1150
  sig { override.returns(::Integer) }
  def hash; end

  # source://udb//lib/udb/logic.rb#1101
  sig { returns(::Integer) }
  def id; end

  # source://udb//lib/udb/logic.rb#1127
  def to_h; end

  # source://udb//lib/udb/logic.rb#1123
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(::String) }
  def to_idl(cfg_arch); end

  # source://udb//lib/udb/logic.rb#1113
  sig { override.returns(::String) }
  def to_s; end

  # source://udb//lib/udb/logic.rb#1130
  sig { returns(::String) }
  def to_s_pretty; end

  # source://udb//lib/udb/logic.rb#1118
  sig { returns(::Z3::BoolExpr) }
  def to_z3; end
end

# source://udb//lib/udb/config.rb#286
class Udb::FullConfig < ::Udb::AbstractConfig
  # source://udb//lib/udb/config.rb#292
  sig { params(data: T::Hash[::String, T.untyped], info: ::Udb::Resolver::ConfigInfo).void }
  def initialize(data, info); end

  # source://udb//lib/udb/config.rb#315
  sig { override.returns(T::Boolean) }
  def fully_configured?; end

  # source://udb//lib/udb/config.rb#324
  sig { returns(T::Array[T::Hash[::String, ::String]]) }
  def implemented_extensions; end

  # source://udb//lib/udb/config.rb#312
  sig { override.returns(::Integer) }
  def mxlen; end

  # source://udb//lib/udb/config.rb#309
  sig do
    override
      .returns(T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)])
  end
  def param_values; end

  # source://udb//lib/udb/config.rb#318
  sig { override.returns(T::Boolean) }
  def partially_configured?; end

  # source://udb//lib/udb/config.rb#321
  sig { override.returns(T::Boolean) }
  def unconfigured?; end
end

# source://udb//lib/udb/condition.rb#1748
class Udb::IdlCondition < ::Udb::Condition
  # source://udb//lib/udb/condition.rb#1762
  sig do
    params(
      yaml: T::Hash[::String, T.untyped],
      cfg_arch: ::Udb::ConfiguredArchitecture,
      input_file: T.nilable(::Pathname),
      input_line: T.nilable(::Integer)
    ).void
  end
  def initialize(yaml, cfg_arch, input_file:, input_line:); end

  # source://udb//lib/udb/condition.rb#1769
  sig { returns(::Udb::Constraint) }
  def constraint; end

  # source://udb//lib/udb/condition.rb#1751
  sig { returns(::String) }
  def reason; end

  # source://udb//lib/udb/condition.rb#1784
  sig { override.returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_h; end

  # source://udb//lib/udb/condition.rb#1787
  sig { override.params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(::String) }
  def to_idl(cfg_arch); end

  # source://udb//lib/udb/condition.rb#1779
  sig { override.returns(::Udb::LogicNode) }
  def to_logic_tree_internal; end
end

# source://udb//lib/udb/obj/instruction.rb#112
class Udb::Instruction < ::Udb::TopLevelDatabaseObject
  include ::Udb::CertifiableObject

  # source://udb//lib/udb/obj/instruction.rb#122
  sig do
    override
      .params(
        data: T::Hash[::String, T.untyped],
        data_path: T.any(::Pathname, ::String),
        arch: ::Udb::ConfiguredArchitecture
      ).void
  end
  def initialize(data, data_path, arch); end

  # source://udb//lib/udb/obj/instruction.rb#371
  def <=>(other); end

  # source://udb//lib/udb/obj/instruction.rb#363
  def ==(other); end

  # source://udb//lib/udb/obj/instruction.rb#380
  def access; end

  # source://udb//lib/udb/obj/instruction.rb#386
  def access_detail; end

  # source://udb//lib/udb/obj/instruction.rb#1146
  def access_detail?; end

  # source://udb//lib/udb/obj/instruction.rb#414
  def assembly; end

  # source://udb//lib/udb/obj/instruction.rb#1030
  def bad_encoding_conflict?(xlen, other_inst); end

  # source://udb//lib/udb/obj/instruction.rb#391
  sig { returns(T.nilable(::Integer)) }
  def base; end

  # source://udb//lib/udb/obj/instruction.rb#1044
  def conflicting_instructions(xlen); end

  # source://udb//lib/udb/obj/instruction.rb#405
  def data_independent_timing?; end

  # source://udb//lib/udb/obj/instruction.rb#1141
  def decode_variables(base); end

  # source://udb//lib/udb/obj/instruction.rb#409
  def defined_in_base?(xlen); end

  # source://udb//lib/udb/obj/instruction.rb#1109
  sig { params(base: ::Integer).returns(::Udb::Instruction::Encoding) }
  def encoding(base); end

  # source://udb//lib/udb/obj/instruction.rb#228
  sig { params(base: ::Integer).returns(::String) }
  def encoding_format(base); end

  # source://udb//lib/udb/obj/instruction.rb#1119
  sig { returns(::Integer) }
  def encoding_width; end

  # source://udb//lib/udb/obj/instruction.rb#127
  def eql?(other); end

  # source://udb//lib/udb/obj/instruction.rb#1185
  def exists_in_cfg?(cfg_arch); end

  # source://udb//lib/udb/obj/instruction.rb#418
  def fill_symtab(effective_xlen, ast); end

  # source://udb//lib/udb/obj/instruction.rb#134
  sig { returns(T::Boolean) }
  def has_type?; end

  # source://udb//lib/udb/obj/instruction.rb#1179
  def hints; end

  # source://udb//lib/udb/obj/instruction.rb#496
  def mask_to_array(int); end

  # source://udb//lib/udb/obj/instruction.rb#1136
  sig { returns(::Integer) }
  def max_encoding_width; end

  # source://udb//lib/udb/obj/instruction.rb#1021
  def multi_encoding?; end

  # source://udb//lib/udb/obj/instruction.rb#194
  sig { params(base: ::Integer).returns(T::Array[::Udb::Instruction::Opcode]) }
  def opcodes(base); end

  # source://udb//lib/udb/obj/instruction.rb#1088
  def operation_ast; end

  # source://udb//lib/udb/obj/instruction.rb#1237
  sig { params(expand: T::Boolean).returns(T::Array[::Udb::Condition]) }
  def other_requirements(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/obj/instruction.rb#256
  def processed_wavedrom_desc(base); end

  # source://udb//lib/udb/obj/instruction.rb#1273
  sig { returns(T::Array[::Udb::Profile]) }
  def profiles_mandating_inst; end

  # source://udb//lib/udb/obj/instruction.rb#1284
  sig { returns(T::Array[::Udb::Profile]) }
  def profiles_optioning_inst; end

  # source://udb//lib/udb/obj/instruction.rb#443
  def pruned_operation_ast(effective_xlen); end

  # source://udb//lib/udb/obj/instruction.rb#483
  def reachable_exceptions(effective_xlen); end

  # source://udb//lib/udb/obj/instruction.rb#511
  def reachable_exceptions_str(effective_xlen = T.unsafe(nil)); end

  # source://udb//lib/udb/obj/instruction.rb#464
  sig { params(effective_xlen: ::Integer).returns(T::Array[::Idl::FunctionDefAst]) }
  def reachable_functions(effective_xlen); end

  # source://udb//lib/udb/obj/instruction.rb#1169
  def rv32?; end

  # source://udb//lib/udb/obj/instruction.rb#1174
  def rv64?; end

  # source://udb//lib/udb/obj/instruction.rb#156
  sig { params(base: ::Integer).returns(::Udb::InstructionSubtype) }
  def subtype(base); end

  # source://udb//lib/udb/obj/instruction.rb#137
  sig { params(base: ::Integer).returns(::Udb::InstructionType) }
  def type(base); end

  # source://udb//lib/udb/obj/instruction.rb#1072
  def type_checked_operation_ast(effective_xlen); end

  # source://udb//lib/udb/obj/instruction.rb#1221
  sig { params(expand: T::Boolean).returns(T::Array[::Udb::ExtensionRequirement]) }
  def unconditional_extension_conflicts(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/obj/instruction.rb#1203
  sig { params(expand: T::Boolean).returns(T::Array[::Udb::ExtensionRequirement]) }
  def unconditional_extension_requirements(expand: T.unsafe(nil)); end

  # source://udb//lib/udb/obj/instruction.rb#325
  sig { override.params(resolver: ::Udb::Resolver).void }
  def validate(resolver); end

  # source://udb//lib/udb/obj/instruction.rb#1154
  def wavedrom_desc(base); end

  private

  # source://udb//lib/udb/obj/instruction.rb#996
  def load_encoding; end

  class << self
    # source://udb//lib/udb/obj/instruction.rb#262
    def ary_from_location(location_str_or_int); end

    # source://udb//lib/udb/obj/instruction.rb#299
    def deprecated_validate_encoding(encoding, inst_name); end

    # source://udb//lib/udb/obj/instruction.rb#279
    sig { params(inst: ::Udb::Instruction, base: ::Integer).void }
    def validate_encoding(inst, base); end
  end
end

# source://udb//lib/udb/obj/instruction.rb#612
class Udb::Instruction::DecodeVariable
  # source://udb//lib/udb/obj/instruction.rb#758
  def initialize(name, field_data); end

  # source://udb//lib/udb/obj/instruction.rb#621
  def alias; end

  # source://udb//lib/udb/obj/instruction.rb#802
  def bits; end

  # source://udb//lib/udb/obj/instruction.rb#631
  def encoding_fields; end

  # source://udb//lib/udb/obj/instruction.rb#699
  def encoding_repl(encoding, value); end

  # source://udb//lib/udb/obj/instruction.rb#783
  def eql?(other); end

  # source://udb//lib/udb/obj/instruction.rb#629
  def excludes; end

  # source://udb//lib/udb/obj/instruction.rb#833
  def extract; end

  # source://udb//lib/udb/obj/instruction.rb#656
  def extract_location(location); end

  # source://udb//lib/udb/obj/instruction.rb#734
  def grouped_encoding_fields; end

  # source://udb//lib/udb/obj/instruction.rb#787
  def hash; end

  # source://udb//lib/udb/obj/instruction.rb#682
  def inst_pos_to_var_pos; end

  # source://udb//lib/udb/obj/instruction.rb#626
  def left_shift; end

  # source://udb//lib/udb/obj/instruction.rb#634
  sig { returns(::String) }
  def location; end

  # source://udb//lib/udb/obj/instruction.rb#638
  sig { returns(T::Array[::Integer]) }
  def location_bits; end

  # source://udb//lib/udb/obj/instruction.rb#616
  def name; end

  # source://udb//lib/udb/obj/instruction.rb#824
  sig { params(other: T.any(::Udb::Instruction::DecodeVariable, ::Udb::Instruction::Opcode)).returns(T::Boolean) }
  def overlaps?(other); end

  # source://udb//lib/udb/obj/instruction.rb#646
  def pretty_name; end

  # source://udb//lib/udb/obj/instruction.rb#819
  def sext?; end

  # source://udb//lib/udb/obj/instruction.rb#809
  def size; end

  # source://udb//lib/udb/obj/instruction.rb#814
  def size_in_encoding; end

  # source://udb//lib/udb/obj/instruction.rb#792
  def split?; end

  private

  # source://udb//lib/udb/obj/instruction.rb#715
  def inst_range_to_var_range(r); end
end

# source://udb//lib/udb/obj/instruction.rb#860
class Udb::Instruction::Encoding
  # source://udb//lib/udb/obj/instruction.rb#953
  def initialize(format, decode_vars, opcode_fields = T.unsafe(nil)); end

  # source://udb//lib/udb/obj/instruction.rb#872
  def decode_variables; end

  # source://udb//lib/udb/obj/instruction.rb#864
  def format; end

  # source://udb//lib/udb/obj/instruction.rb#914
  def indistinguishable?(other_encoding, check_other: T.unsafe(nil)); end

  # source://udb//lib/udb/obj/instruction.rb#869
  def opcode_fields; end

  # source://udb//lib/udb/obj/instruction.rb#991
  def size; end

  class << self
    # source://udb//lib/udb/obj/instruction.rb#903
    def overlapping_format?(format1, format2); end
  end
end

# source://udb//lib/udb/obj/instruction.rb#875
class Udb::Instruction::Encoding::Field
  # source://udb//lib/udb/obj/instruction.rb#888
  def initialize(name, range); end

  # source://udb//lib/udb/obj/instruction.rb#881
  def name; end

  # source://udb//lib/udb/obj/instruction.rb#894
  def opcode?; end

  # source://udb//lib/udb/obj/instruction.rb#884
  def range; end

  # source://udb//lib/udb/obj/instruction.rb#898
  def to_s; end
end

# source://udb//lib/udb/obj/instruction.rb#572
class Udb::Instruction::EncodingField
  # source://udb//lib/udb/obj/instruction.rb#579
  def initialize(name, range, pretty = T.unsafe(nil)); end

  # source://udb//lib/udb/obj/instruction.rb#591
  def eql?(other); end

  # source://udb//lib/udb/obj/instruction.rb#595
  def hash; end

  # source://udb//lib/udb/obj/instruction.rb#574
  def name; end

  # source://udb//lib/udb/obj/instruction.rb#586
  def opcode?; end

  # source://udb//lib/udb/obj/instruction.rb#599
  def pretty_to_s; end

  # source://udb//lib/udb/obj/instruction.rb#577
  def range; end

  # source://udb//lib/udb/obj/instruction.rb#605
  def size; end
end

# source://udb//lib/udb/obj/instruction.rb#117
class Udb::Instruction::MemoizedState < ::T::Struct
  prop :reachable_functions, T.nilable(T::Hash[::Integer, ::Idl::FunctionDefAst])
end

# source://udb//lib/udb/obj/instruction.rb#174
class Udb::Instruction::Opcode < ::Udb::InstructionSubtype::Opcode
  # source://udb//lib/udb/obj/instruction.rb#181
  sig { params(name: ::String, range: T::Range[T.untyped], value: ::Integer).void }
  def initialize(name, range, value); end

  # source://udb//lib/udb/obj/instruction.rb#187
  sig { returns(T::Boolean) }
  def opcode?; end

  # source://udb//lib/udb/obj/instruction.rb#190
  sig { returns(::String) }
  def to_s; end

  # source://udb//lib/udb/obj/instruction.rb#178
  sig { returns(::Integer) }
  def value; end
end

# source://udb//lib/udb/obj/instruction.rb#32
class Udb::InstructionSubtype < ::Udb::TopLevelDatabaseObject
  # source://udb//lib/udb/obj/instruction.rb#65
  sig do
    params(
      data: T::Hash[::String, T.untyped],
      data_path: T.any(::Pathname, ::String),
      arch: ::Udb::ConfiguredArchitecture
    ).void
  end
  def initialize(data, data_path, arch); end

  # source://udb//lib/udb/obj/instruction.rb#85
  sig { returns(T::Array[::Udb::Instruction::Encoding::Field]) }
  def opcodes; end

  # source://udb//lib/udb/obj/instruction.rb#70
  sig { returns(::Udb::InstructionType) }
  def type; end

  # source://udb//lib/udb/obj/instruction.rb#75
  sig { returns(T::Array[::Udb::Instruction::DecodeVariable]) }
  def variables; end
end

# source://udb//lib/udb/obj/instruction.rb#33
class Udb::InstructionSubtype::Opcode
  # source://udb//lib/udb/obj/instruction.rb#43
  sig { params(name: ::String, range: T::Range[T.untyped]).void }
  def initialize(name, range); end

  # source://udb//lib/udb/obj/instruction.rb#37
  sig { returns(::String) }
  def name; end

  # source://udb//lib/udb/obj/instruction.rb#49
  sig do
    params(
      other: T.any(::Udb::Instruction::DecodeVariable, ::Udb::InstructionSubtype::Opcode)
    ).returns(T::Boolean)
  end
  def overlaps?(other); end

  # source://udb//lib/udb/obj/instruction.rb#40
  sig { returns(T::Range[T.untyped]) }
  def range; end
end

# source://udb//lib/udb/obj/instruction.rb#16
class Udb::InstructionType < ::Udb::TopLevelDatabaseObject
  # source://udb//lib/udb/obj/instruction.rb#24
  sig do
    params(
      data: T::Hash[::String, T.untyped],
      data_path: T.any(::Pathname, ::String),
      arch: ::Udb::ConfiguredArchitecture
    ).void
  end
  def initialize(data, data_path, arch); end

  # source://udb//lib/udb/obj/instruction.rb#28
  def length; end

  # source://udb//lib/udb/obj/instruction.rb#29
  def size; end
end

# source://udb//lib/udb/obj/exception_code.rb#65
class Udb::InterruptCode < ::Udb::TopLevelDatabaseObject
  include ::Udb::Code
  include ::Comparable

  # source://udb//lib/udb/obj/exception_code.rb#84
  sig { override.params(other: ::BasicObject).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # source://udb//lib/udb/obj/exception_code.rb#91
  sig { override.params(other: ::BasicObject).returns(T::Boolean) }
  def eql?(other); end

  # source://udb//lib/udb/obj/exception_code.rb#96
  sig { override.returns(::Integer) }
  def hash; end

  # source://udb//lib/udb/obj/exception_code.rb#71
  sig { override.params(resolver: ::Udb::Resolver).void }
  def validate(resolver); end
end

# source://udb//lib/udb/config.rb#204
class Udb::InvalidConfigError < ::StandardError; end

# source://udb//lib/udb/obj/database_obj.rb#481
class Udb::License
  # source://udb//lib/udb/obj/database_obj.rb#485
  sig { params(data: T::Hash[::String, T.nilable(::String)]).void }
  def initialize(data); end

  # source://udb//lib/udb/obj/database_obj.rb#491
  sig { returns(::String) }
  def name; end

  # source://udb//lib/udb/obj/database_obj.rb#500
  sig { returns(::String) }
  def text; end

  # source://udb//lib/udb/obj/database_obj.rb#496
  sig { returns(::String) }
  def url; end
end

# source://udb//lib/udb/log.rb#16
class Udb::LogLevel < ::T::Enum
  include ::Comparable

  enums do
    Debug = new
    Error = new
    Fatal = new
    Info = new
    Warn = new
  end

  # source://udb//lib/udb/log.rb#40
  def <=>(other); end

  # source://udb//lib/udb/log.rb#28
  sig { returns(::Integer) }
  def rank; end
end

# source://udb//lib/udb/condition.rb#1362
class Udb::LogicCondition < ::Udb::Condition
  # source://udb//lib/udb/condition.rb#1365
  sig { params(logic_node: ::Udb::LogicNode, cfg_arch: ::Udb::ConfiguredArchitecture).void }
  def initialize(logic_node, cfg_arch); end

  # source://udb//lib/udb/condition.rb#1372
  sig { override.returns(T::Boolean) }
  def empty?; end

  # source://udb//lib/udb/condition.rb#1375
  sig { override.returns(::Udb::LogicNode) }
  def to_logic_tree_internal; end
end

# source://udb//lib/udb/eqn.rb#14
class Udb::LogicNode
  # source://udb//lib/udb/logic.rb#1254
  sig do
    params(
      type: ::Udb::LogicNodeType,
      children: T::Array[T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::LogicNode, ::Udb::ParameterTerm, ::Udb::XlenTerm)]
    ).void
  end
  def initialize(type, children); end

  # source://udb//lib/udb/logic.rb#1213
  sig do
    returns(T::Array[T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::LogicNode, ::Udb::ParameterTerm, ::Udb::XlenTerm)])
  end
  def children; end

  # source://udb//lib/udb/logic.rb#2796
  sig { returns(T::Boolean) }
  def cnf?; end

  # source://udb//lib/udb/logic.rb#2858
  sig { returns(T::Boolean) }
  def cnf_conjunction_term?; end

  # source://udb//lib/udb/logic.rb#3243
  sig { params(subformulae: T::Array[::Udb::LogicNode]).void }
  def collect_tseytin(subformulae); end

  # source://udb//lib/udb/logic.rb#3230
  sig { returns(::Udb::LogicNode) }
  def distribute_not; end

  # source://udb//lib/udb/logic.rb#2830
  sig { returns(T::Boolean) }
  def dnf?; end

  # source://udb//lib/udb/logic.rb#2885
  sig { returns(T::Boolean) }
  def dnf_disjunctive_term?; end

  # source://udb//lib/udb/logic.rb#3151
  sig do
    params(
      tree: ::Udb::LogicNode,
      term_map: T::Hash[T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm), ::String]
    ).returns(::String)
  end
  def do_to_eqntott(tree, term_map); end

  # source://udb//lib/udb/logic.rb#3625
  sig { override.params(other: T.untyped).returns(T::Boolean) }
  def eql?(other); end

  # source://udb//lib/udb/logic.rb#2769
  sig { returns(::Udb::LogicNode) }
  def equisat_cnf; end

  # source://udb//lib/udb/logic.rb#3094
  sig { params(other: ::Udb::LogicNode, cfg_arch: ::Udb::ConfiguredArchitecture).returns(T::Boolean) }
  def equisatisfiable?(other, cfg_arch); end

  # source://udb//lib/udb/logic.rb#2745
  sig { params(raise_on_explosion: T::Boolean).returns(::Udb::LogicNode) }
  def equiv_cnf(raise_on_explosion: T.unsafe(nil)); end

  # source://udb//lib/udb/logic.rb#3104
  sig { params(other: ::Udb::LogicNode, cfg_arch: ::Udb::ConfiguredArchitecture).returns(T::Boolean) }
  def equivalent?(other, cfg_arch); end

  # source://udb//lib/udb/logic.rb#3478
  sig { params(result_type: ::Udb::LogicNode::CanonicalizationType, exact: T::Boolean).returns(::Udb::LogicNode) }
  def espresso(result_type, exact); end

  # source://udb//lib/udb/logic.rb#1682
  sig do
    params(
      callback: T.proc.params(arg0: T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)).returns(::Udb::SatisfiedResult)
    ).returns(::Udb::SatisfiedResult)
  end
  def eval_cb(callback); end

  # source://udb//lib/udb/logic.rb#3389
  sig { params(dimacs: ::String).returns(::Udb::LogicNode) }
  def from_dimacs(dimacs); end

  # source://udb//lib/udb/logic.rb#2366
  sig { returns(::Udb::LogicNode) }
  def group_by_2; end

  # source://udb//lib/udb/logic.rb#2341
  sig { params(node: ::Udb::LogicNode).returns(T::Boolean) }
  def grouped_by_2?(node); end

  # source://udb//lib/udb/logic.rb#1877
  sig { override.returns(::Integer) }
  def hash; end

  # source://udb//lib/udb/logic.rb#1369
  sig { returns(T::Array[T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)]) }
  def literals; end

  # source://udb//lib/udb/logic.rb#1251
  def memo; end

  # source://udb//lib/udb/logic.rb#1251
  def memo=(_arg0); end

  # source://udb//lib/udb/logic.rb#3435
  sig { returns(T::Array[::Udb::LogicNode]) }
  def minimal_unsat_subsets; end

  # source://udb//lib/udb/logic.rb#1632
  sig { params(result_type: ::Udb::LogicNode::CanonicalizationType).returns(::Udb::LogicNode) }
  def minimize(result_type); end

  # source://udb//lib/udb/logic.rb#2956
  sig { returns(T::Boolean) }
  def nested_cnf?; end

  # source://udb//lib/udb/logic.rb#2912
  sig { params(ancestor_or: T::Boolean).returns(T::Boolean) }
  def nested_cnf_conjunction_term?(ancestor_or); end

  # source://udb//lib/udb/logic.rb#2212
  sig { returns(::Udb::LogicNode) }
  def nnf; end

  # source://udb//lib/udb/logic.rb#2217
  def nnf?; end

  # source://udb//lib/udb/logic.rb#1294
  sig { returns(T::Array[::Udb::LogicNode]) }
  def node_children; end

  # source://udb//lib/udb/logic.rb#1786
  sig do
    params(
      cb: T.proc.params(arg0: T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)).returns(::Udb::SatisfiedResult)
    ).returns(::Udb::LogicNode)
  end
  def partial_evaluate(cb); end

  # source://udb//lib/udb/logic.rb#2597
  sig { returns(::Udb::LogicNode) }
  def reduce; end

  # source://udb//lib/udb/logic.rb#1664
  sig { params(callback: T.proc.params(arg0: ::Udb::LogicNode).returns(::Udb::LogicNode)).returns(::Udb::LogicNode) }
  def replace_terms(callback); end

  # source://udb//lib/udb/logic.rb#1321
  sig { params(ext_req: ::Udb::ExtensionRequirement).returns(T::Boolean) }
  def satisfiability_depends_on_ext_req?(ext_req); end

  # source://udb//lib/udb/logic.rb#3041
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(T::Boolean) }
  def satisfiable?(cfg_arch); end

  # source://udb//lib/udb/logic.rb#1345
  sig { returns(T::Array[T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)]) }
  def terms; end

  # source://udb//lib/udb/logic.rb#1356
  sig { returns(T::Array[T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)]) }
  def terms_no_antecendents; end

  # source://udb//lib/udb/logic.rb#1964
  sig { params(include_versions: T::Boolean).returns(::String) }
  def to_asciidoc(include_versions:); end

  # source://udb//lib/udb/logic.rb#3348
  sig { returns(::String) }
  def to_dimacs; end

  # source://udb//lib/udb/logic.rb#3184
  sig { returns(::Udb::LogicNode::EqntottResult) }
  def to_eqntott; end

  # source://udb//lib/udb/logic.rb#2039
  sig { params(term_determined: T::Boolean).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_h(term_determined = T.unsafe(nil)); end

  # source://udb//lib/udb/logic.rb#2014
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(::String) }
  def to_idl(cfg_arch); end

  # source://udb//lib/udb/logic.rb#1902
  sig { params(format: ::Udb::LogicNode::LogicSymbolFormat).returns(::String) }
  def to_s(format: T.unsafe(nil)); end

  # source://udb//lib/udb/logic.rb#1852
  sig { returns(::String) }
  def to_s_pretty; end

  # source://udb//lib/udb/logic.rb#1927
  sig do
    params(
      callback: T.proc.params(arg0: T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)).returns(::Udb::SatisfiedResult),
      format: ::Udb::LogicNode::LogicSymbolFormat
    ).returns(::String)
  end
  def to_s_with_value(callback, format: T.unsafe(nil)); end

  # source://udb//lib/udb/logic.rb#2993
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture, solver: ::Udb::Z3Solver).returns(::Z3::BoolExpr) }
  def to_z3(cfg_arch, solver = T.unsafe(nil)); end

  # source://udb//lib/udb/logic.rb#3329
  sig { returns(::Udb::LogicNode) }
  def tseytin; end

  # source://udb//lib/udb/logic.rb#3317
  sig { returns(::Udb::LogicNode) }
  def tseytin_prop; end

  # source://udb//lib/udb/logic.rb#1210
  sig { returns(::Udb::LogicNodeType) }
  def type; end

  # source://udb//lib/udb/logic.rb#3091
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(T::Boolean) }
  def unsatisfiable?(cfg_arch); end

  private

  # source://udb//lib/udb/logic.rb#3200
  sig { params(node: ::Udb::LogicNode).returns(::Udb::LogicNode) }
  def distribute_not_helper(node); end

  # source://udb//lib/udb/logic.rb#2381
  sig do
    params(
      left: ::Udb::LogicNode,
      right: ::Udb::LogicNode,
      clause_count: T::Array[::Integer],
      raise_on_explosion: T::Boolean
    ).returns(::Udb::LogicNode)
  end
  def distribute_or(left, right, clause_count = T.unsafe(nil), raise_on_explosion:); end

  # source://udb//lib/udb/logic.rb#2478
  sig do
    params(
      node: ::Udb::LogicNode,
      clause_count: T::Array[::Integer],
      raise_on_explosion: T::Boolean
    ).returns(::Udb::LogicNode)
  end
  def do_equiv_cnf(node, clause_count = T.unsafe(nil), raise_on_explosion:); end

  # source://udb//lib/udb/logic.rb#2232
  sig { params(node: ::Udb::LogicNode).returns(::Udb::LogicNode) }
  def do_group_by_2(node); end

  # source://udb//lib/udb/logic.rb#2159
  sig { params(node: ::Udb::LogicNode).returns(::Udb::LogicNode) }
  def do_nnf(node); end

  # source://udb//lib/udb/logic.rb#2118
  sig { params(node: ::Udb::LogicNode).returns(::Udb::LogicNode) }
  def do_nnf_for_not(node); end

  # source://udb//lib/udb/logic.rb#2532
  sig { params(node: ::Udb::LogicNode).returns(::Udb::LogicNode) }
  def flatten_cnf(node); end

  # source://udb//lib/udb/logic.rb#1509
  sig { params(result_type: ::Udb::LogicNode::CanonicalizationType).returns(::Udb::LogicNode) }
  def quine_mccluskey(result_type); end

  class << self
    # source://udb//lib/udb/logic.rb#1438
    sig { params(mterms: T::Array[::String], group_by: ::String).returns(::Udb::LogicNode::PrimeImplicantsResult) }
    def find_prime_implicants(mterms, group_by); end

    # source://udb//lib/udb/logic.rb#1380
    sig { params(mterms: T::Array[::String], group_by: ::String).returns(T::Hash[::Integer, T::Array[::String]]) }
    def group_mterms(mterms, group_by); end

    # source://udb//lib/udb/logic.rb#1186
    def inc_brute_force_sat_solves; end

    # source://udb//lib/udb/logic.rb#1202
    def inc_z3_cache_hits; end

    # source://udb//lib/udb/logic.rb#1194
    def inc_z3_sat_solves; end

    # source://udb//lib/udb/logic.rb#1653
    sig do
      params(
        blk: T.proc.params(arg0: T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)).returns(::Udb::SatisfiedResult)
      ).returns(T.proc.params(arg0: T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)).returns(::Udb::SatisfiedResult))
    end
    def make_eval_cb(&blk); end

    # source://udb//lib/udb/logic.rb#1659
    sig do
      params(
        blk: T.proc.params(arg0: ::Udb::LogicNode).returns(::Udb::LogicNode)
      ).returns(T.proc.params(arg0: ::Udb::LogicNode).returns(::Udb::LogicNode))
    end
    def make_replace_cb(&blk); end

    # source://udb//lib/udb/logic.rb#1182
    def num_brute_force_sat_solves; end

    # source://udb//lib/udb/logic.rb#1198
    def num_z3_cache_hits; end

    # source://udb//lib/udb/logic.rb#1190
    def num_z3_sat_solves; end

    # source://udb//lib/udb/logic.rb#1396
    sig do
      params(
        group1: T::Array[::String],
        group2: T::Array[::String]
      ).returns(::Udb::LogicNode::PairMintermsResult)
    end
    def pair_mterms(group1, group2); end

    # source://udb//lib/udb/logic.rb#1424
    def prime_implicant_covers_mterm?(implicant, minterm); end

    # source://udb//lib/udb/logic.rb#1172
    def reset_stats; end
  end
end

# source://udb//lib/udb/logic.rb#1501
class Udb::LogicNode::CanonicalizationType < ::T::Enum
  enums do
    ProductOfSums = new
    SumOfProducts = new
  end
end

# source://udb//lib/udb/logic.rb#1207
Udb::LogicNode::ChildType = T.type_alias { T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::LogicNode, ::Udb::ParameterTerm, ::Udb::XlenTerm) }

# source://udb//lib/udb/logic.rb#1646
class Udb::LogicNode::ConditionalEndterm < ::T::Struct
  const :term, T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)
  const :cond, ::Udb::LogicNode
end

# source://udb//lib/udb/logic.rb#3177
class Udb::LogicNode::EqntottResult < ::T::Struct
  const :eqn, ::String
  const :term_map, T::Hash[::String, T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)]
end

# source://udb//lib/udb/logic.rb#1651
Udb::LogicNode::EvalCallbackType = T.type_alias { T.proc.params(arg0: T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)).returns(::Udb::SatisfiedResult) }

# source://udb//lib/udb/logic.rb#1307
Udb::LogicNode::False = T.let(T.unsafe(nil), Udb::LogicNode)

# source://udb//lib/udb/logic.rb#1811
Udb::LogicNode::LOGIC_SYMBOLS = T.let(T.unsafe(nil), Hash)

# source://udb//lib/udb/logic.rb#1802
class Udb::LogicNode::LogicSymbolFormat < ::T::Enum
  enums do
    C = new
    English = new
    Eqn = new
    Predicate = new
  end
end

# source://udb//lib/udb/logic.rb#1218
class Udb::LogicNode::MemoizedState < ::T::Struct
  prop :is_cnf, T.nilable(T::Boolean)
  prop :cnf_form, T.nilable(::Udb::LogicNode)
  prop :is_nested_cnf, T.nilable(T::Boolean)
  prop :is_reduced, T.nilable(T::Boolean)
  prop :terms, T.nilable(T::Array[T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)])
  prop :literals, T.nilable(T::Array[T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm)])
  prop :is_satisfiable, T.nilable(T::Boolean)
  prop :equisat_cnf, T.nilable(::Udb::LogicNode)
  prop :equiv_cnf, T.nilable(::Udb::LogicNode)
end

# source://udb//lib/udb/logic.rb#1390
class Udb::LogicNode::PairMintermsResult < ::T::Struct
  const :new_group, T::Array[::String]
  const :matched_mterms, T::Set[::String]
end

# source://udb//lib/udb/logic.rb#1430
class Udb::LogicNode::PrimeImplicantsResult < ::T::Struct
  const :essential, T::Array[::String]
  const :minimal, T::Array[::String]
end

# source://udb//lib/udb/logic.rb#1657
Udb::LogicNode::ReplaceCallbackType = T.type_alias { T.proc.params(arg0: ::Udb::LogicNode).returns(::Udb::LogicNode) }

# source://udb//lib/udb/logic.rb#2466
class Udb::LogicNode::SizeExplosion < ::RuntimeError; end

# source://udb//lib/udb/logic.rb#1298
Udb::LogicNode::True = T.let(T.unsafe(nil), Udb::LogicNode)

# source://udb//lib/udb/logic.rb#1316
Udb::LogicNode::Xlen32 = T.let(T.unsafe(nil), Udb::LogicNode)

# source://udb//lib/udb/logic.rb#1317
Udb::LogicNode::Xlen64 = T.let(T.unsafe(nil), Udb::LogicNode)

# source://udb//lib/udb/logic.rb#24
class Udb::LogicNodeType < ::T::Enum
  enums do
    And = new
    False = new
    If = new
    None = new
    Not = new
    Or = new
    Term = new
    True = new
    Xor = new
  end
end

# source://udb//lib/udb/obj/manual.rb#13
class Udb::Manual < ::Udb::TopLevelDatabaseObject
  # source://udb//lib/udb/obj/manual.rb#25
  def marketing_name; end

  # source://udb//lib/udb/obj/manual.rb#28
  def repo_path=(path); end

  # source://udb//lib/udb/obj/manual.rb#20
  def version(name); end

  # source://udb//lib/udb/obj/manual.rb#14
  def versions; end
end

# source://udb//lib/udb/obj/manual.rb#34
class Udb::ManualChapter
  # source://udb//lib/udb/obj/manual.rb#35
  def initialize(volume, path); end

  # source://udb//lib/udb/obj/manual.rb#52
  def fullpath; end

  # source://udb//lib/udb/obj/manual.rb#42
  def name; end

  # source://udb//lib/udb/obj/manual.rb#63
  def path; end

  # source://udb//lib/udb/obj/manual.rb#58
  def repo_path=(path); end

  # source://udb//lib/udb/obj/manual.rb#46
  def title; end
end

# source://udb//lib/udb/obj/manual.rb#125
class Udb::ManualVersion < ::Udb::TopLevelDatabaseObject
  # source://udb//lib/udb/obj/manual.rb#189
  def csrs; end

  # source://udb//lib/udb/obj/manual.rb#168
  def extensions; end

  # source://udb//lib/udb/obj/manual.rb#175
  def instructions; end

  # source://udb//lib/udb/obj/manual.rb#151
  def isa_manual_tree; end

  # source://udb//lib/udb/obj/manual.rb#127
  def manual; end

  # source://udb//lib/udb/obj/manual.rb#140
  def marketing_version; end

  # source://udb//lib/udb/obj/manual.rb#143
  def path; end

  # source://udb//lib/udb/obj/manual.rb#202
  def repo_path=(path); end

  # source://udb//lib/udb/obj/manual.rb#165
  def state; end

  # source://udb//lib/udb/obj/manual.rb#148
  def uses_isa_manual?; end

  # source://udb//lib/udb/obj/manual.rb#137
  def version; end

  # source://udb//lib/udb/obj/manual.rb#154
  def volumes; end
end

# source://udb//lib/udb/obj/manual.rb#66
class Udb::ManualVolume
  # source://udb//lib/udb/obj/manual.rb#72
  def initialize(data, version); end

  # source://udb//lib/udb/obj/manual.rb#70
  def cfg_arch; end

  # source://udb//lib/udb/obj/manual.rb#90
  def chapter(name); end

  # source://udb//lib/udb/obj/manual.rb#77
  def chapters; end

  # source://udb//lib/udb/obj/manual.rb#95
  def extensions; end

  # source://udb//lib/udb/obj/manual.rb#119
  def repo_path=(path); end

  # source://udb//lib/udb/obj/manual.rb#92
  def title; end

  # source://udb//lib/udb/obj/manual.rb#68
  def version; end
end

# source://udb//lib/udb/obj/non_isa_specification.rb#23
class Udb::NonIsaSpecification
  # source://udb//lib/udb/obj/non_isa_specification.rb#40
  sig { params(name: ::String, data: T::Hash[::String, T.untyped]).void }
  def initialize(name, data); end

  # source://udb//lib/udb/obj/non_isa_specification.rb#31
  sig { returns(T::Hash[::String, T.untyped]) }
  def data; end

  # source://udb//lib/udb/obj/non_isa_specification.rb#136
  sig { returns(T.untyped) }
  def defined_by_condition; end

  # source://udb//lib/udb/obj/non_isa_specification.rb#109
  sig { params(cfg_arch: T.untyped).returns(T::Boolean) }
  def exists_in_cfg?(cfg_arch); end

  # source://udb//lib/udb/obj/non_isa_specification.rb#177
  sig { params(include_sections: T::Boolean).returns(T::Array[T::Hash[T.any(::String, ::Symbol), T.untyped]]) }
  def extract_prose_statements(include_sections: T.unsafe(nil)); end

  # source://udb//lib/udb/obj/non_isa_specification.rb#50
  sig { void }
  def load_spec_data; end

  # source://udb//lib/udb/obj/non_isa_specification.rb#75
  sig { returns(::String) }
  def long_name; end

  # source://udb//lib/udb/obj/non_isa_specification.rb#28
  sig { returns(::String) }
  def name; end

  # source://udb//lib/udb/obj/non_isa_specification.rb#129
  sig { params(cfg_arch: T.untyped).returns(T::Boolean) }
  def optional_in_cfg?(cfg_arch); end

  # source://udb//lib/udb/obj/non_isa_specification.rb#102
  sig { returns(T::Array[T::Hash[T.any(::String, ::Symbol), T.untyped]]) }
  def references; end

  # source://udb//lib/udb/obj/non_isa_specification.rb#205
  sig do
    params(
      cfg_arch: T.untyped,
      base_level: ::Integer,
      normative: T::Boolean,
      non_normative: T::Boolean
    ).returns(::String)
  end
  def render_for_cfg(cfg_arch, base_level: T.unsafe(nil), normative: T.unsafe(nil), non_normative: T.unsafe(nil)); end

  # source://udb//lib/udb/obj/non_isa_specification.rb#96
  sig { returns(T::Array[T::Hash[T.any(::String, ::Symbol), T.untyped]]) }
  def sections; end

  # source://udb//lib/udb/obj/non_isa_specification.rb#37
  sig { returns(T.nilable(T::Hash[::String, T.untyped])) }
  def spec_data; end

  # source://udb//lib/udb/obj/non_isa_specification.rb#90
  sig { returns(T.untyped) }
  def spec_description; end

  # source://udb//lib/udb/obj/non_isa_specification.rb#34
  sig { returns(T.nilable(::Pathname)) }
  def spec_path; end

  # source://udb//lib/udb/obj/non_isa_specification.rb#225
  sig do
    params(
      base_level: ::Integer,
      normative: T::Boolean,
      non_normative: T::Boolean,
      when_callback: T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T::Boolean))
    ).returns(::String)
  end
  def to_asciidoc(base_level: T.unsafe(nil), normative: T.unsafe(nil), non_normative: T.unsafe(nil), when_callback: T.unsafe(nil)); end

  # source://udb//lib/udb/obj/non_isa_specification.rb#66
  sig { returns(T::Boolean) }
  def valid?; end

  # source://udb//lib/udb/obj/non_isa_specification.rb#149
  sig { returns(T::Array[::String]) }
  def validate_prose_ids; end

  # source://udb//lib/udb/obj/non_isa_specification.rb#84
  sig { returns(T.nilable(::String)) }
  def version; end

  private

  # source://udb//lib/udb/obj/non_isa_specification.rb#376
  sig { params(base_level: ::Integer).returns(::String) }
  def create_fallback_content(base_level); end

  # source://udb//lib/udb/obj/non_isa_specification.rb#360
  sig { params(cfg_arch: T.untyped).returns(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T::Boolean)) }
  def create_when_callback(cfg_arch); end

  # source://udb//lib/udb/obj/non_isa_specification.rb#261
  sig { params(statements: T::Array[T::Hash[T.any(::String, ::Symbol), T.untyped]]).returns(T::Array[::String]) }
  def find_duplicate_ids(statements); end

  # source://udb//lib/udb/obj/non_isa_specification.rb#298
  sig { params(base_level: ::Integer).returns(T::Array[::String]) }
  def render_references(base_level); end

  # source://udb//lib/udb/obj/non_isa_specification.rb#282
  sig do
    params(
      base_level: ::Integer,
      normative: T::Boolean,
      non_normative: T::Boolean,
      when_callback: T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T::Boolean))
    ).returns(T::Array[::String])
  end
  def render_sections(base_level, normative, non_normative, when_callback); end

  # source://udb//lib/udb/obj/non_isa_specification.rb#320
  sig do
    params(
      prose_content: T.untyped,
      normative: T::Boolean,
      non_normative: T::Boolean,
      when_callback: T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T::Boolean))
    ).returns(T.nilable(::String))
  end
  def render_structured_prose(prose_content, normative: T.unsafe(nil), non_normative: T.unsafe(nil), when_callback: T.unsafe(nil)); end

  # source://udb//lib/udb/obj/non_isa_specification.rb#348
  sig do
    params(
      section: T::Hash[T.any(::String, ::Symbol), T.untyped],
      when_callback: T.nilable(T.proc.params(arg0: T.untyped, arg1: T.untyped).returns(T::Boolean))
    ).returns(T::Boolean)
  end
  def should_include_section?(section, when_callback = T.unsafe(nil)); end

  # source://udb//lib/udb/obj/non_isa_specification.rb#249
  sig { params(id: ::String).returns(T::Boolean) }
  def valid_id_format?(id); end

  # source://udb//lib/udb/obj/non_isa_specification.rb#255
  sig { params(id: ::String).returns(T::Boolean) }
  def valid_id_naming?(id); end
end

# source://udb//lib/udb/condition.rb#1584
class Udb::ParamCondition < ::Udb::Condition
  # source://udb//lib/udb/condition.rb#1588
  sig { params(yaml: T::Hash[::String, T.untyped], cfg_arch: ::Udb::ConfiguredArchitecture).void }
  def initialize(yaml, cfg_arch); end

  # source://udb//lib/udb/condition.rb#1637
  sig { override.returns(::Udb::LogicNode) }
  def to_logic_tree_internal; end

  # source://udb//lib/udb/condition.rb#1598
  sig { params(yaml: T.any(T::Boolean, T::Hash[::String, T.untyped])).returns(::Udb::LogicNode) }
  def to_param_logic_tree_helper(yaml); end
end

# source://udb//lib/udb/obj/parameter.rb#18
class Udb::Parameter < ::Udb::TopLevelDatabaseObject
  include ::Idl::RuntimeParam

  # source://udb//lib/udb/obj/parameter.rb#74
  sig do
    params(
      yaml: T::Hash[::String, T.untyped],
      data_path: T.any(::Pathname, ::String),
      cfg_arch: ::Udb::ConfiguredArchitecture
    ).void
  end
  def initialize(yaml, data_path, cfg_arch); end

  # source://udb//lib/udb/obj/parameter.rb#213
  sig { override.params(other: T.untyped).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # source://udb//lib/udb/obj/parameter.rb#25
  sig { returns(::Udb::ConfiguredArchitecture) }
  def cfg_arch; end

  # source://udb//lib/udb/obj/parameter.rb#56
  sig { returns(T.nilable(::Object)) }
  def default; end

  # source://udb//lib/udb/obj/parameter.rb#193
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(::Udb::SatisfiedResult) }
  def defined_in_cfg?(cfg_arch); end

  # source://udb//lib/udb/obj/parameter.rb#138
  sig { override.returns(::Idl::Type) }
  def idl_type; end

  # source://udb//lib/udb/obj/parameter.rb#29
  sig { override.returns(::String) }
  def name; end

  # source://udb//lib/udb/obj/parameter.rb#201
  sig { params(in_scope_exts: T::Array[::Udb::Extension]).returns(::String) }
  def name_potentially_with_link(in_scope_exts); end

  # source://udb//lib/udb/obj/parameter.rb#38
  sig { returns(::Udb::AbstractCondition) }
  def requirements_condition; end

  # source://udb//lib/udb/obj/parameter.rb#104
  sig { override.returns(::Udb::Schema) }
  def schema; end


  # source://udb//lib/udb/obj/parameter.rb#33
  sig { returns(::String) }
  def schema_type; end


  # source://udb//lib/udb/obj/parameter.rb#220
  sig { returns(::String) }
  def to_idl; end

  # source://udb//lib/udb/obj/parameter.rb#226
  sig do
    override
      .returns(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean))
  end
  def value; end

  # source://udb//lib/udb/obj/parameter.rb#223
  sig { override.returns(T::Boolean) }
  def value_known?; end
end

# source://udb//lib/udb/obj/parameter.rb#62
class Udb::Parameter::ConditionalSchema < ::T::Struct
  const :cond, ::Udb::AbstractCondition
  const :schema, ::Udb::Schema
end

# source://udb//lib/udb/obj/parameter.rb#115
class Udb::Parameter::NoMatchingSchemaError < ::RuntimeError; end

# source://udb//lib/udb/logic.rb#297
class Udb::ParameterTerm
  include ::Comparable

  # source://udb//lib/udb/logic.rb#317
  sig { params(yaml: T::Hash[::String, T.untyped]).void }
  def initialize(yaml); end

  # source://udb//lib/udb/logic.rb#1017
  sig { override.params(other: T.untyped).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # source://udb//lib/udb/logic.rb#478
  sig { params(param_values: T::Hash[::String, T.untyped]).returns(::Udb::SatisfiedResult) }
  def _eval(param_values); end

  # source://udb//lib/udb/logic.rb#334
  sig { returns(T::Boolean) }
  def array_comparison?; end

  # source://udb//lib/udb/logic.rb#384
  sig { returns(::Udb::ParameterTerm::ParameterComparisonType) }
  def comparison_type; end

  # source://udb//lib/udb/logic.rb#337
  sig { returns(T.any(::Integer, ::String, T::Array[T.any(::Integer, ::String)], T::Boolean)) }
  def comparison_value; end

  # source://udb//lib/udb/logic.rb#1083
  sig { override.params(other: T.untyped).returns(T::Boolean) }
  def eql?(other); end

  # source://udb//lib/udb/logic.rb#513
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(::Udb::SatisfiedResult) }
  def eval(cfg_arch); end

  # source://udb//lib/udb/logic.rb#453
  sig { params(value: T.untyped).returns(::Udb::SatisfiedResult) }
  def eval_value(value); end

  # source://udb//lib/udb/logic.rb#1075
  sig { override.returns(::Integer) }
  def hash; end

  # source://udb//lib/udb/logic.rb#328
  sig { returns(T.nilable(::Integer)) }
  def index; end

  # source://udb//lib/udb/logic.rb#322
  sig { returns(::String) }
  def name; end

  # source://udb//lib/udb/logic.rb#343
  sig { returns(T.nilable(::Udb::ParameterTerm)) }
  def negate; end

  # source://udb//lib/udb/logic.rb#695
  sig { returns(T::Boolean) }
  def param_is_array?; end

  # source://udb//lib/udb/logic.rb#626
  sig { returns(::String) }
  def param_to_s; end

  # source://udb//lib/udb/logic.rb#527
  sig { params(param_values: T::Hash[::String, T.untyped]).returns(::Udb::SatisfiedResult) }
  def partial_eval(param_values); end

  # source://udb//lib/udb/logic.rb#325
  sig { returns(::String) }
  def reason; end

  # source://udb//lib/udb/logic.rb#704
  sig { params(other_param: ::Udb::ParameterTerm).returns(T.nilable(::Udb::LogicNode)) }
  def relation_to(other_param); end

  # source://udb//lib/udb/logic.rb#736
  sig do
    params(
      other_param: ::Udb::ParameterTerm,
      self_implies_other: ::Udb::LogicNode,
      self_implies_not_other: ::Udb::LogicNode
    ).returns(T.nilable(::Udb::LogicNode))
  end
  def scalar_relation_to(other_param, self_implies_other, self_implies_not_other); end

  # source://udb//lib/udb/logic.rb#331
  sig { returns(T.nilable(T::Boolean)) }
  def size; end

  # source://udb//lib/udb/logic.rb#597
  def to_asciidoc; end

  # source://udb//lib/udb/logic.rb#530
  sig { returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://udb//lib/udb/logic.rb#555
  sig { params(cfg_arch: T.nilable(::Udb::ConfiguredArchitecture)).returns(::String) }
  def to_idl(cfg_arch); end

  # source://udb//lib/udb/logic.rb#550
  sig { returns(::Udb::LogicNode) }
  def to_logic_node; end

  # source://udb//lib/udb/logic.rb#640
  sig { override.returns(::String) }
  def to_s; end

  # source://udb//lib/udb/logic.rb#646
  sig { returns(::String) }
  def to_s_pretty; end

  # source://udb//lib/udb/logic.rb#407
  sig { params(solver: ::Udb::Z3Solver, cfg_arch: ::Udb::ConfiguredArchitecture).returns(::Z3::BoolExpr) }
  def to_z3(solver, cfg_arch); end
end

# source://udb//lib/udb/logic.rb#301
class Udb::ParameterTerm::ParameterComparisonType < ::T::Enum
  enums do
    Equal = new
    GreaterThan = new
    GreaterThanOrEqual = new
    Includes = new
    LessThan = new
    LessThanOrEqual = new
    NotEqual = new
    OneOf = new
  end
end

# source://udb//lib/udb/logic.rb#314
Udb::ParameterTerm::ValueType = T.type_alias { T.any(::Integer, ::String, T::Array[T.any(::Integer, ::String)], T::Boolean) }

# source://udb//lib/udb/obj/parameter.rb#229
class Udb::ParameterWithValue
  include ::Idl::RuntimeParam
  extend ::Forwardable

  # source://udb//lib/udb/obj/parameter.rb#243
  sig do
    params(
      param: ::Udb::Parameter,
      value: T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)
    ).void
  end
  def initialize(param, value); end


  # source://udb//lib/udb/obj/parameter.rb#234
  def defined_by_condition(*args, **_arg1, &block); end

  # source://udb//lib/udb/obj/parameter.rb#234
  def description(*args, **_arg1, &block); end

  # source://udb//lib/udb/obj/parameter.rb#234
  def idl_type(*args, **_arg1, &block); end

  # source://udb//lib/udb/obj/parameter.rb#234
  def name(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def requirements_condition(*args, **_arg1, &block); end

  # source://udb//lib/udb/obj/parameter.rb#234
  def schema(*args, **_arg1, &block); end

  # source://udb//lib/udb/obj/parameter.rb#240
  sig do
    override
      .returns(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean))
  end
  def value; end

  # source://udb//lib/udb/obj/parameter.rb#249
  sig { override.returns(T::Boolean) }
  def value_known?; end
end

# source://udb//lib/udb/config.rb#211
class Udb::PartialConfig < ::Udb::AbstractConfig
  # source://udb//lib/udb/config.rb#217
  sig { params(data: T::Hash[::String, T.untyped], info: ::Udb::Resolver::ConfigInfo).void }
  def initialize(data, info); end

  # source://udb//lib/udb/config.rb#279
  sig { returns(T::Boolean) }
  def additional_extensions_allowed?; end

  # source://udb//lib/udb/config.rb#242
  sig { override.returns(T::Boolean) }
  def fully_configured?; end

  # source://udb//lib/udb/config.rb#251
  sig { returns(T::Array[T::Hash[::String, T.any(::String, T::Array[::String])]]) }
  def mandatory_extensions; end

  # source://udb//lib/udb/config.rb#239
  sig { override.returns(::Integer) }
  def mxlen; end

  # source://udb//lib/udb/config.rb#236
  sig do
    override
      .returns(T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)])
  end
  def param_values; end

  # source://udb//lib/udb/config.rb#245
  sig { override.returns(T::Boolean) }
  def partially_configured?; end

  # source://udb//lib/udb/config.rb#264
  sig { returns(T::Array[T::Hash[::String, T.any(::String, T::Array[::String])]]) }
  def prohibited_extensions; end

  # source://udb//lib/udb/config.rb#248
  sig { override.returns(T::Boolean) }
  def unconfigured?; end
end

# source://udb//lib/udb/obj/database_obj.rb#510
class Udb::Person
  include ::Comparable

  # source://udb//lib/udb/obj/database_obj.rb#529
  sig { params(data: T::Hash[::String, T.nilable(::String)]).void }
  def initialize(data); end

  # source://udb//lib/udb/obj/database_obj.rb#534
  sig { params(other: ::Udb::Person).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # source://udb//lib/udb/obj/database_obj.rb#526
  sig { returns(T.nilable(::String)) }
  def company; end

  # source://udb//lib/udb/obj/database_obj.rb#521
  sig { returns(T.nilable(::String)) }
  def email; end

  # source://udb//lib/udb/obj/database_obj.rb#516
  sig { returns(::String) }
  def name; end
end

# source://udb//lib/udb/obj/portfolio.rb#375
class Udb::Portfolio < ::Udb::TopLevelDatabaseObject
  # source://udb//lib/udb/obj/portfolio.rb#380
  sig do
    params(
      obj_yaml: T::Hash[::String, ::Object],
      yaml_path: T.any(::Pathname, ::String),
      arch: ::Udb::ConfiguredArchitecture
    ).void
  end
  def initialize(obj_yaml, yaml_path, arch); end

  # source://udb//lib/udb/obj/portfolio.rb#821
  def all_in_scope_exts_with_param(param); end

  # source://udb//lib/udb/obj/portfolio.rb#826
  def all_in_scope_exts_without_param(param); end

  # source://udb//lib/udb/obj/portfolio.rb#805
  def all_in_scope_params; end

  # source://udb//lib/udb/obj/portfolio.rb#812
  def all_out_of_scope_params; end

  # source://udb//lib/udb/obj/portfolio.rb#391
  def base; end

  # source://udb//lib/udb/obj/portfolio.rb#581
  def csr_presence(csr_name); end

  # source://udb//lib/udb/obj/portfolio.rb#552
  def csr_presence_obj(csr_name); end

  # source://udb//lib/udb/obj/portfolio.rb#388
  def description; end

  # source://udb//lib/udb/obj/portfolio.rb#618
  def extension_note(ext_name); end

  # source://udb//lib/udb/obj/portfolio.rb#407
  def extension_presence(ext_name); end

  # source://udb//lib/udb/obj/portfolio.rb#398
  def extension_presence_obj(ext_name); end

  # source://udb//lib/udb/obj/portfolio.rb#928
  def extra_notes; end

  # source://udb//lib/udb/obj/portfolio.rb#939
  sig { params(desired_presence_obj: ::Udb::Presence).returns(T::Array[::String]) }
  def extra_notes_for_presence(desired_presence_obj); end

  # source://udb//lib/udb/obj/portfolio.rb#737
  def in_scope_csrs(design); end

  # source://udb//lib/udb/obj/portfolio.rb#754
  def in_scope_exception_codes(design); end

  # source://udb//lib/udb/obj/portfolio.rb#635
  sig do
    params(
      desired_presence: T.nilable(T.any(::String, ::Udb::Presence, T::Hash[::String, T.untyped]))
    ).returns(T::Array[::Udb::PortfolioExtensionRequirement])
  end
  def in_scope_ext_reqs(desired_presence = T.unsafe(nil)); end

  # source://udb//lib/udb/obj/portfolio.rb#698
  def in_scope_extensions; end

  # source://udb//lib/udb/obj/portfolio.rb#724
  def in_scope_instructions(design); end

  # source://udb//lib/udb/obj/portfolio.rb#774
  def in_scope_interrupt_codes(design); end

  # source://udb//lib/udb/obj/portfolio.rb#710
  def in_scope_min_satisfying_extension_versions; end

  # source://udb//lib/udb/obj/portfolio.rb#809
  def in_scope_params(ext_req); end

  # source://udb//lib/udb/obj/portfolio.rb#540
  sig { params(inst_name: ::String).returns(T.nilable(::Udb::Presence)) }
  def instruction_presence(inst_name); end

  # source://udb//lib/udb/obj/portfolio.rb#416
  sig { params(inst_name: ::String).returns(T.nilable(::Udb::Presence)) }
  def instruction_presence_obj(inst_name); end

  # source://udb//lib/udb/obj/portfolio.rb#385
  def introduction; end

  # source://udb//lib/udb/obj/portfolio.rb#626
  def mandatory_ext_reqs; end

  # source://udb//lib/udb/obj/portfolio.rb#627
  def optional_ext_reqs; end

  # source://udb//lib/udb/obj/portfolio.rb#816
  def out_of_scope_params(ext_name); end

  # source://udb//lib/udb/obj/portfolio.rb#961
  def recommendations; end

  # source://udb//lib/udb/obj/portfolio.rb#903
  def revision_history; end

  # source://udb//lib/udb/obj/portfolio.rb#486
  sig { returns(::Udb::ConfiguredArchitecture) }
  def to_cfg_arch; end

  # source://udb//lib/udb/obj/portfolio.rb#499
  sig { returns(::Udb::ConfiguredArchitecture) }
  def to_cfg_arch_for_optional; end

  # source://udb//lib/udb/obj/portfolio.rb#444
  sig { returns(T::Hash[::String, T.untyped]) }
  def to_config; end

  # source://udb//lib/udb/obj/portfolio.rb#792
  def uses_optional_types?; end

  # source://udb//lib/udb/obj/portfolio.rb#394
  def version; end

  # source://udb//lib/udb/obj/portfolio.rb#593
  sig { params(ext_name: ::String, ext_versions: T::Array[::Udb::ExtensionVersion]).returns(T::Array[::String]) }
  def version_greatest_presence(ext_name, ext_versions); end
end

# source://udb//lib/udb/obj/portfolio.rb#917
class Udb::Portfolio::ExtraNote
  # source://udb//lib/udb/obj/portfolio.rb#918
  def initialize(data); end

  # source://udb//lib/udb/obj/portfolio.rb#924
  def presence_obj; end

  # source://udb//lib/udb/obj/portfolio.rb#925
  def text; end
end

# source://udb//lib/udb/obj/portfolio.rb#832
class Udb::Portfolio::InScopeParameter
  # source://udb//lib/udb/obj/portfolio.rb#839
  def initialize(param, schema_hash, note); end

  # source://udb//lib/udb/obj/portfolio.rb#879
  def <=>(other); end

  # source://udb//lib/udb/obj/portfolio.rb#864
  def allowed_values; end

  # source://udb//lib/udb/obj/portfolio.rb#854
  def idl_type; end

  # source://udb//lib/udb/obj/portfolio.rb#853
  def name; end

  # source://udb//lib/udb/obj/portfolio.rb#837
  def note; end

  # source://udb//lib/udb/obj/portfolio.rb#834
  def param; end

  # source://udb//lib/udb/obj/portfolio.rb#855
  def single_value?; end

  # source://udb//lib/udb/obj/portfolio.rb#857
  def value; end
end

# source://udb//lib/udb/obj/portfolio.rb#953
class Udb::Portfolio::Recommendation
  # source://udb//lib/udb/obj/portfolio.rb#954
  def initialize(data); end

  # source://udb//lib/udb/obj/portfolio.rb#958
  def text; end
end

# source://udb//lib/udb/obj/portfolio.rb#893
class Udb::Portfolio::RevisionHistory
  # source://udb//lib/udb/obj/portfolio.rb#894
  def initialize(data); end

  # source://udb//lib/udb/obj/portfolio.rb#900
  def changes; end

  # source://udb//lib/udb/obj/portfolio.rb#899
  def date; end

  # source://udb//lib/udb/obj/portfolio.rb#898
  def revision; end
end

# source://udb//lib/udb/obj/portfolio.rb#58
class Udb::PortfolioClass < ::Udb::TopLevelDatabaseObject
  # source://udb//lib/udb/obj/portfolio.rb#66
  def description; end

  # source://udb//lib/udb/obj/portfolio.rb#69
  def eql?(other); end

  # source://udb//lib/udb/obj/portfolio.rb#63
  def introduction; end

  # source://udb//lib/udb/obj/portfolio.rb#74
  def portfolio_classes_matching_portfolio_kind_and_processor_kind; end

  # source://udb//lib/udb/obj/portfolio.rb#60
  def processor_kind; end
end

# source://udb//lib/udb/obj/portfolio.rb#23
class Udb::PortfolioExtensionRequirement
  extend ::Forwardable

  # source://udb//lib/udb/obj/portfolio.rb#44
  sig do
    params(
      name: ::String,
      requirements: T.any(::String, T::Array[::String]),
      arch: ::Udb::ConfiguredArchitecture,
      note: T.nilable(::String),
      req_id: T.nilable(::String),
      presence: T.nilable(::Udb::Presence)
    ).void
  end
  def initialize(name, requirements, arch:, note:, req_id:, presence:); end

  # source://udb//lib/udb/obj/portfolio.rb#32
  def ext_req; end

  # source://udb//lib/udb/obj/portfolio.rb#27
  def extension(*args, **_arg1, &block); end

  # source://udb//lib/udb/obj/portfolio.rb#27
  def min_satisfying_ext_ver(*args, **_arg1, &block); end

  # source://udb//lib/udb/obj/portfolio.rb#27
  def name(*args, **_arg1, &block); end

  # source://udb//lib/udb/obj/portfolio.rb#32
  def note; end

  # source://udb//lib/udb/obj/portfolio.rb#32
  def presence; end

  # source://udb//lib/udb/obj/portfolio.rb#32
  def req_id; end

  # source://udb//lib/udb/obj/portfolio.rb#27
  def requirement_specs(*args, **_arg1, &block); end

  # source://udb//lib/udb/obj/portfolio.rb#27
  def requirement_specs_to_s_pretty(*args, **_arg1, &block); end

  # source://udb//lib/udb/obj/portfolio.rb#27
  def satisfied_by?(*args, **_arg1, &block); end

  # source://udb//lib/udb/obj/portfolio.rb#27
  def satisfying_versions(*args, **_arg1, &block); end

  # source://udb//lib/udb/obj/portfolio.rb#27
  def to_s(*args, **_arg1, &block); end

  # source://udb//lib/udb/obj/portfolio.rb#27
  def to_s_pretty(*args, **_arg1, &block); end
end

# source://udb//lib/udb/obj/portfolio.rb#89
class Udb::PortfolioGroup
  extend ::Forwardable

  # source://udb//lib/udb/obj/portfolio.rb#100
  def initialize(name, portfolios); end

  # source://udb//lib/udb/obj/portfolio.rb#347
  def all_in_scope_exts_with_param(param); end

  # source://udb//lib/udb/obj/portfolio.rb#359
  def all_in_scope_exts_without_param(param); end

  # source://udb//lib/udb/obj/portfolio.rb#303
  def all_in_scope_params; end

  # source://udb//lib/udb/obj/portfolio.rb#324
  def all_out_of_scope_params; end

  # source://udb//lib/udb/obj/portfolio.rb#287
  def csr_presence(csr_name); end

  # source://udb//lib/udb/obj/portfolio.rb#97
  def each(*args, **_arg1, &block); end

  # source://udb//lib/udb/obj/portfolio.rb#251
  sig { params(ext_name: ::String).returns(::String) }
  def extension_presence(ext_name); end

  # source://udb//lib/udb/obj/portfolio.rb#204
  def in_scope_csrs(design); end

  # source://udb//lib/udb/obj/portfolio.rb#219
  def in_scope_exception_codes(design); end

  # source://udb//lib/udb/obj/portfolio.rb#134
  def in_scope_ext_reqs; end

  # source://udb//lib/udb/obj/portfolio.rb#170
  def in_scope_extensions; end

  # source://udb//lib/udb/obj/portfolio.rb#186
  def in_scope_instructions(design); end

  # source://udb//lib/udb/obj/portfolio.rb#234
  def in_scope_interrupt_codes(design); end

  # source://udb//lib/udb/obj/portfolio.rb#314
  def in_scope_params(ext_req); end

  # source://udb//lib/udb/obj/portfolio.rb#269
  def instruction_presence(inst_name); end

  # source://udb//lib/udb/obj/portfolio.rb#146
  def mandatory_ext_reqs; end

  # source://udb//lib/udb/obj/portfolio.rb#97
  def map(*args, **_arg1, &block); end

  # source://udb//lib/udb/obj/portfolio.rb#124
  def max_base; end

  # source://udb//lib/udb/obj/portfolio.rb#93
  def name; end

  # source://udb//lib/udb/obj/portfolio.rb#158
  def optional_ext_reqs; end

  # source://udb//lib/udb/obj/portfolio.rb#335
  def out_of_scope_params(ext_name); end

  # source://udb//lib/udb/obj/portfolio.rb#112
  def param_values; end

  # source://udb//lib/udb/obj/portfolio.rb#109
  def portfolios; end

  # source://udb//lib/udb/obj/portfolio.rb#97
  def select(*args, **_arg1, &block); end
end

# source://udb//lib/udb/presence.rb#13
class Udb::Presence < ::T::Enum
  enums do
    DevelopmentOption = new
    ExpansionOption = new
    LocalizedOption = new
    Mandatory = new
    Option = new
    TransitoryOption = new
  end

  # source://udb//lib/udb/presence.rb#84
  sig { returns(T::Boolean) }
  def mandatory?; end

  # source://udb//lib/udb/presence.rb#87
  sig { returns(T::Boolean) }
  def optional?; end

  # source://udb//lib/udb/presence.rb#63
  sig { returns(T.nilable(::String)) }
  def optional_type; end

  # source://udb//lib/udb/presence.rb#51
  def presence; end

  # source://udb//lib/udb/presence.rb#90
  sig { override.returns(::String) }
  def to_s; end

  # source://udb//lib/udb/presence.rb#93
  sig { returns(::String) }
  def to_s_concise; end

  class << self
    # source://udb//lib/udb/presence.rb#24
    sig { params(yaml: T.any(::String, T::Hash[::String, ::String])).returns(::Udb::Presence) }
    def from_yaml(yaml); end
  end
end

# source://udb//lib/udb/obj/prm.rb#12
class Udb::Prm < ::Udb::TopLevelDatabaseObject
  # source://udb//lib/udb/obj/prm.rb#46
  def chapters; end

  # source://udb//lib/udb/obj/prm.rb#19
  def description; end

  # source://udb//lib/udb/obj/prm.rb#25
  def processor_config; end

  # source://udb//lib/udb/obj/prm.rb#15
  def resolver; end

  # source://udb//lib/udb/obj/prm.rb#15
  def resolver=(_arg0); end
end

# source://udb//lib/udb/obj/certificate.rb#20
class Udb::ProcCertClass < ::Udb::PortfolioClass; end

# source://udb//lib/udb/obj/certificate.rb#29
class Udb::ProcCertModel < ::Udb::Portfolio
  # source://udb//lib/udb/obj/certificate.rb#33
  def initialize(obj_yaml, yaml_path, arch); end

  # source://udb//lib/udb/obj/certificate.rb#210
  def all_in_scope_exts_with_param(param); end

  # source://udb//lib/udb/obj/certificate.rb#223
  def all_in_scope_exts_without_param(param); end

  # source://udb//lib/udb/obj/certificate.rb#164
  def all_in_scope_params; end

  # source://udb//lib/udb/obj/certificate.rb#186
  def all_out_of_scope_params; end

  # source://udb//lib/udb/obj/certificate.rb#39
  def debug_manual_revision; end

  # source://udb//lib/udb/obj/certificate.rb#51
  def in_scope_priv_modes; end

  # source://udb//lib/udb/obj/certificate.rb#203
  def out_of_scope_params(ext_name); end

  # source://udb//lib/udb/obj/certificate.rb#38
  def priv_isa_manual_revision; end

  # source://udb//lib/udb/obj/certificate.rb#54
  def proc_cert_class; end

  # source://udb//lib/udb/obj/certificate.rb#146
  def requirement_groups; end

  # source://udb//lib/udb/obj/certificate.rb#41
  def tsc_profile_release; end

  # source://udb//lib/udb/obj/certificate.rb#37
  def unpriv_isa_manual_revision; end
end

# source://udb//lib/udb/obj/certificate.rb#66
class Udb::ProcCertModel::Requirement
  # source://udb//lib/udb/obj/certificate.rb#69
  def initialize(data, arch); end

  # source://udb//lib/udb/obj/certificate.rb#78
  def description; end

  # source://udb//lib/udb/obj/certificate.rb#77
  def name; end

  # source://udb//lib/udb/obj/certificate.rb#79
  def when; end

  # source://udb//lib/udb/obj/certificate.rb#81
  def when_pretty; end
end

# source://udb//lib/udb/obj/certificate.rb#103
class Udb::ProcCertModel::RequirementGroup
  # source://udb//lib/udb/obj/certificate.rb#106
  def initialize(data, arch); end

  # source://udb//lib/udb/obj/certificate.rb#115
  def description; end

  # source://udb//lib/udb/obj/certificate.rb#114
  def name; end

  # source://udb//lib/udb/obj/certificate.rb#134
  def requirements; end

  # source://udb//lib/udb/obj/certificate.rb#116
  def when; end

  # source://udb//lib/udb/obj/certificate.rb#118
  def when_pretty; end
end

# source://udb//lib/udb/obj/profile.rb#174
class Udb::Profile < ::Udb::Portfolio
  # source://udb//lib/udb/obj/profile.rb#199
  def all_in_scope_params; end

  # source://udb//lib/udb/obj/profile.rb#195
  def base; end

  # source://udb//lib/udb/obj/profile.rb#270
  def ext_note_to_adoc(ext_name); end

  # source://udb//lib/udb/obj/profile.rb#257
  def ext_req_to_adoc(ext_req); end

  # source://udb//lib/udb/obj/profile.rb#207
  def extensions_to_adoc(presence_type, heading_level); end

  # source://udb//lib/udb/obj/profile.rb#176
  def marketing_name; end

  # source://udb//lib/udb/obj/profile.rb#190
  def mode; end

  # source://udb//lib/udb/obj/profile.rb#187
  def profile_family; end

  # source://udb//lib/udb/obj/profile.rb#179
  def profile_release; end
end

# source://udb//lib/udb/obj/profile.rb#14
class Udb::ProfileFamily < ::Udb::PortfolioClass
  # source://udb//lib/udb/obj/profile.rb#22
  def company; end

  # source://udb//lib/udb/obj/profile.rb#25
  def doc_license; end

  # source://udb//lib/udb/obj/profile.rb#68
  def in_scope_extensions; end

  # source://udb//lib/udb/obj/profile.rb#80
  def in_scope_extensions_matching_processor_kind; end

  # source://udb//lib/udb/obj/profile.rb#19
  def marketing_name; end

  # source://udb//lib/udb/obj/profile.rb#16
  def naming_scheme; end

  # source://udb//lib/udb/obj/profile.rb#30
  def profile_releases; end

  # source://udb//lib/udb/obj/profile.rb#39
  def profile_releases_matching_processor_kind; end

  # source://udb//lib/udb/obj/profile.rb#53
  def profiles; end

  # source://udb//lib/udb/obj/profile.rb#60
  def profiles_matching_processor_kind; end
end

# source://udb//lib/udb/obj/profile.rb#97
class Udb::ProfileRelease < ::Udb::TopLevelDatabaseObject
  # source://udb//lib/udb/obj/profile.rb#153
  def all_in_scope_params; end

  # source://udb//lib/udb/obj/profile.rb#114
  def contributors; end

  # source://udb//lib/udb/obj/profile.rb#170
  def csr_presence(csr_name); end

  # source://udb//lib/udb/obj/profile.rb#160
  def extension_presence(ext_name); end

  # source://udb//lib/udb/obj/profile.rb#151
  def in_scope_extensions; end

  # source://udb//lib/udb/obj/profile.rb#165
  def instruction_presence(inst_name); end

  # source://udb//lib/udb/obj/profile.rb#101
  def introduction; end

  # source://udb//lib/udb/obj/profile.rb#98
  def marketing_name; end

  # source://udb//lib/udb/obj/profile.rb#140
  def portfolio_grp; end

  # source://udb//lib/udb/obj/profile.rb#121
  def profile_family; end

  # source://udb//lib/udb/obj/profile.rb#129
  def profiles; end

  # source://udb//lib/udb/obj/profile.rb#107
  def ratification_date; end

  # source://udb//lib/udb/obj/profile.rb#103
  def state; end
end

# source://udb//lib/udb/obj/register_file.rb#12
class Udb::RegisterFile < ::Udb::TopLevelDatabaseObject
  # source://udb//lib/udb/obj/register_file.rb#107
  sig { returns(T.nilable(::String)) }
  def register_class; end

  # source://udb//lib/udb/obj/register_file.rb#101
  sig { returns(T.any(::Integer, ::String)) }
  def register_length; end

  # source://udb//lib/udb/obj/register_file.rb#110
  sig { returns(T::Array[::Udb::RegisterFile::RegisterEntry]) }
  def registers; end

  # source://udb//lib/udb/obj/register_file.rb#104
  sig { returns(T.nilable(::String)) }
  def summary; end

  # source://udb//lib/udb/obj/register_file.rb#115
  sig { returns(T::Array[T::Hash[::String, T.untyped]]) }
  def templates; end
end

# source://udb//lib/udb/obj/register_file.rb#15
class Udb::RegisterFile::RegisterEntry
  # source://udb//lib/udb/obj/register_file.rb#40
  sig { params(file: ::Udb::RegisterFile, data: T::Hash[::String, T.untyped], index: ::Integer).void }
  def initialize(file, data, index); end

  # source://udb//lib/udb/obj/register_file.rb#50
  sig { returns(T::Array[::String]) }
  def abi_mnemonics; end

  # source://udb//lib/udb/obj/register_file.rb#70
  sig { returns(T.nilable(::String)) }
  def arch_read; end

  # source://udb//lib/udb/obj/register_file.rb#75
  sig { returns(T.nilable(::String)) }
  def arch_write; end

  # source://udb//lib/udb/obj/register_file.rb#67
  sig { returns(T.nilable(T::Boolean)) }
  def callee_saved; end

  # source://udb//lib/udb/obj/register_file.rb#64
  sig { returns(T.nilable(T::Boolean)) }
  def caller_saved; end

  # source://udb//lib/udb/obj/register_file.rb#34
  sig { returns(T::Hash[::String, T.untyped]) }
  def data; end

  # source://udb//lib/udb/obj/register_file.rb#86
  sig { returns(T.nilable(::Udb::AbstractCondition)) }
  def defined_by_condition; end

  # source://udb//lib/udb/obj/register_file.rb#56
  sig { returns(T.nilable(::String)) }
  def description; end

  # source://udb//lib/udb/obj/register_file.rb#37
  sig { returns(T.any(::Integer, ::String)) }
  def index; end

  # source://udb//lib/udb/obj/register_file.rb#47
  sig { returns(::String) }
  def name; end

  # source://udb//lib/udb/obj/register_file.rb#59
  sig { returns(T::Array[::Udb::RegisterFile::RegisterEntry::Role]) }
  def roles; end

  # source://udb//lib/udb/obj/register_file.rb#80
  sig { returns(T.nilable(::String)) }
  def sw_read; end

  # source://udb//lib/udb/obj/register_file.rb#83
  sig { returns(T.nilable(::String)) }
  def sw_write; end

  # source://udb//lib/udb/obj/register_file.rb#93
  sig { returns(T.nilable(::Udb::Condition)) }
  def when_condition; end
end

# source://udb//lib/udb/obj/register_file.rb#18
class Udb::RegisterFile::RegisterEntry::Role < ::T::Enum
  enums do
    AlternateLinkRegister = new
    Argument = new
    FramePointer = new
    GlobalPointer = new
    ReturnAddress = new
    ReturnValue = new
    StackPointer = new
    Temporary = new
    ThreadPointer = new
    Zero = new
  end
end

# source://udb//lib/udb/version_spec.rb#179
class Udb::RequirementSpec
  # source://udb//lib/udb/version_spec.rb#192
  sig { params(requirement: ::String).void }
  def initialize(requirement); end

  # source://udb//lib/udb/version_spec.rb#206
  sig { override.params(other: T.untyped).returns(T::Boolean) }
  def eql?(other); end

  # source://udb//lib/udb/version_spec.rb#215
  sig { override.returns(::Integer) }
  def hash; end

  # source://udb//lib/udb/version_spec.rb#185
  sig { returns(::String) }
  def op; end

  # source://udb//lib/udb/version_spec.rb#252
  sig do
    params(
      version: T.any(::String, ::Udb::VersionSpec),
      ext: T.any(::Udb::Extension, T::Hash[::String, T.untyped])
    ).returns(T::Boolean)
  end
  def satisfied_by?(version, ext); end

  # source://udb//lib/udb/version_spec.rb#220
  sig { returns(::String) }
  def to_s; end

  # source://udb//lib/udb/version_spec.rb#188
  sig { returns(::Udb::VersionSpec) }
  def version_spec; end
end

# source://udb//lib/udb/version_spec.rb#181
Udb::RequirementSpec::REQUIREMENT_OP_REGEX = T.let(T.unsafe(nil), Regexp)

# source://udb//lib/udb/version_spec.rb#182
Udb::RequirementSpec::REQUIREMENT_REGEX = T.let(T.unsafe(nil), Regexp)

# source://udb//lib/udb/resolver.rb#67
class Udb::Resolver
  # source://udb//lib/udb/resolver.rb#147
  sig do
    params(
      repo_root: ::Pathname,
      schemas_path_override: T.nilable(::Pathname),
      cfgs_path_override: T.nilable(::Pathname),
      gen_path_override: T.nilable(::Pathname),
      std_path_override: T.nilable(::Pathname),
      custom_path_override: T.nilable(::Pathname),
      quiet: T::Boolean,
      compile_idl: T::Boolean
    ).void
  end
  def initialize(repo_root = T.unsafe(nil), schemas_path_override: T.unsafe(nil), cfgs_path_override: T.unsafe(nil), gen_path_override: T.unsafe(nil), std_path_override: T.unsafe(nil), custom_path_override: T.unsafe(nil), quiet: T.unsafe(nil), compile_idl: T.unsafe(nil)); end

  # source://udb//lib/udb/resolver.rb#175
  sig { params(target: ::Pathname, deps: T::Array[::Pathname]).returns(T::Boolean) }
  def any_newer?(target, deps); end

  # source://udb//lib/udb/resolver.rb#343
  sig { params(config_path_or_name: T.any(::Pathname, ::String)).returns(::Udb::ConfiguredArchitecture) }
  def cfg_arch_for(config_path_or_name); end

  # source://udb//lib/udb/resolver.rb#289
  sig { params(config_path_or_name: T.any(::Pathname, ::String)).returns(::Udb::Resolver::ConfigInfo) }
  def cfg_info(config_path_or_name); end

  # source://udb//lib/udb/resolver.rb#89
  sig { returns(::Pathname) }
  def cfgs_path; end

  # source://udb//lib/udb/resolver.rb#101
  sig { returns(::Pathname) }
  def custom_path; end

  # source://udb//lib/udb/resolver.rb#93
  sig { returns(::Pathname) }
  def gen_path; end

  # source://udb//lib/udb/resolver.rb#222
  sig { params(config_yaml: T::Hash[::String, T.untyped]).void }
  def merge_arch(config_yaml); end

  # source://udb//lib/udb/resolver.rb#105
  sig { params(cfg_path_or_name: T.any(::Pathname, ::String)).returns(::Pathname) }
  def merged_spec_path(cfg_path_or_name); end

  # source://udb//lib/udb/resolver.rb#256
  sig { params(config_yaml: T::Hash[::String, T.untyped]).void }
  def resolve_arch(config_yaml); end

  # source://udb//lib/udb/resolver.rb#198
  sig { params(config_path: ::Pathname).returns(T::Hash[::String, T.untyped]) }
  def resolve_config(config_path); end

  # source://udb//lib/udb/resolver.rb#117
  sig { params(cfg_path_or_name: T.any(::Pathname, ::String)).returns(::Pathname) }
  def resolved_spec_path(cfg_path_or_name); end

  # source://udb//lib/udb/resolver.rb#185
  sig { params(cmd: T::Array[::String]).void }
  def run(cmd); end

  # source://udb//lib/udb/resolver.rb#85
  sig { returns(::Pathname) }
  def schemas_path; end

  # source://udb//lib/udb/resolver.rb#97
  sig { returns(::Pathname) }
  def std_path; end
end

# source://udb//lib/udb/resolver.rb#71
class Udb::Resolver::ConfigInfo < ::T::Struct
  prop :name, ::String
  prop :path, ::Pathname
  prop :overlay_path, T.nilable(::Pathname)
  const :unresolved_yaml, T::Hash[::String, T.untyped]
  prop :resolved_yaml, T.nilable(T::Hash[::String, T.untyped])
  const :spec_path, ::Pathname
  const :merged_spec_path, ::Pathname
  const :resolved_spec_path, ::Pathname
  const :resolver, ::Udb::Resolver
end

# source://udb//lib/udb/condition.rb#99
class Udb::SatisfiedResult < ::T::Enum
  enums do
    Maybe = new
    No = new
    Yes = new
  end
end

# source://udb//lib/udb/obj/parameter.rb#16
class Udb::Schema
  include ::Idl::Schema

  # source://udb//lib/udb/schema.rb#25
  sig { params(schema_hash: T::Hash[::String, T.untyped]).void }
  def initialize(schema_hash); end

  # source://udb//lib/udb/schema.rb#225
  sig { returns(T::Boolean) }
  def empty?; end

  # source://udb//lib/udb/schema.rb#287
  def is_power_of_two?(num); end

  # source://udb//lib/udb/schema.rb#207
  sig { params(value: T.nilable(T.any(::Numeric, ::String, T::Boolean))).returns(::String) }
  def large2hex(value); end

  # source://udb//lib/udb/schema.rb#261
  sig { override.returns(::Integer) }
  def max_val; end

  # source://udb//lib/udb/schema.rb#243
  sig { override.returns(T::Boolean) }
  def max_val_known?; end

  # source://udb//lib/udb/schema.rb#218
  sig { params(other_schema: T.any(::Udb::Schema, T::Hash[::String, T.untyped])).returns(::Udb::Schema) }
  def merge(other_schema); end

  # source://udb//lib/udb/schema.rb#275
  sig { override.returns(::Integer) }
  def min_val; end

  # source://udb//lib/udb/schema.rb#252
  sig { override.returns(T::Boolean) }
  def min_val_known?; end

  # source://udb//lib/udb/schema.rb#294
  def num_bits(min, max); end

  # source://udb//lib/udb/schema.rb#230
  sig { returns(T::Boolean) }
  def single_value?; end

  # source://udb//lib/udb/schema.rb#43
  sig { returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://udb//lib/udb/schema.rb#301
  sig { override.returns(::Idl::Type) }
  def to_idl_type; end

  # source://udb//lib/udb/schema.rb#95
  sig { params(schema_hash: T::Hash[::String, T.untyped]).returns(::String) }
  def to_pretty_s(schema_hash = T.unsafe(nil)); end

  # source://udb//lib/udb/schema.rb#89
  sig { returns(::String) }
  def type_pretty; end

  # source://udb//lib/udb/schema.rb#30
  sig { params(rb_value: T.untyped, udb_resolver: ::Udb::Resolver).returns(T::Boolean) }
  def validate(rb_value, udb_resolver:); end

  # source://udb//lib/udb/schema.rb#235
  sig { returns(::Object) }
  def value; end

  private

  # source://udb//lib/udb/schema.rb#46
  sig { params(rb_type: ::Object).returns(::String) }
  def rb_obj_to_jsonschema_type(rb_type); end

  # source://udb//lib/udb/schema.rb#66
  sig { params(hsh: T::Hash[::String, T.untyped]).returns(::String) }
  def type_pretty_helper(hsh); end
end

# source://udb//lib/udb/logic.rb#1165
Udb::TermType = T.type_alias { T.any(::Udb::ExtensionTerm, ::Udb::FreeTerm, ::Udb::ParameterTerm, ::Udb::XlenTerm) }

# source://udb//lib/udb/condition.rb#17
class Udb::TopLevelDatabaseObject < ::Udb::DatabaseObject
  # source://udb//lib/udb/obj/database_obj.rb#445
  sig do
    params(
      data: T::Hash[::String, T.untyped],
      data_path: T.any(::Pathname, ::String),
      arch: ::Udb::ConfiguredArchitecture
    ).void
  end
  def initialize(data, data_path, arch); end

  # source://udb//lib/udb/obj/database_obj.rb#456
  sig { params(k: ::String).returns(T::Boolean) }
  def key?(k); end

  # source://udb//lib/udb/obj/database_obj.rb#451
  sig { returns(T::Array[::String]) }
  def keys; end

  # source://udb//lib/udb/obj/database_obj.rb#399
  sig { overridable.params(resolver: ::Udb::Resolver).void }
  def validate(resolver); end

  class << self
    # source://udb//lib/udb/obj/database_obj.rb#384
    sig { params(udb_resolver: ::Udb::Resolver).returns(T.proc.params(pattern: ::Regexp).returns(T.untyped)) }
    def create_json_schemer_resolver(udb_resolver); end
  end
end

# source://udb//lib/udb/obj/database_obj.rb#314
class Udb::TopLevelDatabaseObject::SchemaError < ::StandardError
  # source://udb//lib/udb/obj/database_obj.rb#318
  def initialize(result); end

  # source://udb//lib/udb/obj/database_obj.rb#316
  def result; end
end

# source://udb//lib/udb/obj/database_obj.rb#329
class Udb::TopLevelDatabaseObject::SchemaValidationError < ::StandardError
  # source://udb//lib/udb/obj/database_obj.rb#337
  def initialize(path, result); end

  # source://udb//lib/udb/obj/database_obj.rb#332
  def result; end
end

# source://udb//lib/udb/obj/database_obj.rb#379
class Udb::TopLevelDatabaseObject::ValidationError < ::StandardError; end

# source://udb//lib/udb/config.rb#172
class Udb::UnConfig < ::Udb::AbstractConfig
  # source://udb//lib/udb/config.rb#178
  sig { params(data: T::Hash[::String, T.untyped], info: ::Udb::Resolver::ConfigInfo).void }
  def initialize(data, info); end

  # source://udb//lib/udb/config.rb#195
  sig { override.returns(T::Boolean) }
  def fully_configured?; end

  # source://udb//lib/udb/config.rb#192
  sig { override.returns(::NilClass) }
  def mxlen; end

  # source://udb//lib/udb/config.rb#189
  sig do
    override
      .returns(T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)])
  end
  def param_values; end

  # source://udb//lib/udb/config.rb#198
  sig { override.returns(T::Boolean) }
  def partially_configured?; end

  # source://udb//lib/udb/config.rb#201
  sig { override.returns(T::Boolean) }
  def unconfigured?; end
end

# source://udb//lib/udb/version_spec.rb#35
class Udb::VersionSpec
  include ::Comparable

  # source://udb//lib/udb/version_spec.rb#56
  sig { params(version_str: ::String).void }
  def initialize(version_str); end

  # source://udb//lib/udb/version_spec.rb#104
  sig { params(other: T.untyped).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # source://udb//lib/udb/version_spec.rb#82
  sig { returns(::String) }
  def canonical; end

  # source://udb//lib/udb/version_spec.rb#146
  sig { returns(::Udb::VersionSpec) }
  def decrement_patch; end

  # source://udb//lib/udb/version_spec.rb#125
  sig { override.params(other: T.untyped).returns(T::Boolean) }
  def eql?(other); end

  # source://udb//lib/udb/version_spec.rb#134
  sig { override.returns(::Integer) }
  def hash; end

  # source://udb//lib/udb/version_spec.rb#139
  sig { returns(::Udb::VersionSpec) }
  def increment_patch; end

  # source://udb//lib/udb/version_spec.rb#76
  sig { returns(::String) }
  def inspect; end

  # source://udb//lib/udb/version_spec.rb#44
  def major; end

  # source://udb//lib/udb/version_spec.rb#47
  def minor; end

  # source://udb//lib/udb/version_spec.rb#50
  def patch; end

  # source://udb//lib/udb/version_spec.rb#53
  def pre; end

  # source://udb//lib/udb/version_spec.rb#91
  sig { returns(::String) }
  def to_rvi_s; end

  # source://udb//lib/udb/version_spec.rb#101
  sig { returns(::String) }
  def to_s; end
end

# source://udb//lib/udb/version_spec.rb#41
Udb::VersionSpec::VERSION_REGEX = T.let(T.unsafe(nil), Regexp)

# source://udb//lib/udb/condition.rb#1716
class Udb::XlenCondition < ::Udb::Condition
  # source://udb//lib/udb/condition.rb#1720
  sig { params(xlen: ::Integer).void }
  def initialize(xlen); end

  # source://udb//lib/udb/condition.rb#1736
  sig { override.returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_h; end

  # source://udb//lib/udb/condition.rb#1739
  sig { override.params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(::String) }
  def to_idl(cfg_arch); end

  # source://udb//lib/udb/condition.rb#1725
  sig { override.returns(::Udb::LogicNode) }
  def to_logic_tree_internal; end
end

# source://udb//lib/udb/logic.rb#38
class Udb::XlenTerm
  include ::Comparable

  # source://udb//lib/udb/logic.rb#45
  sig { params(xlen: ::Integer).void }
  def initialize(xlen); end

  # source://udb//lib/udb/logic.rb#88
  sig { override.params(other: T.untyped).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # source://udb//lib/udb/logic.rb#104
  sig { override.params(other: T.untyped).returns(T::Boolean) }
  def eql?(other); end

  # source://udb//lib/udb/logic.rb#96
  sig { override.returns(::Integer) }
  def hash; end

  # source://udb//lib/udb/logic.rb#68
  sig { returns(::String) }
  def to_asciidoc; end

  # source://udb//lib/udb/logic.rb#50
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(::Udb::Condition) }
  def to_condition(cfg_arch); end

  # source://udb//lib/udb/logic.rb#71
  sig { returns(T::Hash[::String, ::Integer]) }
  def to_h; end

  # source://udb//lib/udb/logic.rb#78
  sig { params(cfg_arch: ::Udb::ConfiguredArchitecture).returns(::String) }
  def to_idl(cfg_arch); end

  # source://udb//lib/udb/logic.rb#55
  sig { override.returns(::String) }
  def to_s; end

  # source://udb//lib/udb/logic.rb#65
  sig { returns(::String) }
  def to_s_pretty; end

  # source://udb//lib/udb/logic.rb#60
  sig { params(solver: ::Udb::Z3Solver).returns(::Z3::BoolExpr) }
  def to_z3(solver); end

  # source://udb//lib/udb/logic.rb#42
  def xlen; end
end

# source://udb//lib/udb/z3.rb#432
class Udb::Z3ExtensionRequirement
  # source://udb//lib/udb/z3.rb#436
  sig do
    params(
      name: ::String,
      req: T.any(::Udb::RequirementSpec, T::Array[::Udb::RequirementSpec]),
      solver: ::Udb::Z3Solver,
      cfg_arch: ::Udb::ConfiguredArchitecture
    ).void
  end
  def initialize(name, req, solver, cfg_arch); end

  # source://udb//lib/udb/z3.rb#468
  sig { returns(::Z3::BoolExpr) }
  def term; end
end

# source://udb//lib/udb/z3.rb#471
class Udb::Z3ExtensionVersion
  # source://udb//lib/udb/z3.rb#478
  sig do
    params(
      name: ::String,
      version: ::Udb::VersionSpec,
      solver: ::Udb::Z3Solver,
      cfg_arch: ::Udb::ConfiguredArchitecture
    ).void
  end
  def initialize(name, version, solver, cfg_arch); end

  # source://udb//lib/udb/z3.rb#505
  sig { params(ver: T.any(::String, ::Udb::VersionSpec)).returns(::Z3::BoolExpr) }
  def !=(ver); end

  # source://udb//lib/udb/z3.rb#543
  sig { params(ver: T.any(::String, ::Udb::VersionSpec)).returns(::Z3::BoolExpr) }
  def <(ver); end

  # source://udb//lib/udb/z3.rb#536
  sig { params(ver: T.any(::String, ::Udb::VersionSpec)).returns(::Z3::BoolExpr) }
  def <=(ver); end

  # source://udb//lib/udb/z3.rb#498
  sig { params(ver: T.any(::String, ::Udb::VersionSpec)).returns(::Z3::BoolExpr) }
  def ==(ver); end

  # source://udb//lib/udb/z3.rb#519
  sig { params(ver: T.any(::String, ::Udb::VersionSpec)).returns(::Z3::BoolExpr) }
  def >(ver); end

  # source://udb//lib/udb/z3.rb#512
  sig { params(ver: T.any(::String, ::Udb::VersionSpec)).returns(::Z3::BoolExpr) }
  def >=(ver); end

  # source://udb//lib/udb/z3.rb#475
  sig { returns(::Z3::BoolExpr) }
  def term; end
end

# source://udb//lib/udb/z3.rb#22
class Udb::Z3FiniteArray
  # source://udb//lib/udb/z3.rb#26
  sig do
    params(
      solver: ::Udb::Z3Solver,
      name: ::String,
      sort: T.any(T.class_of(Z3::BitvecSort), T.class_of(Z3::BoolSort), T.class_of(Z3::IntSort)),
      max_n: ::Integer,
      bitvec_width: T.nilable(::Integer)
    ).void
  end
  def initialize(solver, name, sort, max_n, bitvec_width: T.unsafe(nil)); end

  # source://udb//lib/udb/z3.rb#36
  sig { params(idx: ::Integer).returns(T.any(::Z3::BitvecExpr, ::Z3::BoolExpr, ::Z3::IntExpr)) }
  def [](idx); end

  # source://udb//lib/udb/z3.rb#52
  def max_size; end

  # source://udb//lib/udb/z3.rb#50
  def size_term; end
end

# source://udb//lib/udb/z3_loader.rb#50
module Udb::Z3Loader
  class << self
    # source://udb//lib/udb/z3_loader.rb#60
    sig { void }
    def ensure_z3_loaded; end

    # source://udb//lib/udb/z3_loader.rb#73
    sig { returns(::String) }
    def z3_lib_dir; end

    private

    # source://udb//lib/udb/z3_loader.rb#127
    sig { void }
    def configure_library_path; end

    # source://udb//lib/udb/z3_loader.rb#96
    sig { returns(T::Boolean) }
    def correct_version_installed?; end

    # source://udb//lib/udb/z3_loader.rb#155
    sig { returns(::String) }
    def detect_platform; end

    # source://udb//lib/udb/z3_loader.rb#197
    sig { void }
    def download_and_install_z3; end

    # source://udb//lib/udb/z3_loader.rb#246
    sig { params(url: ::String, destination: ::String).void }
    def download_file(url, destination); end

    # source://udb//lib/udb/z3_loader.rb#273
    sig { params(zip_path: ::String, destination: ::String).void }
    def extract_zip(zip_path, destination); end

    # source://udb//lib/udb/z3_loader.rb#286
    sig { params(source_dir: ::String).void }
    def install_z3(source_dir); end

    # source://udb//lib/udb/z3_loader.rb#81
    sig { returns(::String) }
    def library_name; end

    # source://udb//lib/udb/z3_loader.rb#123
    sig { returns(::String) }
    def z3_bin_dir; end

    # source://udb//lib/udb/z3_loader.rb#108
    sig { returns(::String) }
    def z3_install_dir; end
  end
end

# source://udb//lib/udb/z3_loader.rb#53
class Udb::Z3Loader::Z3LoadError < ::StandardError; end

# source://udb//lib/udb/z3.rb#58
class Udb::Z3ParameterTerm
  # source://udb//lib/udb/z3.rb#334
  sig { params(name: ::String, solver: ::Udb::Z3Solver, schema_hsh: T::Hash[::String, T.untyped]).void }
  def initialize(name, solver, schema_hsh); end

  # source://udb//lib/udb/z3.rb#402
  sig { params(val: T.any(::Integer, ::String, T::Boolean)).returns(::Z3::BoolExpr) }
  def !=(val); end

  # source://udb//lib/udb/z3.rb#416
  sig { params(val: ::Integer).returns(::Z3::BoolExpr) }
  def <(val); end

  # source://udb//lib/udb/z3.rb#411
  sig { params(val: ::Integer).returns(::Z3::BoolExpr) }
  def <=(val); end

  # source://udb//lib/udb/z3.rb#393
  sig { params(val: T.any(::Integer, ::String, T::Boolean)).returns(::Z3::BoolExpr) }
  def ==(val); end

  # source://udb//lib/udb/z3.rb#426
  sig { params(val: ::Integer).returns(::Z3::BoolExpr) }
  def >(val); end

  # source://udb//lib/udb/z3.rb#421
  sig { params(val: ::Integer).returns(::Z3::BoolExpr) }
  def >=(val); end

  # source://udb//lib/udb/z3.rb#388
  sig { params(idx: ::Integer).returns(T.any(::Z3::BitvecExpr, ::Z3::BoolExpr, ::Z3::IntExpr)) }
  def [](idx); end

  # source://udb//lib/udb/z3.rb#383
  sig { params(msb: ::Integer, lsb: ::Integer).returns(::Z3::BitvecExpr) }
  def extract(msb, lsb); end

  # source://udb//lib/udb/z3.rb#373
  sig { returns(::Z3::IntExpr) }
  def idx_term; end

  # source://udb//lib/udb/z3.rb#370
  sig { returns(::Integer) }
  def max_items; end

  # source://udb//lib/udb/z3.rb#378
  sig { returns(::Z3::IntExpr) }
  def size_term; end

  class << self
    # source://udb//lib/udb/z3.rb#184
    sig do
      params(
        solver: ::Udb::Z3Solver,
        term: ::Udb::Z3FiniteArray,
        schema_hsh: T::Hash[::String, T.untyped],
        subtype_constrain: ::Method
      ).void
    end
    def constrain_array(solver, term, schema_hsh, subtype_constrain); end

    # source://udb//lib/udb/z3.rb#119
    sig { params(solver: ::Udb::Z3Solver, term: ::Z3::BoolExpr, schema_hsh: T::Hash[::String, T.untyped]).void }
    def constrain_bool(solver, term, schema_hsh); end

    # source://udb//lib/udb/z3.rb#63
    sig { params(solver: ::Udb::Z3Solver, term: ::Z3::BitvecExpr, schema_hsh: T::Hash[::String, T.untyped]).void }
    def constrain_int(solver, term, schema_hsh); end

    # source://udb//lib/udb/z3.rb#145
    def constrain_string(solver, term, schema_hsh); end

    # source://udb//lib/udb/z3.rb#323
    sig { params(schema_hsh: T::Hash[::String, T.untyped]).returns(::Symbol) }
    def detect_array_subtype(schema_hsh); end

    # source://udb//lib/udb/z3.rb#251
    sig { params(schema_hsh: T::Hash[::String, T.untyped]).returns(::Symbol) }
    def detect_type(schema_hsh); end
  end
end

# source://udb//lib/udb/z3.rb#560
class Udb::Z3Solver
  extend ::Forwardable

  # source://udb//lib/udb/z3.rb#571
  def initialize; end

  # source://udb//lib/udb/z3.rb#564
  def assert(*args, **_arg1, &block); end

  # source://udb//lib/udb/z3.rb#564
  def assertions(*args, **_arg1, &block); end

  # source://udb//lib/udb/z3.rb#564
  def check(*args, **_arg1, &block); end

  # source://udb//lib/udb/z3.rb#620
  sig { params(name: ::String).returns(::Z3::IntExpr) }
  def ext_major(name); end

  # source://udb//lib/udb/z3.rb#625
  sig { params(name: ::String).returns(::Z3::IntExpr) }
  def ext_minor(name); end

  # source://udb//lib/udb/z3.rb#630
  sig { params(name: ::String).returns(::Z3::IntExpr) }
  def ext_patch(name); end

  # source://udb//lib/udb/z3.rb#635
  sig { params(name: ::String).returns(::Z3::BoolExpr) }
  def ext_pre(name); end

  # source://udb//lib/udb/z3.rb#614
  sig do
    params(
      name: ::String,
      req: T.any(::Udb::RequirementSpec, T::Array[::Udb::RequirementSpec]),
      cfg_arch: ::Udb::ConfiguredArchitecture
    ).returns(::Udb::Z3ExtensionRequirement)
  end
  def ext_req(name, req, cfg_arch); end

  # source://udb//lib/udb/z3.rb#603
  sig do
    params(
      name: ::String,
      version: T.any(::String, ::Udb::VersionSpec),
      cfg_arch: ::Udb::ConfiguredArchitecture
    ).returns(::Udb::Z3ExtensionVersion)
  end
  def ext_ver(name, version, cfg_arch); end

  # source://udb//lib/udb/z3.rb#564
  def model(*args, **_arg1, &block); end

  # source://udb//lib/udb/z3.rb#641
  sig { params(name: ::String, schema_hsh: T::Hash[::String, T.untyped]).returns(::Udb::Z3ParameterTerm) }
  def param(name, schema_hsh); end

  # source://udb//lib/udb/z3.rb#583
  def pop; end

  # source://udb//lib/udb/z3.rb#564
  def prove!(*args, **_arg1, &block); end

  # source://udb//lib/udb/z3.rb#564
  def push(*args, **_arg1, &block); end

  # source://udb//lib/udb/z3.rb#564
  def satisfiable?(*args, **_arg1, &block); end

  # source://udb//lib/udb/z3.rb#564
  def unsatisfiable?(*args, **_arg1, &block); end

  # source://udb//lib/udb/z3.rb#594
  sig { returns(::Z3::IntExpr) }
  def xlen; end
end

# source://udb//lib/udb/z3.rb#18
class Udb::Z3Sovler; end

# source://udb//lib/udb/z3_version.rb#10
Udb::Z3_VERSION = T.let(T.unsafe(nil), String)
