# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `idlc` gem.
# Please instead update this file by running `bin/tapioca gem idlc`.


# source://idlc//lib/idlc/syntax_node.rb#48
module Idl
  include ::Treetop::Runtime

  # source://idlc//lib/idlc/idl_parser.rb#6275
  def _nt_ary_access; end

  # source://idlc//lib/idlc/idl_parser.rb#6173
  def _nt_ary_eligible_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#11858
  def _nt_ary_size_decl; end

  # source://idlc//lib/idlc/idl_parser.rb#11104
  def _nt_assignment; end

  # source://idlc//lib/idlc/idl_parser.rb#889
  def _nt_bitfield_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#6576
  def _nt_bits_cast; end

  # source://idlc//lib/idlc/idl_parser.rb#9614
  def _nt_body_function_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#10378
  def _nt_builtin_function_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#16350
  def _nt_builtin_read_only_var; end

  # source://idlc//lib/idlc/idl_parser.rb#16374
  def _nt_builtin_read_write_var; end

  # source://idlc//lib/idlc/idl_parser.rb#14711
  def _nt_builtin_type_name; end

  # source://idlc//lib/idlc/idl_parser.rb#15960
  def _nt_comment; end

  # source://idlc//lib/idlc/idl_parser.rb#5747
  def _nt_concatenation_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#8614
  def _nt_constraint_body; end

  # source://idlc//lib/idlc/idl_parser.rb#5888
  def _nt_csr_field_access_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#16456
  def _nt_csr_field_name; end

  # source://idlc//lib/idlc/idl_parser.rb#16401
  def _nt_csr_name; end

  # source://idlc//lib/idlc/idl_parser.rb#5962
  def _nt_csr_register_access_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#12210
  def _nt_declaration; end

  # source://idlc//lib/idlc/idl_parser.rb#12650
  def _nt_dontcare_lvalue; end

  # source://idlc//lib/idlc/idl_parser.rb#12674
  def _nt_dontcare_return; end

  # source://idlc//lib/idlc/idl_parser.rb#468
  def _nt_enum_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#780
  def _nt_enum_ref; end

  # source://idlc//lib/idlc/idl_parser.rb#6699
  def _nt_enum_to_a; end

  # source://idlc//lib/idlc/idl_parser.rb#13759
  def _nt_execute_if_block; end

  # source://idlc//lib/idlc/idl_parser.rb#8704
  def _nt_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#10833
  def _nt_fetch; end

  # source://idlc//lib/idlc/idl_parser.rb#6058
  def _nt_field_access_eligible_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#6106
  def _nt_field_access_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#15834
  def _nt_field_name; end

  # source://idlc//lib/idlc/idl_parser.rb#14368
  def _nt_for_loop; end

  # source://idlc//lib/idlc/idl_parser.rb#12078
  def _nt_for_loop_iteration_variable_declaration; end

  # source://idlc//lib/idlc/idl_parser.rb#9432
  def _nt_function_arg_list; end

  # source://idlc//lib/idlc/idl_parser.rb#16108
  def _nt_function_body; end

  # source://idlc//lib/idlc/idl_parser.rb#8917
  def _nt_function_call; end

  # source://idlc//lib/idlc/idl_parser.rb#8784
  def _nt_function_call_template_arguments; end

  # source://idlc//lib/idlc/idl_parser.rb#10929
  def _nt_function_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#13101
  def _nt_function_if_block; end

  # source://idlc//lib/idlc/idl_parser.rb#9337
  def _nt_function_name; end

  # source://idlc//lib/idlc/idl_parser.rb#16051
  def _nt_function_statement; end

  # source://idlc//lib/idlc/idl_parser.rb#290
  def _nt_global_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#16286
  def _nt_id; end

  # source://idlc//lib/idlc/idl_parser.rb#8031
  def _nt_implication_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#8248
  def _nt_implication_for_loop; end

  # source://idlc//lib/idlc/idl_parser.rb#8551
  def _nt_implication_statement; end

  # source://idlc//lib/idlc/idl_parser.rb#196
  def _nt_include_statement; end

  # source://idlc//lib/idlc/idl_parser.rb#16192
  def _nt_instruction_operation; end

  # source://idlc//lib/idlc/idl_parser.rb#1529
  def _nt_int; end

  # source://idlc//lib/idlc/idl_parser.rb#26
  def _nt_isa; end

  # source://idlc//lib/idlc/idl_parser.rb#15088
  def _nt_keyword; end

  # source://idlc//lib/idlc/idl_parser.rb#3517
  def _nt_p0_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#2897
  def _nt_p0_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#3635
  def _nt_p1_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#2965
  def _nt_p1_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#3753
  def _nt_p2_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3033
  def _nt_p2_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#3871
  def _nt_p3_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3101
  def _nt_p3_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#3169
  def _nt_p3_template_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#4107
  def _nt_p4_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3213
  def _nt_p4_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#4343
  def _nt_p5_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3260
  def _nt_p5_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#4579
  def _nt_p6_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3313
  def _nt_p6_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#4815
  def _nt_p7_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3340
  def _nt_p7_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#5051
  def _nt_p8_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3393
  def _nt_p8_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#5287
  def _nt_p9_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3417
  def _nt_p9_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#5510
  def _nt_paren_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#6462
  def _nt_post_dec; end

  # source://idlc//lib/idlc/idl_parser.rb#6519
  def _nt_post_inc; end

  # source://idlc//lib/idlc/idl_parser.rb#5594
  def _nt_replication_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#15918
  def _nt_reserved; end

  # source://idlc//lib/idlc/idl_parser.rb#12726
  def _nt_return_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#12908
  def _nt_return_statement; end

  # source://idlc//lib/idlc/idl_parser.rb#10961
  def _nt_rval; end

  # source://idlc//lib/idlc/idl_parser.rb#12382
  def _nt_single_declaration; end

  # source://idlc//lib/idlc/idl_parser.rb#11949
  def _nt_single_declaration_with_initialization; end

  # source://idlc//lib/idlc/idl_parser.rb#16726
  def _nt_space; end

  # source://idlc//lib/idlc/idl_parser.rb#12480
  def _nt_statement; end

  # source://idlc//lib/idlc/idl_parser.rb#16631
  def _nt_string; end

  # source://idlc//lib/idlc/idl_parser.rb#1213
  def _nt_struct_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#8736
  def _nt_template_safe_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3989
  def _nt_template_safe_p3_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#4225
  def _nt_template_safe_p4_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#4461
  def _nt_template_safe_p5_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#4697
  def _nt_template_safe_p6_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#4933
  def _nt_template_safe_p7_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#5169
  def _nt_template_safe_p8_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#5405
  def _nt_template_safe_p9_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#7903
  def _nt_template_safe_ternary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#7782
  def _nt_ternary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#15886
  def _nt_type_name; end

  # source://idlc//lib/idlc/idl_parser.rb#6866
  def _nt_unary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3441
  def _nt_unary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#15767
  def _nt_user_type_name; end

  # source://idlc//lib/idlc/idl_parser.rb#16515
  def _nt_var_write; end

  # source://idlc//lib/idlc/idl_parser.rb#1397
  def _nt_version_string; end

  # source://idlc//lib/idlc/idl_parser.rb#12
  def root; end

  class << self
    # source://idlc//lib/idlc/log.rb#15
    sig { returns(::Logger) }
    def logger; end

    # source://idlc//lib/idlc/log.rb#20
    sig { params(logger: ::Logger).returns(::Logger) }
    def set_logger(logger); end
  end
end

# source://idlc//lib/idlc/ast.rb#1378
class Idl::ArrayIncludesAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1388
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      ary: T.all(::Idl::AstNode, ::Idl::Rvalue),
      value: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, ary, value); end

  # source://idlc//lib/idlc/ast.rb#1382
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def ary; end

  # source://idlc//lib/idlc/ast.rb#1416
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1385
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def expr; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#305
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1422
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1419
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#142
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#1406
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1393
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1411
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1430
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1372
class Idl::ArrayIncludesSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1373
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#5262
class Idl::ArrayLiteralAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5266
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5270
  def element_nodes; end

  # source://idlc//lib/idlc/ast.rb#5268
  def entries; end

  # source://idlc//lib/idlc/ast.rb#5297
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5294
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5285
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#5275
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5289
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5304
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ArrayLiteralAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5256
class Idl::ArrayLiteralSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5257
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1449
class Idl::ArraySizeAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # @return [ArraySizeAst] a new instance of ArraySizeAst
  #
  # source://idlc//lib/idlc/ast.rb#1458
  def initialize(input, interval, expression); end

  # source://idlc//lib/idlc/ast.rb#1456
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # @return [AstNode] Array expression
  #
  # source://idlc//lib/idlc/ast.rb#1453
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#299
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1490
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1487
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1469
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1462
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1480
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Integer) }
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1497
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1443
class Idl::ArraySizeSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1444
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#6247
module Idl::AryAccess0
  # source://idlc//lib/idlc/idl_parser.rb#6248
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#6254
module Idl::AryAccess1
  # source://idlc//lib/idlc/idl_parser.rb#6259
  def lsb; end

  # source://idlc//lib/idlc/idl_parser.rb#6255
  def msb; end
end

# source://idlc//lib/idlc/idl_parser.rb#6265
module Idl::AryAccess2
  # source://idlc//lib/idlc/idl_parser.rb#6266
  def a; end

  # source://idlc//lib/idlc/idl_parser.rb#6270
  def brackets; end
end

# this is not used as an AST node; we use it split chained array accesses
#
# For example, it helps us represent
#   X[rs1][31:0]
#
# source://idlc//lib/idlc/ast.rb#2384
class Idl::AryAccessSyntaxNode < ::Idl::SyntaxNode
  # fix up left recursion
  #
  # @return [AstNode] New tree rooted at the array access
  #
  # source://idlc//lib/idlc/ast.rb#2388
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#2404
class Idl::AryElementAccessAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # @return [AryElementAccessAst] a new instance of AryElementAccessAst
  #
  # source://idlc//lib/idlc/ast.rb#2419
  def initialize(input, interval, var, index); end

  # source://idlc//lib/idlc/ast.rb#2408
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#229
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2417
  def index; end

  # source://idlc//lib/idlc/ast.rb#2492
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#2489
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#113
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#2454
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#2424
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2469
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#2416
  def var; end

  class << self
    # source://idlc//lib/idlc/ast.rb#2500
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# represents an array element assignment
#
# for example:
#   X[rs1] = XLEN'd0
#
# source://idlc//lib/idlc/ast.rb#2807
class Idl::AryElementAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # @return [AryElementAssignmentAst] a new instance of AryElementAssignmentAst
  #
  # source://idlc//lib/idlc/ast.rb#2829
  def initialize(input, interval, lhs, idx, rhs); end

  # source://idlc//lib/idlc/ast.rb#2811
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#2868
  def execute(symtab); end

  # "execute" the statement, forcing any variable assignments to an unknown state
  # This is used down unknown conditional paths.
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#2898
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#253
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2826
  def idx; end

  # source://idlc//lib/idlc/ast.rb#2825
  def lhs; end

  # source://idlc//lib/idlc/ast.rb#2827
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#2936
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#2933
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#2834
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2945
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AryElementAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2797
class Idl::AryElementAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2798
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#2513
class Idl::AryRangeAccessAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # @return [AryRangeAccessAst] a new instance of AryRangeAccessAst
  #
  # source://idlc//lib/idlc/ast.rb#2531
  def initialize(input, interval, var, msb, lsb); end

  # source://idlc//lib/idlc/ast.rb#2517
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#168
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2529
  def lsb; end

  # source://idlc//lib/idlc/ast.rb#2528
  def msb; end

  # source://idlc//lib/idlc/ast.rb#2587
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#2584
  sig { override.returns(::String) }
  def to_idl; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#2561
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#2536
  def type_check(symtab); end

  # Return the compile-time-known value of the node
  #
  # source://idlc//lib/idlc/ast.rb#2577
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#2527
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def var; end

  class << self
    # source://idlc//lib/idlc/ast.rb#2598
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# represents an array range assignment
#
# for example:
#   vec[8:0] = 8'd0
#
# source://idlc//lib/idlc/ast.rb#2969
class Idl::AryRangeAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # @return [AryRangeAssignmentAst] a new instance of AryRangeAssignmentAst
  #
  # source://idlc//lib/idlc/ast.rb#2992
  def initialize(input, interval, variable, msb, lsb, write_value); end

  # source://idlc//lib/idlc/ast.rb#2973
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#3029
  def execute(symtab); end

  # "execute" the statement, forcing any variable assignments to an unknown state
  # This is used down unknown conditional paths.
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#3057
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#20
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2989
  def lsb; end

  # source://idlc//lib/idlc/ast.rb#2988
  def msb; end

  # source://idlc//lib/idlc/ast.rb#3024
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#3066
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#3063
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#2997
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2987
  def variable; end

  # source://idlc//lib/idlc/ast.rb#2990
  def write_value; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3078
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AryRangeAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2959
class Idl::AryRangeAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2960
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#11851
module Idl::ArySizeDecl0
  # source://idlc//lib/idlc/idl_parser.rb#11852
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#11011
module Idl::Assignment0
  # source://idlc//lib/idlc/idl_parser.rb#11012
  def var; end
end

# source://idlc//lib/idlc/idl_parser.rb#11018
module Idl::Assignment1
  # source://idlc//lib/idlc/idl_parser.rb#11019
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#11027
  def function_call; end

  # source://idlc//lib/idlc/idl_parser.rb#11023
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#11032
module Idl::Assignment2
  # source://idlc//lib/idlc/idl_parser.rb#11033
  def rval; end
end

# source://idlc//lib/idlc/idl_parser.rb#11038
module Idl::Assignment3
  # source://idlc//lib/idlc/idl_parser.rb#11043
  def rval; end

  # source://idlc//lib/idlc/idl_parser.rb#11039
  def var; end
end

# source://idlc//lib/idlc/idl_parser.rb#11048
module Idl::Assignment4
  # source://idlc//lib/idlc/idl_parser.rb#11049
  def csr_field_access_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#11053
  def rval; end
end

# source://idlc//lib/idlc/idl_parser.rb#11058
module Idl::Assignment5
  # source://idlc//lib/idlc/idl_parser.rb#11063
  def field_name; end

  # source://idlc//lib/idlc/idl_parser.rb#11059
  def id; end

  # source://idlc//lib/idlc/idl_parser.rb#11067
  def rval; end
end

# source://idlc//lib/idlc/idl_parser.rb#11072
module Idl::Assignment6
  # source://idlc//lib/idlc/idl_parser.rb#11081
  def lsb; end

  # source://idlc//lib/idlc/idl_parser.rb#11077
  def msb; end

  # source://idlc//lib/idlc/idl_parser.rb#11085
  def rval; end

  # source://idlc//lib/idlc/idl_parser.rb#11073
  def var; end
end

# source://idlc//lib/idlc/idl_parser.rb#11090
module Idl::Assignment7
  # source://idlc//lib/idlc/idl_parser.rb#11095
  def idx; end

  # source://idlc//lib/idlc/idl_parser.rb#11099
  def rval; end

  # source://idlc//lib/idlc/idl_parser.rb#11091
  def var; end
end

# set up a default
#
# source://idlc//lib/idlc/type.rb#11
class Idl::AstNode
  abstract!

  # source://idlc//lib/idlc/ast.rb#207
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      children: T::Array[::Idl::AstNode]
    ).void
  end
  def initialize(input, interval, children); end

  # source://idlc//lib/idlc/ast.rb#83
  sig { returns(T::Array[::Idl::AstNode]) }
  def children; end

  # is this node const evaluatable?
  # all nodes with a compile-time-known value are const_eval
  # not all const_eval nodes have a compile-time-known value; they may rely on an unknown parameter
  #
  # @abstract
  #
  # source://idlc//lib/idlc/ast.rb#201
  sig { abstract.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#262
  sig { params(klass: ::Class).returns(T.nilable(::Idl::AstNode)) }
  def find_ancestor(klass); end

  # freeze the entire tree from further modification
  # This is also an opportunity to pre-calculate anything that only needs global symbols
  #
  # freeze the entire tree from further modification
  # This is also an opportunity to pre-calculate anything that only needs global symbols
  #
  # source://idlc//lib/idlc/ast.rb#439
  sig { params(global_symtab: ::Idl::SymbolTable).returns(::Idl::AstNode) }
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#10
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # Generates asciidoc to document an implementation option.
  #
  # The result is *not* IDL code, but pretty-ified Asciidoc for document layout
  #
  # @return [String] Asciidoc source
  #
  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#16
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#64
  sig { returns(T.nilable(::String)) }
  def input; end

  # source://idlc//lib/idlc/ast.rb#56
  sig { returns(T.nilable(::Pathname)) }
  def input_file; end

  # source://idlc//lib/idlc/ast.rb#590
  sig { returns(::String) }
  def inspect; end

  # raise an internal error
  #
  # @raise [AstNode::TypeError] always
  #
  # source://idlc//lib/idlc/ast.rb#373
  sig { params(reason: ::String).returns(T.noreturn) }
  def internal_error(reason); end

  # source://idlc//lib/idlc/ast.rb#68
  sig { returns(T.nilable(T::Range[::Integer])) }
  def interval; end

  # source://idlc//lib/idlc/ast.rb#255
  sig { returns(::Integer) }
  def lineno; end

  # source://idlc//lib/idlc/ast.rb#280
  sig { returns(::Idl::AstNode::LinesDescriptor) }
  def lines_around; end

  # source://idlc//lib/idlc/passes/prune.rb#64
  def nullify_assignments(symtab); end

  # source://idlc//lib/idlc/ast.rb#79
  sig { returns(T.nilable(::Idl::AstNode)) }
  def parent; end

  # source://idlc//lib/idlc/passes/find_return_values.rb#11
  def pass_find_return_values(values, current_conditions); end

  # source://idlc//lib/idlc/ast.rb#448
  sig { returns(::String) }
  def path; end

  # pretty print the AST rooted at this node
  #
  # source://idlc//lib/idlc/ast.rb#422
  sig { params(indent: ::Integer, indent_size: ::Integer, io: ::IO).void }
  def print_ast(indent = T.unsafe(nil), indent_size: T.unsafe(nil), io: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#45
  def prune(symtab); end

  # @return [Array<FunctionBodyAst>] List of all functions that can be reached (via function calls) from this node
  #
  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#13
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # @return [Array<FunctionDefAst>] List of all functions that can be reached (via function calls) from this node
  #
  # source://idlc//lib/idlc/passes/reachable_functions.rb#12
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # remember where the code comes from
  #
  # source://idlc//lib/idlc/ast.rb#244
  sig { params(filename: T.any(::Pathname, ::String), starting_line: ::Integer).void }
  def set_input_file(filename, starting_line = T.unsafe(nil)); end

  # Sets the input file for this syntax node unless it has already been set.
  #
  # If the input file has not been set, it will be set with the given filename and starting line number.
  #
  # source://idlc//lib/idlc/ast.rb#228
  sig { params(filename: T.any(::Pathname, ::String), starting_line: ::Integer).void }
  def set_input_file_unless_already_set(filename, starting_line = T.unsafe(nil)); end

  # return yaml to indicate where the node comes from
  #
  # source://idlc//lib/idlc/ast.rb#487
  sig { returns(T::Hash[::String, T.untyped]) }
  def source_yaml; end

  # source://idlc//lib/idlc/ast.rb#60
  sig { returns(::Integer) }
  def starting_line; end

  # source://idlc//lib/idlc/ast.rb#72
  sig { returns(::String) }
  def text_value; end

  # @abstract
  #
  # source://idlc//lib/idlc/ast.rb#507
  sig { abstract.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # @abstract
  #
  # source://idlc//lib/idlc/ast.rb#480
  sig { abstract.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#483
  sig { overridable.returns(::String) }
  def to_idl_verbose; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#18
  sig { overridable.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#308
  sig { params(reason: ::String).void }
  def truncation_warn(reason); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @abstract
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  #
  # source://idlc//lib/idlc/ast.rb#470
  sig { abstract.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # raise a type error
  #
  # @raise [AstNode::TypeError] always
  #
  # source://idlc//lib/idlc/ast.rb#324
  sig { params(reason: ::String).returns(T.noreturn) }
  def type_error(reason); end

  # unindent a multiline string, getting rid of all common leading whitespace (like <<~ heredocs)
  #
  # borrowed from https://stackoverflow.com/questions/33527064/multiline-strings-with-no-indent
  #
  # source://idlc//lib/idlc/ast.rb#412
  sig { params(s: ::String).returns(::String) }
  def unindent(s); end

  # source://idlc//lib/idlc/ast.rb#195
  sig { params(value_result: T.untyped, block: T.proc.returns(T.untyped)).returns(T.untyped) }
  def value_else(value_result, &block); end

  # raise AstNode::ValueError.new(lineno, input_file, reason), reason, []
  #
  # source://idlc//lib/idlc/ast.rb#403
  sig { params(reason: ::String).returns(T.noreturn) }
  def value_error(reason); end

  # source://idlc//lib/idlc/ast.rb#185
  sig { params(block: T.proc.params(arg0: ::Object).returns(T.untyped)).returns(T.untyped) }
  def value_try(&block); end

  class << self
    # source://idlc//lib/idlc/ast.rb#510
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end

    # source://idlc//lib/idlc/ast.rb#496
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(T.nilable(::String))
    end
    def input_from_source_yaml(yaml, source_mapper); end

    # source://idlc//lib/idlc/ast.rb#502
    sig { params(yaml: T::Hash[::String, T.untyped]).returns(T.nilable(T::Range[::Integer])) }
    def interval_from_source_yaml(yaml); end

    # source://idlc//lib/idlc/ast.rb#188
    sig { params(value_result: T.untyped, _block: T.proc.returns(T.untyped)).returns(T.untyped) }
    def value_else(value_result, &_block); end

    # raise a value error, indicating that the value is not known at compile time
    #
    # @raise [AstNode::ValueError] always
    #
    # source://idlc//lib/idlc/ast.rb#394
    sig { params(reason: ::String, ast: T.nilable(::Idl::AstNode)).returns(T.noreturn) }
    def value_error(reason, ast = T.unsafe(nil)); end

    # Returns the value of attribute value_error_ast.
    #
    # source://idlc//lib/idlc/ast.rb#386
    def value_error_ast; end

    # Sets the attribute value_error_ast
    #
    # @param value the value to set the attribute value_error_ast to.
    #
    # source://idlc//lib/idlc/ast.rb#386
    def value_error_ast=(_arg0); end

    # Returns the value of attribute value_error_reason.
    #
    # source://idlc//lib/idlc/ast.rb#386
    def value_error_reason; end

    # Sets the attribute value_error_reason
    #
    # @param value the value to set the attribute value_error_reason to.
    #
    # source://idlc//lib/idlc/ast.rb#386
    def value_error_reason=(_arg0); end

    # source://idlc//lib/idlc/ast.rb#181
    sig { params(block: T.proc.params(arg0: ::Object).returns(T.untyped)).returns(T.untyped) }
    def value_try(&block); end
  end
end

# source://idlc//lib/idlc/ast.rb#43
Idl::AstNode::Bits1Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#45
Idl::AstNode::Bits32Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#47
Idl::AstNode::Bits64Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#50
Idl::AstNode::BoolType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#49
Idl::AstNode::ConstBoolType = T.let(T.unsafe(nil), Idl::Type)

# error that is thrown when the compiler hits an unrecoverable error (that needs fixed!)
#
# source://idlc//lib/idlc/ast.rb#116
class Idl::AstNode::InternalError < ::StandardError
  # source://idlc//lib/idlc/ast.rb#132
  sig { params(what: ::String).void }
  def initialize(what); end

  # The backtrace starting from the 'internal_error' call site
  #
  # Note, this will be different (truncated) from #backtrace
  #
  # source://idlc//lib/idlc/ast.rb#129
  sig { returns(T::Array[::String]) }
  def bt; end

  # source://idlc//lib/idlc/ast.rb#121
  sig { returns(::String) }
  def what; end
end

# source://idlc//lib/idlc/ast.rb#272
class Idl::AstNode::LinesDescriptor < ::T::Struct
  const :lines, ::String
  const :problem_interval, T::Range[T.untyped]
  const :lines_interval, T::Range[T.untyped]

  class << self
    # source://sorbet-runtime/0.6.12690/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://idlc//lib/idlc/ast.rb#44
Idl::AstNode::PossiblyUnknownBits1Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#46
Idl::AstNode::PossiblyUnknownBits32Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#48
Idl::AstNode::PossiblyUnknownBits64Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#52
Idl::AstNode::StringType = T.let(T.unsafe(nil), Idl::Type)

# error that is thrown when compilation reveals a type error
#
# source://idlc//lib/idlc/ast.rb#86
class Idl::AstNode::TypeError < ::StandardError
  # source://idlc//lib/idlc/ast.rb#103
  sig { params(what: ::String).void }
  def initialize(what); end

  # The backtrace starting from the 'type_error' call site
  #
  # Note, this will be different (truncated) from #backtrace
  #
  # source://idlc//lib/idlc/ast.rb#99
  sig { returns(T::Array[::String]) }
  def bt; end

  # source://idlc//lib/idlc/ast.rb#91
  sig { returns(::String) }
  def what; end
end

# exception type raised when the value of IDL code is requested (via node.value(...)) but
# cannot be provided because some part the code isn't known at compile time
#
# source://idlc//lib/idlc/ast.rb#146
class Idl::AstNode::ValueError < ::StandardError
  # source://idlc//lib/idlc/ast.rb#159
  sig { params(lineno: ::Integer, file: ::String, reason: ::String).void }
  def initialize(lineno, file, reason); end

  # source://idlc//lib/idlc/ast.rb#153
  sig { returns(::String) }
  def file; end

  # source://idlc//lib/idlc/ast.rb#150
  sig { returns(::Integer) }
  def lineno; end

  # source://idlc//lib/idlc/ast.rb#170
  sig { returns(::String) }
  def message; end

  # source://idlc//lib/idlc/ast.rb#156
  sig { returns(::String) }
  def reason; end

  # source://idlc//lib/idlc/ast.rb#167
  sig { returns(::String) }
  def what; end
end

# source://idlc//lib/idlc/ast.rb#51
Idl::AstNode::VoidType = T.let(T.unsafe(nil), Idl::Type)

# type, from ruby's perspective, of any IDL value
#
# source://idlc//lib/idlc/ast.rb#16
Idl::BasicValueRbType = T.type_alias { T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean) }

# source://idlc//lib/idlc/ast.rb#4395
class Idl::BinaryExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # create a new, left-recursion-fixed, binary expression
  #
  # @return [BinaryExpressionAst] a new instance of BinaryExpressionAst
  #
  # source://idlc//lib/idlc/ast.rb#4414
  def initialize(input, interval, lhs, op, rhs); end

  # @param value [Integer] the value
  # @param signed [Boolean] if true, return the number of bits needed if the value is a signed type
  # @return [Integer] the number of bits needed to represent value in two's complement
  #
  # source://idlc//lib/idlc/ast.rb#4684
  def bits_needed(value, signed); end

  # source://idlc//lib/idlc/ast.rb#4404
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#235
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # @return [BinaryExpressionAst] this expression, but with an inverted condition
  #
  # source://idlc//lib/idlc/ast.rb#4421
  def invert(symtab); end

  # source://idlc//lib/idlc/ast.rb#4410
  def lhs; end

  # source://idlc//lib/idlc/ast.rb#4711
  def max_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#4854
  def min_value(symtab); end

  # returns the operator as a string
  #
  # source://idlc//lib/idlc/ast.rb#5198
  def op; end

  # source://idlc//lib/idlc/passes/prune.rb#239
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#4411
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#4457
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#4452
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#201
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#4480
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#4580
  def type_check(symtab); end

  # Return the compile-time-known value of the node
  #
  # source://idlc//lib/idlc/ast.rb#5004
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4466
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::BinaryExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4400
Idl::BinaryExpressionAst::ARITH_OPS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#4399
Idl::BinaryExpressionAst::BIT_OPS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#4398
Idl::BinaryExpressionAst::LOGICAL_OPS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#4401
Idl::BinaryExpressionAst::OPS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#3940
class Idl::BinaryExpressionRightSyntaxNode < ::Idl::SyntaxNode
  # fix up left recursion
  # i.e., xlen() - 1 - i => (xlen() - 1) - i
  #
  # source://idlc//lib/idlc/ast.rb#3944
  def to_ast; end

  # source://idlc//lib/idlc/ast.rb#3961
  def type_check(_symtab); end
end

# source://idlc//lib/idlc/idl_parser.rb#847
module Idl::BitfieldDefinition0
  # source://idlc//lib/idlc/idl_parser.rb#848
  def int; end
end

# source://idlc//lib/idlc/idl_parser.rb#853
module Idl::BitfieldDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#854
  def int; end

  # source://idlc//lib/idlc/idl_parser.rb#858
  def lsb; end
end

# source://idlc//lib/idlc/idl_parser.rb#863
module Idl::BitfieldDefinition2
  # source://idlc//lib/idlc/idl_parser.rb#864
  def field_name; end

  # source://idlc//lib/idlc/idl_parser.rb#868
  def range; end
end

# source://idlc//lib/idlc/idl_parser.rb#874
module Idl::BitfieldDefinition3
  # source://idlc//lib/idlc/idl_parser.rb#883
  def e; end

  # source://idlc//lib/idlc/idl_parser.rb#875
  def int; end

  # source://idlc//lib/idlc/idl_parser.rb#879
  def user_type_name; end
end

# represents a bitfield definition
#
#  # this will result in a BitfieldDefinitionAst
#  bitfield (64) Sv39PageTableEntry {
#    N 63
#    PBMT 62-61
#    Reserved 60-54
#    PPN2 53-28
#    PPN1 27-19
#    PPN0 18-10
#    PPN 53-10 # in addition to the components, we define the entire PPN
#    RSW  9-8
#    D 7
#    A 6
#    G 5
#    U 4
#    X 3
#    W 2
#    R 1
#    V 0
#  }
#
# source://idlc//lib/idlc/ast.rb#2116
class Idl::BitfieldDefinitionAst < ::Idl::AstNode
  include ::Idl::Declaration

  # @return [BitfieldDefinitionAst] a new instance of BitfieldDefinitionAst
  #
  # source://idlc//lib/idlc/ast.rb#2122
  def initialize(input, interval, name, size, fields); end

  # source://idlc//lib/idlc/ast.rb#2175
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#2120
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # @return [Array<String>] Array of all element names, in the same order as those from {#element_ranges}
  #
  # source://idlc//lib/idlc/ast.rb#2147
  def element_names; end

  # @return [Array<Range>] Array of all element ranges, in the same order as those from {#element_names}.
  #
  # source://idlc//lib/idlc/ast.rb#2155
  def element_ranges(symtab); end

  # freeze the entire tree from further modification
  # This is also an opportunity to pre-calculate anything that only needs global symbols
  #
  # @param global_symtab [SymbolTable] Symbol table with global scope populated
  #
  # source://idlc//lib/idlc/ast.rb#2131
  def freeze_tree(global_symtab); end

  # @return [String] bitfield name
  #
  # source://idlc//lib/idlc/ast.rb#2197
  def name; end

  # @return [Integer] The number of bits in the Bitfield
  #
  # source://idlc//lib/idlc/ast.rb#2142
  def size(symtab); end

  # source://idlc//lib/idlc/ast.rb#2214
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#2204
  sig { override.returns(::String) }
  def to_idl; end

  # Return the type of this node
  #
  # @param _symtab [SymbolTable] Not used
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#2185
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#2162
  def type_check(symtab); end

  # Return the compile-time-known value of the node
  #
  # @param _symtab [SymbolTable] Not used
  # @raise [AstNode::ValueError] if the value is not knowable at compile time
  # @return [Integer] if the compile-time-known value is an integer
  # @return [Boolean] if the compile-time-known value is a boolean
  #
  # source://idlc//lib/idlc/ast.rb#2200
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2223
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2085
class Idl::BitfieldDefinitionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2086
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#2000
class Idl::BitfieldFieldDefinitionAst < ::Idl::AstNode
  # @return [BitfieldFieldDefinitionAst] a new instance of BitfieldFieldDefinitionAst
  #
  # source://idlc//lib/idlc/ast.rb#2007
  def initialize(input, interval, name, msb, lsb); end

  # source://idlc//lib/idlc/ast.rb#2005
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # @return [String] The field name
  #
  # source://idlc//lib/idlc/ast.rb#2002
  def name; end

  # @return Range The field's location in the bitfield
  #
  # source://idlc//lib/idlc/ast.rb#2042
  def range(symtab); end

  # source://idlc//lib/idlc/ast.rb#2060
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2051
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#2020
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2071
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/type.rb#711
class Idl::BitfieldType < ::Idl::Type
  # @return [BitfieldType] a new instance of BitfieldType
  #
  # source://idlc//lib/idlc/type.rb#712
  def initialize(type_name, width, field_names, field_ranges); end

  # source://idlc//lib/idlc/type.rb#732
  def clone; end

  # source://idlc//lib/idlc/type.rb#728
  def field_names; end

  # source://idlc//lib/idlc/type.rb#721
  def range(field_name); end
end

# pre-define some common types
#
# source://idlc//lib/idlc/type.rb#996
Idl::Bits1Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/type.rb#997
Idl::Bits32Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/type.rb#998
Idl::Bits64Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/idl_parser.rb#6569
module Idl::BitsCast0
  # source://idlc//lib/idlc/idl_parser.rb#6570
  def expr; end
end

# Node for a cast to a Bits<N> type
#
# This will result in a BitsCaseAst:
#
#   $bits(ExceptionCode::LoadAccessFault)
#
# source://idlc//lib/idlc/ast.rb#4306
class Idl::BitsCastAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # @return [BitsCastAst] a new instance of BitsCastAst
  #
  # source://idlc//lib/idlc/ast.rb#4317
  def initialize(input, interval, exp); end

  # source://idlc//lib/idlc/ast.rb#4310
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # @return [AstNode] The casted expression
  #
  # source://idlc//lib/idlc/ast.rb#4315
  def expr; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#102
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#506
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#4376
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#4373
  sig { override.returns(::String) }
  def to_idl; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#4329
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#4320
  def type_check(symtab); end

  # Return the compile-time-known value of the node
  #
  # source://idlc//lib/idlc/ast.rb#4350
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4383
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::BitsCastAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4295
class Idl::BitsCastSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4296
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#999
Idl::BitsUnknownType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/idl_parser.rb#9522
module Idl::BodyFunctionDefinition0; end

# source://idlc//lib/idlc/idl_parser.rb#9525
module Idl::BodyFunctionDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#9526
  def single_declaration; end
end

# source://idlc//lib/idlc/idl_parser.rb#9531
module Idl::BodyFunctionDefinition2
  # source://idlc//lib/idlc/idl_parser.rb#9532
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#9536
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#9542
module Idl::BodyFunctionDefinition3
  # source://idlc//lib/idlc/idl_parser.rb#9543
  def type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#9548
module Idl::BodyFunctionDefinition4
  # source://idlc//lib/idlc/idl_parser.rb#9549
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#9553
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#9559
module Idl::BodyFunctionDefinition5
  # source://idlc//lib/idlc/idl_parser.rb#9560
  def single_declaration; end
end

# source://idlc//lib/idlc/idl_parser.rb#9565
module Idl::BodyFunctionDefinition6
  # source://idlc//lib/idlc/idl_parser.rb#9566
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#9570
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#9576
module Idl::BodyFunctionDefinition7
  # source://idlc//lib/idlc/idl_parser.rb#9577
  def function_body; end
end

# source://idlc//lib/idlc/idl_parser.rb#9583
module Idl::BodyFunctionDefinition8
  # source://idlc//lib/idlc/idl_parser.rb#9600
  def args; end

  # source://idlc//lib/idlc/idl_parser.rb#9608
  def body_block; end

  # source://idlc//lib/idlc/idl_parser.rb#9604
  def desc; end

  # source://idlc//lib/idlc/idl_parser.rb#9588
  def function_name; end

  # source://idlc//lib/idlc/idl_parser.rb#9596
  def ret; end

  # source://idlc//lib/idlc/idl_parser.rb#9592
  def targs; end

  # source://idlc//lib/idlc/idl_parser.rb#9584
  def type; end
end

# source://idlc//lib/idlc/type.rb#1002
Idl::BoolType = T.let(T.unsafe(nil), Idl::Type)

# represents a builtin (auto-generated from config) enum definition
#
#   # this will result in a BuiltinEnumDefinitionAst
#   generated enum ExtensionName
#
# source://idlc//lib/idlc/ast.rb#1935
class Idl::BuiltinEnumDefinitionAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#1942
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      user_type: ::Idl::UserTypeNameAst
    ).void
  end
  def initialize(input, interval, user_type); end

  # source://idlc//lib/idlc/ast.rb#1969
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#1939
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1955
  def element_names(symtab); end

  # source://idlc//lib/idlc/ast.rb#1959
  def element_values(symtab); end

  # @return [String] name of the enum class
  #
  # source://idlc//lib/idlc/ast.rb#1974
  def name; end

  # source://idlc//lib/idlc/ast.rb#1981
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#1978
  sig { override.returns(::String) }
  def to_idl; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#1964
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1948
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1988
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1924
class Idl::BuiltinEnumDefinitionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1925
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#10331
module Idl::BuiltinFunctionDefinition0
  # source://idlc//lib/idlc/idl_parser.rb#10332
  def first; end
end

# source://idlc//lib/idlc/idl_parser.rb#10338
module Idl::BuiltinFunctionDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#10339
  def single_declaration; end
end

# source://idlc//lib/idlc/idl_parser.rb#10344
module Idl::BuiltinFunctionDefinition2
  # source://idlc//lib/idlc/idl_parser.rb#10345
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#10349
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#10355
module Idl::BuiltinFunctionDefinition3
  # source://idlc//lib/idlc/idl_parser.rb#10368
  def args; end

  # source://idlc//lib/idlc/idl_parser.rb#10372
  def desc; end

  # source://idlc//lib/idlc/idl_parser.rb#10360
  def function_name; end

  # source://idlc//lib/idlc/idl_parser.rb#10364
  def ret; end

  # source://idlc//lib/idlc/idl_parser.rb#10356
  def type; end
end

# source://idlc//lib/idlc/idl_parser.rb#14689
module Idl::BuiltinTypeName0; end

# source://idlc//lib/idlc/idl_parser.rb#14692
module Idl::BuiltinTypeName1
  # source://idlc//lib/idlc/idl_parser.rb#14693
  def i; end
end

# source://idlc//lib/idlc/idl_parser.rb#14699
module Idl::BuiltinTypeName2; end

# source://idlc//lib/idlc/idl_parser.rb#14702
module Idl::BuiltinTypeName3; end

# source://idlc//lib/idlc/idl_parser.rb#14705
module Idl::BuiltinTypeName4; end

# source://idlc//lib/idlc/idl_parser.rb#14708
module Idl::BuiltinTypeName5; end

# represents a type name of one of the builtin types:
#
#  * Bits<N>
#  * Boolean
#  * String
#
# And their aliases:
#
#  * XReg (Bits<XLEN>)
#  * U32 (Bits<32>)
#  * U64 (Bits<64>)
#
# source://idlc//lib/idlc/ast.rb#6871
class Idl::BuiltinTypeNameAst < ::Idl::AstNode
  # @return [BuiltinTypeNameAst] a new instance of BuiltinTypeNameAst
  #
  # source://idlc//lib/idlc/ast.rb#6878
  def initialize(input, interval, type_name, bits_expression); end

  # source://idlc//lib/idlc/ast.rb#6876
  def bits_expression; end

  # source://idlc//lib/idlc/ast.rb#6874
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6905
  def freeze_tree(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#192
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6967
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#6958
  sig { override.returns(::String) }
  def to_idl; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  #
  # source://idlc//lib/idlc/ast.rb#6924
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#6888
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6984
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::BuiltinTypeNameAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# @api private
#
# source://idlc//lib/idlc/ast.rb#6850
class Idl::BuiltinTypeNameSyntaxNode < ::Idl::SyntaxNode
  # @api private
  #
  # source://idlc//lib/idlc/ast.rb#6851
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#5578
class Idl::BuiltinVariableAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5597
  sig { params(input: T.nilable(::String), interval: T.nilable(T::Range[::Integer]), name: ::String).void }
  def initialize(input, interval, name); end

  # source://idlc//lib/idlc/ast.rb#5582
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#213
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5593
  def name; end

  # source://idlc//lib/idlc/ast.rb#5594
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#5629
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5626
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5606
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5602
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5621
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5636
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::BuiltinVariableAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5648
class Idl::BuiltinVariableSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5649
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#15950
module Idl::Comment0; end

# source://idlc//lib/idlc/idl_parser.rb#15953
module Idl::Comment1
  # source://idlc//lib/idlc/idl_parser.rb#15954
  def content; end
end

# represents a comment
#
# source://idlc//lib/idlc/ast.rb#6808
class Idl::CommentAst < ::Idl::AstNode
  # @return [CommentAst] a new instance of CommentAst
  #
  # source://idlc//lib/idlc/ast.rb#6812
  def initialize(input, interval, text); end

  # source://idlc//lib/idlc/ast.rb#6810
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # @example
  #   # This is a comment     #=> "This is a comment"
  # @return [String] The comment text, with the leading hash and any leading space removed
  #
  # source://idlc//lib/idlc/ast.rb#6825
  def content; end

  # source://idlc//lib/idlc/ast.rb#6817
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#6831
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6828
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#6820
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6838
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CommentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# @api private
#
# source://idlc//lib/idlc/ast.rb#6803
class Idl::CommentSyntaxNode < ::Idl::SyntaxNode
  # @api private
  #
  # source://idlc//lib/idlc/ast.rb#6804
  def to_ast; end
end

# the Idl compiler
#
# source://idlc//lib/idlc.rb#63
class Idl::Compiler
  # @return [Compiler] a new instance of Compiler
  #
  # source://idlc//lib/idlc.rb#68
  def initialize; end

  # source://idlc//lib/idlc.rb#376
  sig { params(body: ::String, symtab: ::Idl::SymbolTable, pass_error: T::Boolean).returns(::Idl::ConstraintBodyAst) }
  def compile_constraint(body, symtab, pass_error: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#332
  def compile_expression(expression, symtab, pass_error: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#84
  def compile_file(path, source_mapper = T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#151
  sig { params(loop: ::String, symtab: ::Idl::SymbolTable, pass_error: T::Boolean).returns(::Idl::ForLoopAst) }
  def compile_for_loop(loop, symtab, pass_error: T.unsafe(nil)); end

  # compile a function body, and return the abstract syntax tree
  #
  # @param body [String] Function body source code
  # @param return_type [Type] Expected return type, if known
  # @param symtab [SymbolTable] Symbol table to use for type checking
  # @param name [String] Function name, used for error messages
  # @param input_file [Pathname] Path to the input file this source comes from
  # @param input_line [Integer] Starting line in the input file that this source comes from
  # @param no_rescue [Boolean] Whether or not to automatically catch any errors
  # @return [Ast] The root of the abstract syntax tree
  #
  # source://idlc//lib/idlc.rb#204
  def compile_func_body(body, return_type: T.unsafe(nil), symtab: T.unsafe(nil), name: T.unsafe(nil), input_file: T.unsafe(nil), input_line: T.unsafe(nil), no_rescue: T.unsafe(nil), extra_syms: T.unsafe(nil), type_check: T.unsafe(nil)); end

  # compile an instruction operation, and return the abstract syntax tree
  #
  # @param inst [Instruction] Instruction object
  # @param symtab [SymbolTable] Symbol table
  # @param input_file [Pathname] Path to the input file this source comes from
  # @param input_line [Integer] Starting line in the input file that this source comes from
  # @return [Ast] The root of the abstract syntax tree
  #
  # source://idlc//lib/idlc.rb#293
  def compile_inst_operation(inst, symtab:, input_file: T.unsafe(nil), input_line: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#266
  def compile_inst_scope(idl, symtab:, input_file:, input_line: T.unsafe(nil)); end

  # Returns the value of attribute parser.
  #
  # source://idlc//lib/idlc.rb#66
  def parser; end

  # set a progressbar
  #
  # source://idlc//lib/idlc.rb#73
  def pb=(pb); end

  # Type check an abstract syntax tree
  #
  # @param ast [AstNode] An abstract syntax tree
  # @param symtab [SymbolTable] The compilation context
  # @param what [String] A description of what you are type checking (for error messages)
  # @raise AstNode::TypeError if a type error is found
  #
  # source://idlc//lib/idlc.rb#304
  def type_check(ast, symtab, what); end

  # unset a progressbar
  #
  # source://idlc//lib/idlc.rb#79
  def unset_pb; end

  class << self
    # source://idlc//lib/idlc/version.rb#8
    def version; end
  end
end

# source://idlc//lib/idlc/idl_parser.rb#5730
module Idl::ConcatenationExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5731
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#5736
module Idl::ConcatenationExpression1
  # source://idlc//lib/idlc/idl_parser.rb#5737
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#5741
  def rest; end
end

# represents a concatenation expression
#
# for example:
#   {1'b0, 5'd3}
#
# source://idlc//lib/idlc/ast.rb#5326
class Idl::ConcatenationExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5330
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5332
  def expressions; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#97
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5398
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#5395
  sig { override.returns(::String) }
  def to_idl; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#5348
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#5335
  def type_check(symtab); end

  # Return the compile-time-known value of the node
  #
  # source://idlc//lib/idlc/ast.rb#5383
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5405
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ConcatenationExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5316
class Idl::ConcatenationExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5317
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#6723
class Idl::ConditionalReturnStatementAst < ::Idl::AstNode
  include ::Idl::Returns

  # @return [ConditionalReturnStatementAst] a new instance of ConditionalReturnStatementAst
  #
  # source://idlc//lib/idlc/ast.rb#6732
  def initialize(input, interval, return_expression, condition); end

  # source://idlc//lib/idlc/ast.rb#6730
  def condition; end

  # source://idlc//lib/idlc/ast.rb#6727
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#25
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#413
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#150
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#137
  def reachable_functions(symtab, cache); end

  # source://idlc//lib/idlc/ast.rb#6729
  def return_expression; end

  # @return [Type] The actual return type
  #
  # source://idlc//lib/idlc/ast.rb#6744
  def return_type(symtab); end

  # @return [Array<Type>] List of actual return types
  #
  # source://idlc//lib/idlc/ast.rb#6749
  def return_types(symtab); end

  # Evaluate the compile-time return value of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on the taken path), execute the node
  # and update the symtab
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  # @return [Integer] The return value, if it is integral
  # @return [Boolean] The return value, if it is boolean
  # @return [nil] if the return value is not compile-time-known
  #
  # source://idlc//lib/idlc/ast.rb#6755
  def return_value(symtab); end

  # Evaluate all possible compile-time return values of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on a possible path), execute the node
  # and update the symtab
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  # @return [Array<Integer>] The possible return values. Will be an empty array if there are no return values
  # @return [Array<Boolean>] The possible return values. Will be an empty array if there are no return values
  #
  # source://idlc//lib/idlc/ast.rb#6764
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#6781
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6778
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#6737
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6789
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ConditionalReturnStatementAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6717
class Idl::ConditionalReturnStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6718
  def to_ast; end
end

# represents a predicated simple statement
#
# for example:
#   a = 2 if condition;
#
# source://idlc//lib/idlc/ast.rb#6332
class Idl::ConditionalStatementAst < ::Idl::AstNode
  # @return [ConditionalStatementAst] a new instance of ConditionalStatementAst
  #
  # source://idlc//lib/idlc/ast.rb#6339
  def initialize(input, interval, action, condition); end

  # source://idlc//lib/idlc/ast.rb#6333
  def action; end

  # source://idlc//lib/idlc/ast.rb#6334
  def condition; end

  # source://idlc//lib/idlc/ast.rb#6337
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#6353
  def execute(symtab); end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#6369
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#283
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#428
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#166
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#154
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6380
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#6375
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#6344
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6388
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ConditionalStatementAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6322
class Idl::ConditionalStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6323
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#1000
Idl::ConstBitsUnknownType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/type.rb#1001
Idl::ConstBoolType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/idl_parser.rb#8601
module Idl::ConstraintBody0
  # source://idlc//lib/idlc/idl_parser.rb#8602
  def i; end
end

# source://idlc//lib/idlc/idl_parser.rb#8608
module Idl::ConstraintBody1
  # source://idlc//lib/idlc/idl_parser.rb#8609
  def b; end
end

# source://idlc//lib/idlc/ast.rb#4109
class Idl::ConstraintBodyAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#4117
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      stmts: T::Array[T.any(::Idl::ForLoopAst, ::Idl::ImplicationStatementAst)]
    ).void
  end
  def initialize(input, interval, stmts); end

  # source://idlc//lib/idlc/ast.rb#4122
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4135
  sig { params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def satisfied?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4125
  sig { returns(T::Array[T.any(::Idl::ForLoopAst, ::Idl::ImplicationStatementAst)]) }
  def stmts; end

  # source://idlc//lib/idlc/ast.rb#4147
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4142
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#53
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#4128
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4154
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ConstraintBodyAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4098
class Idl::ConstraintBodySyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4100
  sig { override.returns(::Idl::ConstraintBodyAst) }
  def to_ast; end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://idlc//lib/idlc/interfaces.rb#119
module Idl::Csr
  interface!

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#134
  sig { abstract.returns(T::Boolean) }
  def dynamic_length?; end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#137
  sig { abstract.returns(T::Array[::Idl::CsrField]) }
  def fields; end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#128
  sig { abstract.params(base: T.nilable(::Integer)).returns(T.nilable(::Integer)) }
  def length(base); end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#131
  sig { abstract.returns(::Integer) }
  def max_length; end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#125
  sig { abstract.returns(::String) }
  def name; end

  # If the entire CSR is read-only with a known reset value, returns the value
  # otherwise, returns nil
  #
  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#142
  sig { abstract.returns(T.nilable(::Integer)) }
  def value; end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://idlc//lib/idlc/interfaces.rb#73
module Idl::CsrField
  interface!

  # whether or not this field is defined only in RV32
  #
  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#97
  sig { abstract.returns(T::Boolean) }
  def base32_only?; end

  # whether or not this field is defined only in RV64
  #
  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#93
  sig { abstract.returns(T::Boolean) }
  def base64_only?; end

  # whether or not this field is defined in both RV32 and RV64
  #
  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#83
  sig { abstract.returns(T::Boolean) }
  def defined_in_all_bases?; end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#86
  sig { abstract.returns(T::Boolean) }
  def defined_in_base32?; end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#89
  sig { abstract.returns(T::Boolean) }
  def defined_in_base64?; end

  # whether or not the field is supposed to exist/be implemented in the
  # execution context
  #
  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#113
  sig { abstract.returns(T::Boolean) }
  def exists?; end

  # returns the location of the field in the CSR.
  # base is required when the field moves locations between RV32 and RV64
  #
  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#102
  sig { abstract.params(base: T.nilable(::Integer)).returns(T::Range[::Integer]) }
  def location(base); end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#79
  sig { abstract.returns(::String) }
  def name; end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#116
  sig do
    abstract
      .returns(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)]))
  end
  def reset_value; end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#108
  sig { abstract.params(base: T.nilable(::Integer)).returns(T.nilable(::String)) }
  def type(base); end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#105
  sig { abstract.params(base: T.nilable(::Integer)).returns(::Integer) }
  def width(base); end
end

# source://idlc//lib/idlc/idl_parser.rb#5878
module Idl::CsrFieldAccessExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5879
  def csr; end

  # source://idlc//lib/idlc/idl_parser.rb#5883
  def csr_field_name; end
end

# source://idlc//lib/idlc/ast.rb#3240
class Idl::CsrFieldAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#3250
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      csr_field: ::Idl::CsrFieldReadExpressionAst,
      write_value: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, csr_field, write_value); end

  # source://idlc//lib/idlc/ast.rb#3244
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3246
  def csr_field; end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#3271
  def execute(symtab); end

  # "execute" the statement, forcing any variable assignments to an unknown state
  # This is used down unknown conditional paths.
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#3276
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#3259
  def field(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#112
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#476
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#3282
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#3279
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#3255
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#3263
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#3247
  def write_value; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3290
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrFieldAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3234
class Idl::CsrFieldAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3235
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16453
module Idl::CsrFieldName0; end

# source://idlc//lib/idlc/ast.rb#9279
class Idl::CsrFieldReadExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#9293
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      csr: ::Idl::CsrReadExpressionAst,
      field_name: ::String
    ).void
  end
  def initialize(input, interval, csr, field_name); end

  # @api private
  #
  # source://idlc//lib/idlc/ast.rb#9374
  sig { params(symtab: ::Idl::SymbolTable).returns(T.nilable(::Idl::Type)) }
  def calc_type(symtab); end

  # @api private
  #
  # source://idlc//lib/idlc/ast.rb#9407
  sig { params(symtab: ::Idl::SymbolTable).void }
  def calc_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#9290
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9322
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Csr) }
  def csr_def(symtab); end

  # source://idlc//lib/idlc/ast.rb#9327
  sig { returns(::String) }
  def csr_name; end

  # source://idlc//lib/idlc/ast.rb#9302
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Csr) }
  def csr_obj(symtab); end

  # source://idlc//lib/idlc/ast.rb#9330
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::CsrField) }
  def field_def(symtab); end

  # source://idlc//lib/idlc/ast.rb#9335
  sig { params(symtab: ::Idl::SymbolTable).returns(::String) }
  def field_name(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#317
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#482
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#9346
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#9341
  sig { override.returns(::String) }
  def to_idl; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  #
  # source://idlc//lib/idlc/ast.rb#9368
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  #
  # source://idlc//lib/idlc/ast.rb#9314
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # Return the compile-time-known value of the node
  # Return the compile-time-known value of the node
  #
  # source://idlc//lib/idlc/ast.rb#9394
  sig do
    override
      .params(
        symtab: ::Idl::SymbolTable
      ).returns(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)]))
  end
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9354
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrFieldReadExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#9282
class Idl::CsrFieldReadExpressionAst::MemoizedState < ::T::Struct
  prop :csr, T.nilable(::Idl::Csr)
  prop :type, T.nilable(::Idl::Type)
  prop :value_calculated, T::Boolean
  prop :value, T.nilable(::Integer)

  class << self
    # source://sorbet-runtime/0.6.12690/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://idlc//lib/idlc/ast.rb#9434
class Idl::CsrFieldReadExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#9435
  def to_ast; end
end

# represents a function call for a CSR register
# for example:
#
#   CSR[mstatus].address()
#   CSR[mtval].sw_read()
#
# source://idlc//lib/idlc/ast.rb#9602
class Idl::CsrFunctionCallAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # @return [CsrFunctionCallAst] a new instance of CsrFunctionCallAst
  #
  # source://idlc//lib/idlc/ast.rb#9620
  def initialize(input, interval, function_name, csr, args); end

  # source://idlc//lib/idlc/ast.rb#9618
  def args; end

  # source://idlc//lib/idlc/ast.rb#9606
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9617
  def csr; end

  # source://idlc//lib/idlc/ast.rb#9658
  def csr_def(symtab); end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/ast.rb#9652
  def csr_known?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9656
  def csr_name; end

  # @return [String] The function being called
  #
  # source://idlc//lib/idlc/ast.rb#9615
  def function_name; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#76
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#9687
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#9682
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#9635
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#9625
  def type_check(symtab); end

  # @todo check the sw_read function body
  #
  # source://idlc//lib/idlc/ast.rb#9663
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9696
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrFunctionCallAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# @api private
#
# source://idlc//lib/idlc/ast.rb#9587
class Idl::CsrFunctionCallSyntaxNode < ::Idl::SyntaxNode
  # @api private
  #
  # source://idlc//lib/idlc/ast.rb#9588
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16398
module Idl::CsrName0; end

# source://idlc//lib/idlc/ast.rb#9440
class Idl::CsrReadExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # @return [CsrReadExpressionAst] a new instance of CsrReadExpressionAst
  #
  # source://idlc//lib/idlc/ast.rb#9448
  def initialize(input, interval, csr_name); end

  # source://idlc//lib/idlc/ast.rb#9444
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9474
  def csr_def(symtab); end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/ast.rb#9478
  def csr_known?(symtab); end

  # Returns the value of attribute csr_name.
  #
  # source://idlc//lib/idlc/ast.rb#9446
  def csr_name; end

  # source://idlc//lib/idlc/ast.rb#9454
  def freeze_tree(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#325
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#494
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#9496
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#9493
  sig { override.returns(::String) }
  def to_idl; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#9467
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#9470
  def type_check(symtab); end

  # Return the compile-time-known value of the node
  #
  # source://idlc//lib/idlc/ast.rb#9483
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9503
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrReadExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#9428
class Idl::CsrReadExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#9429
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#5955
module Idl::CsrRegisterAccessExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5956
  def csr_name; end
end

# source://idlc//lib/idlc/ast.rb#9520
class Idl::CsrSoftwareWriteAst < ::Idl::AstNode
  include ::Idl::Executable

  # @return [CsrSoftwareWriteAst] a new instance of CsrSoftwareWriteAst
  #
  # source://idlc//lib/idlc/ast.rb#9529
  def initialize(input, interval, csr, expression); end

  # source://idlc//lib/idlc/ast.rb#9524
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9526
  def csr; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/ast.rb#9543
  def csr_known?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9547
  def csr_name; end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#9555
  def execute(_symtab); end

  # nothing to do for a function call
  #
  # source://idlc//lib/idlc/ast.rb#9558
  def execute_unknown(_symtab); end

  # source://idlc//lib/idlc/ast.rb#9527
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#82
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#9565
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#9562
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#9533
  def type_check(symtab); end

  # Return the compile-time-known value of the node
  #
  # source://idlc//lib/idlc/ast.rb#9550
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9573
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrSoftwareWriteAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#9514
class Idl::CsrSoftwareWriteSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#9515
  def to_ast; end
end

# represents a CSR register
#
# source://idlc//lib/idlc/type.rb#744
class Idl::CsrType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#751
  sig { params(csr: ::Idl::Csr, qualifiers: T::Array[::Symbol]).void }
  def initialize(csr, qualifiers: T.unsafe(nil)); end

  # source://idlc//lib/idlc/type.rb#748
  sig { returns(::Idl::Csr) }
  def csr; end

  # source://idlc//lib/idlc/type.rb#756
  sig { returns(T::Array[::Idl::CsrField]) }
  def fields; end
end

# source://idlc//lib/idlc/ast.rb#9714
class Idl::CsrWriteAst < ::Idl::AstNode
  include ::Idl::Executable

  # @return [CsrWriteAst] a new instance of CsrWriteAst
  #
  # source://idlc//lib/idlc/ast.rb#9722
  def initialize(input, interval, idx); end

  # source://idlc//lib/idlc/ast.rb#9718
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9738
  def csr_def(symtab); end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#9757
  def execute(symtab); end

  # nothing to do for a function call
  #
  # source://idlc//lib/idlc/ast.rb#9762
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#9720
  def idx; end

  # source://idlc//lib/idlc/ast.rb#9752
  def name(symtab); end

  # source://idlc//lib/idlc/ast.rb#9769
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#9766
  sig { override.returns(::String) }
  def to_idl; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#9748
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#9727
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9776
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrWriteAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#9710
class Idl::CsrWriteSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#9711
  def to_ast; end
end

# interface for any AstNode that introduces a new symbol into scope
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://idlc//lib/idlc/ast.rb#823
module Idl::Declaration
  interface!

  # @abstract
  #
  # source://idlc//lib/idlc/ast.rb#833
  sig { abstract.params(symtab: ::Idl::SymbolTable).void }
  def add_symbol(symtab); end
end

# source://idlc//lib/idlc/idl_parser.rb#12189
module Idl::Declaration0
  # source://idlc//lib/idlc/idl_parser.rb#12190
  def id; end
end

# source://idlc//lib/idlc/idl_parser.rb#12195
module Idl::Declaration1
  # source://idlc//lib/idlc/idl_parser.rb#12200
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#12204
  def rest; end

  # source://idlc//lib/idlc/idl_parser.rb#12196
  def type_name; end
end

# source://idlc//lib/idlc/ast.rb#6474
class Idl::DontCareLvalueAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # @return [DontCareLvalueAst] a new instance of DontCareLvalueAst
  #
  # source://idlc//lib/idlc/ast.rb#6480
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#6478
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6499
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6496
  sig { override.returns(::String) }
  def to_idl; end

  # Return the type of this node
  #
  # @param _symtab [SymbolTable] Not used
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#6488
  def type(_symtab); end

  # source://idlc//lib/idlc/ast.rb#6483
  def type_check(_symtab); end

  # Return the compile-time-known value of the node
  #
  # @param _symtab [SymbolTable] Not used
  # @raise [AstNode::ValueError] if the value is not knowable at compile time
  # @return [Integer] if the compile-time-known value is an integer
  # @return [Boolean] if the compile-time-known value is a boolean
  #
  # source://idlc//lib/idlc/ast.rb#6493
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6505
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::DontCareLvalueAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6470
class Idl::DontCareLvalueSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6471
  def to_ast; end
end

# represents a don't care return value
#
# for example:
#   return -;
#
# source://idlc//lib/idlc/ast.rb#6411
class Idl::DontCareReturnAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # @return [DontCareReturnAst] a new instance of DontCareReturnAst
  #
  # source://idlc//lib/idlc/ast.rb#6417
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#6415
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#61
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6445
  def set_expected_type(t); end

  # source://idlc//lib/idlc/ast.rb#6453
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6450
  sig { override.returns(::String) }
  def to_idl; end

  # Return the type of this node
  #
  # @param _symtab [SymbolTable] Not used
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#6427
  def type(_symtab); end

  # source://idlc//lib/idlc/ast.rb#6422
  def type_check(_symtab); end

  # Return the compile-time-known value of the node
  #
  # @param _symtab [SymbolTable] Not used
  # @raise [AstNode::ValueError] if the value is not knowable at compile time
  # @return [Integer] if the compile-time-known value is an integer
  # @return [Boolean] if the compile-time-known value is a boolean
  #
  # source://idlc//lib/idlc/ast.rb#6432
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6459
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::DontCareReturnAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6401
class Idl::DontCareReturnSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6402
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#34
Idl::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#8865
class Idl::ElseIfAst < ::Idl::AstNode
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#8880
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      body_interval: T.nilable(T::Range[::Integer]),
      cond: T.all(::Idl::AstNode, ::Idl::Rvalue),
      body_stmts: T::Array[::Idl::StatementAst]
    ).void
  end
  def initialize(input, interval, body_interval, cond, body_stmts); end

  # source://idlc//lib/idlc/ast.rb#8877
  sig { returns(::Idl::IfBodyAst) }
  def body; end

  # source://idlc//lib/idlc/ast.rb#8874
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def cond; end

  # source://idlc//lib/idlc/ast.rb#8869
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/prune.rb#343
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#8901
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#8906
  def return_value(symtab); end

  # Evaluate all possible compile-time return values of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on a possible path), execute the node
  # and update the symtab
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  # @return [Array<Integer>] The possible return values. Will be an empty array if there are no return values
  # @return [Array<Boolean>] The possible return values. Will be an empty array if there are no return values
  #
  # source://idlc//lib/idlc/ast.rb#8917
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#8934
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#8929
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#8885
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#8942
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ElseIfAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# represents the builtin that returns an array with all elements of an Enum type
#
#  $enum_to_a(PrivilegeMode) #=> [3, 1, 1, 0, 5, 4]
#
# source://idlc//lib/idlc/ast.rb#1717
class Idl::EnumArrayCastAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1726
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      enum_class_name: ::Idl::UserTypeNameAst
    ).void
  end
  def initialize(input, interval, enum_class_name); end

  # source://idlc//lib/idlc/ast.rb#1723
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1720
  def enum_class; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#132
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1751
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1748
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1734
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1730
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1743
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1758
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::EnumArrayCastAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1708
class Idl::EnumArrayCastSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1709
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1633
class Idl::EnumCastAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1654
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      user_type_name: ::Idl::UserTypeNameAst,
      expression: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, user_type_name, expression); end

  # source://idlc//lib/idlc/ast.rb#1637
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # @return [UserTypeAst] Enum name
  #
  # source://idlc//lib/idlc/ast.rb#1640
  def enum_name; end

  # @return [Rvalue] Value expression
  #
  # source://idlc//lib/idlc/ast.rb#1643
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#107
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1687
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1684
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1676
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1658
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1681
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1695
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1627
class Idl::EnumCastSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1628
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#433
module Idl::EnumDefinition0
  # source://idlc//lib/idlc/idl_parser.rb#434
  def user_type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#440
module Idl::EnumDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#441
  def int; end
end

# source://idlc//lib/idlc/idl_parser.rb#447
module Idl::EnumDefinition2
  # source://idlc//lib/idlc/idl_parser.rb#452
  def i; end

  # source://idlc//lib/idlc/idl_parser.rb#448
  def user_type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#457
module Idl::EnumDefinition3
  # source://idlc//lib/idlc/idl_parser.rb#462
  def e; end

  # source://idlc//lib/idlc/idl_parser.rb#458
  def user_type_name; end
end

# Node representing an IDL enum definition
#
#  # this will result in an EnumDefinitionAst
#  enum PrivilegeMode {
#    M  0b011
#    S  0b001
#    HS 0b001 # alias for S when H extension is used
#    U  0b000
#    VS 0b101
#    VU 0b100
#  }
#
# source://idlc//lib/idlc/type.rb#12
class Idl::EnumDefinitionAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#1818
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      user_type: ::Idl::UserTypeNameAst,
      element_names: T::Array[::Idl::UserTypeNameAst],
      element_values: T::Array[T.nilable(::Idl::IntLiteralAst)]
    ).void
  end
  def initialize(input, interval, user_type, element_names, element_values); end

  # source://idlc//lib/idlc/ast.rb#1867
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#1807
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1842
  sig { returns(T::Array[::String]) }
  def element_names; end

  # source://idlc//lib/idlc/ast.rb#1852
  sig { returns(T::Array[::Integer]) }
  def element_values; end

  # @return [String] enum name
  #
  # source://idlc//lib/idlc/ast.rb#1883
  def name; end

  # source://idlc//lib/idlc/ast.rb#1897
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#1887
  sig { override.returns(::String) }
  def to_idl; end

  # Return the type of this node
  #
  # @param _symtab [SymbolTable] Not used
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#1875
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#1855
  def type_check(symtab); end

  # Return the compile-time-known value of the node
  #
  # @param _symtab [SymbolTable] Not used
  # @raise [AstNode::ValueError] if the value is not knowable at compile time
  # @return [Integer] if the compile-time-known value is an integer
  # @return [Boolean] if the compile-time-known value is a boolean
  #
  # source://idlc//lib/idlc/ast.rb#1880
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1910
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1770
class Idl::EnumDefinitionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1771
  def to_ast; end
end

# represents the builtin that returns the bitwidth of an element in an enum class
#
#  $enum_element_size(PrivilegeMode) #=> 3
#
# source://idlc//lib/idlc/ast.rb#1579
class Idl::EnumElementSizeAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1588
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      enum_class_name: ::Idl::UserTypeNameAst
    ).void
  end
  def initialize(input, interval, enum_class_name); end

  # source://idlc//lib/idlc/ast.rb#1585
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1582
  def enum_class; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#127
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1608
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1605
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1596
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1592
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1600
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1615
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1570
class Idl::EnumElementSizeSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1571
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#770
module Idl::EnumRef0
  # source://idlc//lib/idlc/idl_parser.rb#771
  def enum_class; end

  # source://idlc//lib/idlc/idl_parser.rb#775
  def member; end
end

# represents an enum reference
#
# for example:
#  ExtensionName::C
#  PrivilegeMode::M
#
# source://idlc//lib/idlc/ast.rb#5846
class Idl::EnumRefAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # @return [EnumRefAst] a new instance of EnumRefAst
  #
  # source://idlc//lib/idlc/ast.rb#5855
  def initialize(input, interval, class_name, member_name); end

  # source://idlc//lib/idlc/ast.rb#5852
  def class_name; end

  # source://idlc//lib/idlc/ast.rb#5850
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # freeze the entire tree from further modification
  # This is also an opportunity to pre-calculate anything that only needs global symbols
  #
  # @param global_symtab [SymbolTable] Symbol table with global scope populated
  #
  # source://idlc//lib/idlc/ast.rb#5864
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#117
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#148
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#5853
  def member_name; end

  # source://idlc//lib/idlc/ast.rb#5913
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#5910
  sig { override.returns(::String) }
  def to_idl; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#5887
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#5877
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5903
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5921
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::EnumRefAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5835
class Idl::EnumRefSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5836
  def to_ast; end
end

# represents the builtin that returns the nymber of elements in an enum class
#
#  $enum_size(XRegWidth) #=> 2
#
# source://idlc//lib/idlc/ast.rb#1519
class Idl::EnumSizeAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # @return [EnumSizeAst] a new instance of EnumSizeAst
  #
  # source://idlc//lib/idlc/ast.rb#1527
  def initialize(input, interval, enum_class_name); end

  # source://idlc//lib/idlc/ast.rb#1525
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1522
  def enum_class; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#122
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1551
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1548
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1535
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1531
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1543
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1558
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1510
class Idl::EnumSizeSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1511
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#6692
module Idl::EnumToA0
  # source://idlc//lib/idlc/idl_parser.rb#6693
  def user_type_name; end
end

# source://idlc//lib/idlc/type.rb#641
class Idl::EnumerationType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#671
  sig do
    params(
      type_name: ::String,
      element_names: T::Array[::String],
      element_values: T::Array[::Integer],
      builtin: T::Boolean
    ).void
  end
  def initialize(type_name, element_names, element_values, builtin: T.unsafe(nil)); end

  # source://idlc//lib/idlc/type.rb#686
  sig { returns(T::Boolean) }
  def builtin?; end

  # source://idlc//lib/idlc/type.rb#689
  sig { returns(::Idl::EnumerationType) }
  def clone; end

  # source://idlc//lib/idlc/type.rb#702
  sig { params(element_value: ::Integer).returns(T.nilable(::String)) }
  def element_name(element_value); end

  # source://idlc//lib/idlc/type.rb#650
  sig { returns(T::Array[::String]) }
  def element_names; end

  # source://idlc//lib/idlc/type.rb#654
  sig { returns(T::Array[::Integer]) }
  def element_values; end

  # source://idlc//lib/idlc/type.rb#658
  sig { returns(::Idl::Type) }
  def ref_type; end

  # source://idlc//lib/idlc/type.rb#694
  sig { params(element_name: ::String).returns(T.nilable(::Integer)) }
  def value(element_name); end

  # source://idlc//lib/idlc/type.rb#646
  sig { returns(::Integer) }
  def width; end
end

# interface for nodes that can be executed, but don't have a value (e.g., statements)
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://idlc//lib/idlc/ast.rb#594
module Idl::Executable
  interface!

  # "execute" the statement by updating the variables in the symbol table
  # "execute" the statement by updating the variables in the symbol table
  #
  # @abstract
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @raise ValueError if some part of the statement cannot be executed at compile time
  #
  # source://idlc//lib/idlc/ast.rb#616
  sig { abstract.params(symtab: ::Idl::SymbolTable).void }
  def execute(symtab); end

  # "execute" the statement, forcing any variable assignments to an unknown state
  # This is used down unknown conditional paths.
  # "execute" the statement, forcing any variable assignments to an unknown state
  # This is used down unknown conditional paths.
  #
  # @abstract
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @raise ValueError if some part of the statement cannot be executed at compile time
  #
  # source://idlc//lib/idlc/ast.rb#620
  sig { abstract.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end
end

# source://idlc//lib/idlc/ast.rb#623
Idl::ExecutableAst = T.type_alias { T.all(::Idl::AstNode, ::Idl::Executable) }

# source://idlc//lib/idlc/idl_parser.rb#13702
module Idl::ExecuteIfBlock0
  # source://idlc//lib/idlc/idl_parser.rb#13703
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13709
module Idl::ExecuteIfBlock1
  # source://idlc//lib/idlc/idl_parser.rb#13710
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13716
module Idl::ExecuteIfBlock2
  # source://idlc//lib/idlc/idl_parser.rb#13721
  def body; end

  # source://idlc//lib/idlc/idl_parser.rb#13717
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#13727
module Idl::ExecuteIfBlock3
  # source://idlc//lib/idlc/idl_parser.rb#13728
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13734
module Idl::ExecuteIfBlock4
  # source://idlc//lib/idlc/idl_parser.rb#13735
  def body; end
end

# source://idlc//lib/idlc/idl_parser.rb#13741
module Idl::ExecuteIfBlock5
  # source://idlc//lib/idlc/idl_parser.rb#13750
  def elseifs; end

  # source://idlc//lib/idlc/idl_parser.rb#13754
  def final_else; end

  # source://idlc//lib/idlc/idl_parser.rb#13746
  def if_body; end

  # source://idlc//lib/idlc/idl_parser.rb#13742
  def if_cond; end
end

# source://idlc//lib/idlc/ast.rb#919
class Idl::FalseExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#923
  sig { params(input: ::String, interval: T::Range[::Integer]).void }
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#928
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#153
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#93
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#943
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#940
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#71
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#934
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#931
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#937
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::FalseClass) }
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#949
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#915
class Idl::FalseExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#916
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#10826
module Idl::Fetch0
  # source://idlc//lib/idlc/idl_parser.rb#10827
  def function_body; end
end

# source://idlc//lib/idlc/ast.rb#7985
class Idl::FetchAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#7992
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      body: ::Idl::FunctionBodyAst
    ).void
  end
  def initialize(input, interval, body); end

  # source://idlc//lib/idlc/ast.rb#7989
  def body; end

  # source://idlc//lib/idlc/ast.rb#7987
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#8000
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#8014
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#8005
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7996
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#8021
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FetchAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#7979
class Idl::FetchSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7980
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#6096
module Idl::FieldAccessExpression0
  # source://idlc//lib/idlc/idl_parser.rb#6097
  def field_access_eligible_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#6101
  def field_name; end
end

# represents a bitfield or struct field access (rvalue)
#
# for example:
#   entry.PPN
#
# source://idlc//lib/idlc/ast.rb#5747
class Idl::FieldAccessExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5757
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      bitfield: T.all(::Idl::AstNode, ::Idl::Rvalue),
      field_name: ::String
    ).void
  end
  def initialize(input, interval, bitfield, field_name); end

  # source://idlc//lib/idlc/ast.rb#5751
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#87
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5763
  def kind(symtab); end

  # source://idlc//lib/idlc/ast.rb#5754
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def obj; end

  # source://idlc//lib/idlc/ast.rb#5814
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#5811
  sig { override.returns(::String) }
  def to_idl; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#5768
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5780
  def type_check(symtab); end

  # Return the compile-time-known value of the node
  #
  # source://idlc//lib/idlc/ast.rb#5798
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5822
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FieldAccessExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5737
class Idl::FieldAccessExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5738
  def to_ast; end
end

# represents a bitfield or struct assignment
#
# for example:
#   Sv39PageTableEntry entry;
#   entry.PPN = 0
#
# source://idlc//lib/idlc/ast.rb#3105
class Idl::FieldAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#3133
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      id: ::Idl::IdAst,
      field_name: ::String,
      rhs: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, id, field_name, rhs); end

  # source://idlc//lib/idlc/ast.rb#3118
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#3178
  def execute(symtab); end

  # "execute" the statement, forcing any variable assignments to an unknown state
  # This is used down unknown conditional paths.
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#3201
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#3115
  sig { returns(::String) }
  def field_name; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#92
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3109
  sig { returns(::Idl::IdAst) }
  def id; end

  # source://idlc//lib/idlc/ast.rb#3112
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#3211
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#3208
  sig { override.returns(::String) }
  def to_idl; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#3139
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#3153
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#3220
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FieldAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3093
class Idl::FieldAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3094
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#15831
module Idl::FieldName0; end

# source://idlc//lib/idlc/idl_parser.rb#14342
module Idl::ForLoop0
  # source://idlc//lib/idlc/idl_parser.rb#14343
  def s; end
end

# source://idlc//lib/idlc/idl_parser.rb#14349
module Idl::ForLoop1
  # source://idlc//lib/idlc/idl_parser.rb#14358
  def action; end

  # source://idlc//lib/idlc/idl_parser.rb#14354
  def condition; end

  # source://idlc//lib/idlc/idl_parser.rb#14350
  def for_loop_iteration_variable_declaration; end

  # source://idlc//lib/idlc/idl_parser.rb#14362
  def stmts; end
end

# source://idlc//lib/idlc/ast.rb#8514
class Idl::ForLoopAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Returns

  # @return [ForLoopAst] a new instance of ForLoopAst
  #
  # source://idlc//lib/idlc/ast.rb#8539
  def initialize(input, interval, init, condition, update, stmts); end

  # source://idlc//lib/idlc/ast.rb#8530
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def condition; end

  # source://idlc//lib/idlc/ast.rb#8519
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#8657
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#8660
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#202
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#8527
  sig { returns(::Idl::VariableDeclarationWithInitializationAst) }
  def init; end

  # source://idlc//lib/idlc/passes/prune.rb#118
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#197
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#174
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#8606
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # Evaluate the compile-time return value of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on the taken path), execute the node
  # and update the symtab
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  # @return [Integer] The return value, if it is integral
  # @return [Boolean] The return value, if it is boolean
  # @return [nil] if the return value is not compile-time-known
  #
  # source://idlc//lib/idlc/ast.rb#8573
  def return_value(symtab); end

  # Evaluate all possible compile-time return values of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on a possible path), execute the node
  # and update the symtab
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  # @return [Array<Integer>] The possible return values. Will be an empty array if there are no return values
  # @return [Array<Boolean>] The possible return values. Will be an empty array if there are no return values
  #
  # source://idlc//lib/idlc/ast.rb#8612
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#8556
  sig { params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def satisfied?(symtab); end

  # source://idlc//lib/idlc/ast.rb#8537
  sig do
    returns(T::Array[T.any(::Idl::ForLoopAst, ::Idl::IfAst, ::Idl::ImplicationStatementAst, ::Idl::ReturnStatementAst, ::Idl::StatementAst)])
  end
  def stmts; end

  # source://idlc//lib/idlc/ast.rb#8692
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#8682
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#88
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#8544
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#8533
  sig { returns(T.all(::Idl::AstNode, ::Idl::Executable)) }
  def update; end

  class << self
    # source://idlc//lib/idlc/ast.rb#8702
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ForLoopAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#8535
Idl::ForLoopAst::StmtType = T.type_alias { T.any(::Idl::ForLoopAst, ::Idl::IfAst, ::Idl::ImplicationStatementAst, ::Idl::ReturnStatementAst, ::Idl::StatementAst) }

# source://idlc//lib/idlc/idl_parser.rb#12060
module Idl::ForLoopIterationVariableDeclaration0
  # source://idlc//lib/idlc/idl_parser.rb#12069
  def ary_size; end

  # source://idlc//lib/idlc/idl_parser.rb#12065
  def id; end

  # source://idlc//lib/idlc/idl_parser.rb#12073
  def rval; end

  # source://idlc//lib/idlc/idl_parser.rb#12061
  def type_name; end
end

# source://idlc//lib/idlc/ast.rb#3706
class Idl::ForLoopIterationVariableDeclarationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3707
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#8502
class Idl::ForLoopSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#8503
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#9416
module Idl::FunctionArgList0
  # source://idlc//lib/idlc/idl_parser.rb#9417
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#9422
module Idl::FunctionArgList1
  # source://idlc//lib/idlc/idl_parser.rb#9423
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#9427
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#16095
module Idl::FunctionBody0
  # source://idlc//lib/idlc/idl_parser.rb#16096
  def choice; end
end

# source://idlc//lib/idlc/idl_parser.rb#16102
module Idl::FunctionBody1
  # source://idlc//lib/idlc/idl_parser.rb#16103
  def func_stmt_list; end
end

# source://idlc//lib/idlc/ast.rb#7840
class Idl::FunctionBodyAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#7852
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      stmts: T::Array[T.all(::Idl::AstNode, ::Idl::Executable)]
    ).void
  end
  def initialize(input, interval, stmts); end

  # source://idlc//lib/idlc/ast.rb#7845
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7915
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#7918
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#311
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#22
  def gen_option_adoc; end

  # @return [Array<Ast, Array<Ast>>] List of possible return values, along with the condition it occurs under
  #
  # source://idlc//lib/idlc/passes/find_return_values.rb#67
  def pass_find_return_values(symtab); end

  # source://idlc//lib/idlc/passes/prune.rb#161
  def prune(symtab, args_already_applied: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7884
  def return_type(symtab); end

  # Evaluate the compile-time return value of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on the taken path), execute the node
  # and update the symtab
  #
  # @note arguments and template arguments must be put on the symtab before calling
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  # @return [Integer] The return value, if it is integral
  # @return [Boolean] The return value, if it is boolean
  # @return [nil] if the return value is not compile-time-known
  #
  # source://idlc//lib/idlc/ast.rb#7899
  def return_value(symtab); end

  # Evaluate all possible compile-time return values of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on a possible path), execute the node
  # and update the symtab
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  # @return [Array<Integer>] The possible return values. Will be an empty array if there are no return values
  # @return [Array<Boolean>] The possible return values. Will be an empty array if there are no return values
  #
  # source://idlc//lib/idlc/ast.rb#7925
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#7856
  def statements; end

  # source://idlc//lib/idlc/ast.rb#7858
  def stmts; end

  # source://idlc//lib/idlc/ast.rb#7960
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#7955
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#7861
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#7967
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FunctionBodyAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#7833
class Idl::FunctionBodySyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7835
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#8869
module Idl::FunctionCall0
  # source://idlc//lib/idlc/idl_parser.rb#8870
  def csr; end

  # source://idlc//lib/idlc/idl_parser.rb#8874
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#8880
module Idl::FunctionCall1
  # source://idlc//lib/idlc/idl_parser.rb#8881
  def csr; end

  # source://idlc//lib/idlc/idl_parser.rb#8889
  def function_arg_list; end

  # source://idlc//lib/idlc/idl_parser.rb#8885
  def function_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#8895
module Idl::FunctionCall2
  # source://idlc//lib/idlc/idl_parser.rb#8896
  def targs; end
end

# source://idlc//lib/idlc/idl_parser.rb#8902
module Idl::FunctionCall3
  # source://idlc//lib/idlc/idl_parser.rb#8911
  def function_arg_list; end

  # source://idlc//lib/idlc/idl_parser.rb#8903
  def function_name; end

  # source://idlc//lib/idlc/idl_parser.rb#8907
  def t; end
end

# source://idlc//lib/idlc/ast.rb#7507
class Idl::FunctionCallExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue
  include ::Idl::Executable

  # @raise [ArgumentError]
  # @return [FunctionCallExpressionAst] a new instance of FunctionCallExpressionAst
  #
  # source://idlc//lib/idlc/ast.rb#7522
  def initialize(input, interval, function_name, targs, args); end

  # @return [Array<AstNode>] Function argument nodes
  #
  # source://idlc//lib/idlc/ast.rb#7564
  def arg_nodes; end

  # source://idlc//lib/idlc/ast.rb#7520
  def args; end

  # source://idlc//lib/idlc/ast.rb#7513
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7720
  def execute(symtab); end

  # nothing to do for a function call
  #
  # source://idlc//lib/idlc/ast.rb#7728
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#7568
  def func_type(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#289
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#28
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#7722
  def name; end

  # source://idlc//lib/idlc/passes/prune.rb#82
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#25
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#21
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7519
  def targs; end

  # @return [Boolean] whether or not the function call has a template argument
  #
  # source://idlc//lib/idlc/ast.rb#7535
  def template?; end

  # @return [Array<AstNode>] Template argument nodes
  #
  # source://idlc//lib/idlc/ast.rb#7540
  def template_arg_nodes; end

  # source://idlc//lib/idlc/ast.rb#7544
  def template_values(symtab, unknown_ok: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7741
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#7732
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#163
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#7634
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#7583
  def type_check(symtab); end

  # Return the compile-time-known value of the node
  #
  # source://idlc//lib/idlc/ast.rb#7643
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#7752
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FunctionCallExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#7497
class Idl::FunctionCallExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7498
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#8768
module Idl::FunctionCallTemplateArguments0
  # source://idlc//lib/idlc/idl_parser.rb#8769
  def arg; end
end

# source://idlc//lib/idlc/idl_parser.rb#8774
module Idl::FunctionCallTemplateArguments1
  # source://idlc//lib/idlc/idl_parser.rb#8775
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#8779
  def rest; end
end

# source://idlc//lib/idlc/ast.rb#8053
class Idl::FunctionDefAst < ::Idl::AstNode
  include ::Idl::Declaration

  # @param input [String] The source code
  # @param interval [Range] The range in the source code for this function definition
  # @param name [String] The name of the function
  # @param targs [Array<AstNode>] Template arguments
  # @param return_types [Array<AstNode>] Return types
  # @param arguments [Array<AstNode>] Arguments
  # @param desc [String] Description
  # @param type [:normal, :builtin, :generated, :external] Type of function
  # @param body [AstNode, nil] Body, unless the function is builtin
  # @return [FunctionDefAst] a new instance of FunctionDefAst
  #
  # source://idlc//lib/idlc/ast.rb#8077
  def initialize(input, interval, name, targs, return_types, arguments, desc, type, body); end

  # source://idlc//lib/idlc/ast.rb#8058
  def <=>(other); end

  # source://idlc//lib/idlc/ast.rb#8345
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#8307
  def apply_template_and_arg_syms(symtab); end

  # Returns the value of attribute argument_nodes.
  #
  # source://idlc//lib/idlc/ast.rb#8098
  def argument_nodes; end

  # @return [Array<Array(Type,String)>] containing the argument types and names, in order
  #
  # source://idlc//lib/idlc/ast.rb#8128
  def arguments(symtab); end

  # returns an array of arguments, as a string
  # function (or template instance) does not need to be resolved
  #
  # source://idlc//lib/idlc/ast.rb#8159
  def arguments_list_str; end

  # source://idlc//lib/idlc/ast.rb#8397
  def body; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/ast.rb#8403
  def builtin?; end

  # if the arguments are all consts, will the return value be const/knowable?
  # if const_if_args_const? is true, then the return value of the function is gauranteed
  # to be known at compile time when all argument values are known at compile time
  #
  # source://idlc//lib/idlc/ast.rb#8239
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # @return [String] Asciidoc formatted function description
  #
  # source://idlc//lib/idlc/ast.rb#8113
  def description; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/ast.rb#8064
  def eql?(other); end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/ast.rb#8411
  def external?; end

  # freeze the entire tree from further modification
  # This is also an opportunity to pre-calculate anything that only needs global symbols
  #
  # @param global_symtab [SymbolTable] Symbol table with global scope populated
  #
  # source://idlc//lib/idlc/ast.rb#8101
  def freeze_tree(global_symtab); end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/ast.rb#8407
  def generated?; end

  # source://idlc//lib/idlc/ast.rb#8268
  def name; end

  # @return [Integer] The number of arguments to the function
  #
  # source://idlc//lib/idlc/ast.rb#8123
  def num_args; end

  # source://idlc//lib/idlc/passes/prune.rb#141
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#8415
  def qualifier_str; end

  # Returns the value of attribute reachable_functions_cache.
  #
  # source://idlc//lib/idlc/ast.rb#8098
  def reachable_functions_cache; end

  # return the return type, which may be a tuple of multiple types
  #
  # source://idlc//lib/idlc/ast.rb#8164
  def return_type(symtab); end

  # function (or template instance) does not need to be resolved
  #
  # @return [Array<String>] return type strings
  #
  # source://idlc//lib/idlc/ast.rb#8227
  def return_type_list_str; end

  # Returns the value of attribute return_type_nodes.
  #
  # source://idlc//lib/idlc/ast.rb#8056
  def return_type_nodes; end

  # @return [Array<String>] Template argument names, in order
  #
  # source://idlc//lib/idlc/ast.rb#8359
  def template_names; end

  # @param symtab [SymbolTable] The context for evaluation
  # @return [Array<Type>] Template argument types, in order
  #
  # source://idlc//lib/idlc/ast.rb#8365
  def template_types(symtab); end

  # @return [Boolean] whether or not the function is templated
  #
  # source://idlc//lib/idlc/ast.rb#8118
  def templated?; end

  # source://idlc//lib/idlc/ast.rb#8471
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#8428
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#8318
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#8387
  def type_check_args(symtab); end

  # source://idlc//lib/idlc/ast.rb#8391
  def type_check_body(symtab); end

  # we do lazy type checking of the function body so that we never check
  # uncalled functions, which avoids dealing with mentions of CSRs that
  # may not exist in a given implementation
  #
  # source://idlc//lib/idlc/ast.rb#8291
  def type_check_from_call(symtab); end

  # source://idlc//lib/idlc/ast.rb#8383
  def type_check_return(symtab); end

  # source://idlc//lib/idlc/ast.rb#8378
  def type_check_targs(symtab); end

  # @param template [Array<Integer>] values to apply
  #
  # source://idlc//lib/idlc/ast.rb#8273
  def type_check_template_instance(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#8484
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FunctionDefAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#8033
class Idl::FunctionDefSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#8034
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#13044
module Idl::FunctionIfBlock0
  # source://idlc//lib/idlc/idl_parser.rb#13045
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13051
module Idl::FunctionIfBlock1
  # source://idlc//lib/idlc/idl_parser.rb#13052
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13058
module Idl::FunctionIfBlock2
  # source://idlc//lib/idlc/idl_parser.rb#13063
  def body; end

  # source://idlc//lib/idlc/idl_parser.rb#13059
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#13069
module Idl::FunctionIfBlock3
  # source://idlc//lib/idlc/idl_parser.rb#13070
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13076
module Idl::FunctionIfBlock4
  # source://idlc//lib/idlc/idl_parser.rb#13077
  def body; end
end

# source://idlc//lib/idlc/idl_parser.rb#13083
module Idl::FunctionIfBlock5
  # source://idlc//lib/idlc/idl_parser.rb#13092
  def elseifs; end

  # source://idlc//lib/idlc/idl_parser.rb#13096
  def final_else; end

  # source://idlc//lib/idlc/idl_parser.rb#13088
  def if_body; end

  # source://idlc//lib/idlc/idl_parser.rb#13084
  def if_cond; end
end

# source://idlc//lib/idlc/idl_parser.rb#9334
module Idl::FunctionName0; end

# source://idlc//lib/idlc/type.rb#763
class Idl::FunctionType < ::Idl::Type
  # @return [FunctionType] a new instance of FunctionType
  #
  # source://idlc//lib/idlc/type.rb#766
  def initialize(func_name, func_def_ast, symtab); end

  # apply the arguments as Vars.
  # then add the value to the Var
  #
  # source://idlc//lib/idlc/type.rb#845
  sig do
    params(
      symtab: ::Idl::SymbolTable,
      argument_nodes: T::Array[::Idl::Rvalue],
      call_site_symtab: ::Idl::SymbolTable,
      func_call_ast: ::Idl::FunctionCallExpressionAst
    ).returns(T::Array[T.any(::Integer, ::Symbol)])
  end
  def apply_arguments(symtab, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#816
  def apply_template_values(template_values, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#949
  def argument_name(index, template_values = T.unsafe(nil), func_call_ast); end

  # source://idlc//lib/idlc/type.rb#934
  def argument_type(index, template_values, argument_nodes, call_site_symtab, func_call_ast); end

  # @return [Array<Integer,Boolean>] Array of argument values, if known
  # @return [nil] if at least one argument value is not known
  #
  # source://idlc//lib/idlc/type.rb#866
  def argument_values(symtab, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#964
  def body; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/type.rb#778
  def builtin?; end

  # source://idlc//lib/idlc/type.rb#774
  def clone; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/type.rb#782
  def external?; end

  # Returns the value of attribute func_def_ast.
  #
  # source://idlc//lib/idlc/type.rb#764
  def func_def_ast; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/type.rb#780
  def generated?; end

  # source://idlc//lib/idlc/type.rb#784
  def num_args; end

  # return [Type] type of the call return
  #
  # source://idlc//lib/idlc/type.rb#892
  sig do
    params(
      template_values: T::Array[::Integer],
      argument_nodes: T::Array[::Idl::Rvalue],
      func_call_ast: ::Idl::FunctionCallExpressionAst
    ).returns(::Idl::Type)
  end
  def return_type(template_values, argument_nodes, func_call_ast); end

  # @param template_values [Array<Integer>] Template values to apply, required if {#templated?}
  # @return [Array<Type>] return types
  #
  # source://idlc//lib/idlc/type.rb#921
  def return_types(template_values, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#905
  def return_value(template_values, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#810
  def template_names; end

  # source://idlc//lib/idlc/type.rb#812
  def template_types(symtab); end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/type.rb#814
  def templated?; end

  # source://idlc//lib/idlc/type.rb#786
  def type_check_call(template_values, argument_nodes, call_site_symtab, func_call_ast); end
end

# source://idlc//lib/idlc/ast.rb#1185
class Idl::GlobalAst < ::Idl::AstNode
  include ::Idl::Declaration

  # @return [GlobalAst] a new instance of GlobalAst
  #
  # source://idlc//lib/idlc/ast.rb#1200
  def initialize(input, interval, declaration); end

  # source://idlc//lib/idlc/ast.rb#1213
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#1189
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # @return [VariableDeclarationAst] The decl
  #
  # source://idlc//lib/idlc/ast.rb#1196
  def declaration; end

  # source://idlc//lib/idlc/ast.rb#1191
  def id; end

  # source://idlc//lib/idlc/ast.rb#1223
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1220
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1209
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1205
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1230
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/idl_parser.rb#269
module Idl::GlobalDefinition0; end

# source://idlc//lib/idlc/idl_parser.rb#272
module Idl::GlobalDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#273
  def const; end

  # source://idlc//lib/idlc/idl_parser.rb#277
  def single_declaration_with_initialization; end
end

# source://idlc//lib/idlc/idl_parser.rb#283
module Idl::GlobalDefinition2
  # source://idlc//lib/idlc/idl_parser.rb#284
  def declaration; end
end

# source://idlc//lib/idlc/ast.rb#1179
class Idl::GlobalSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1180
  def to_ast; end
end

# global variable declared with an initializer,
#
# e.g.,
#
# Bits<65> UNDEFINED_LEGAL = 65'h10000000000000000;
# Bits<FLEN> f[32] = [0, 0, 0, 0, 0, 0, 0, 0,
#                     0, 0, 0, 0, 0, 0, 0, 0,
#                     0, 0, 0, 0, 0, 0, 0, 0,
#                     0, 0, 0, 0, 0, 0, 0, 0];
#
# source://idlc//lib/idlc/ast.rb#1105
class Idl::GlobalWithInitializationAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Declaration

  # @return [GlobalWithInitializationAst] a new instance of GlobalWithInitializationAst
  #
  # source://idlc//lib/idlc/ast.rb#1120
  def initialize(input, interval, var_decl_with_init); end

  # source://idlc//lib/idlc/ast.rb#1147
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#1113
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1141
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#1144
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#1109
  def id; end

  # source://idlc//lib/idlc/ast.rb#1110
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#1161
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1156
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1131
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1126
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1136
  def value(symtab); end

  # @return [VariableDeclarationWithInitializationAst] The initializer
  #
  # source://idlc//lib/idlc/ast.rb#1116
  def var_decl_with_init; end

  class << self
    # source://idlc//lib/idlc/ast.rb#1168
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1090
class Idl::GlobalWithInitializationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1091
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16283
module Idl::Id0; end

# an identifier
#
# Used for variables
#
# source://idlc//lib/idlc/ast.rb#967
class Idl::IdAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#981
  sig { params(input: ::String, interval: T::Range[::Integer], name: ::String).void }
  def initialize(input, interval, name); end

  # source://idlc//lib/idlc/ast.rb#1012
  sig { returns(T::Boolean) }
  def const?; end

  # source://idlc//lib/idlc/ast.rb#971
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#158
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#97
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#1028
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(::Integer, ::Symbol)) }
  def max_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#1046
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(::Integer, ::Symbol)) }
  def min_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#975
  sig { returns(::String) }
  def name; end

  # source://idlc//lib/idlc/ast.rb#978
  sig { override.returns(::String) }
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#1068
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#1065
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#76
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  #
  # source://idlc//lib/idlc/ast.rb#994
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#988
  def type_check(symtab); end

  # Return the compile-time-known value of the node
  #
  # source://idlc//lib/idlc/ast.rb#1015
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1075
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#960
class Idl::IdSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#961
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#8992
class Idl::IfAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Returns

  # @return [IfAst] a new instance of IfAst
  #
  # source://idlc//lib/idlc/ast.rb#9016
  def initialize(input, interval, if_cond, if_body, elseifs, final_else_body); end

  # source://idlc//lib/idlc/ast.rb#8997
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9011
  sig { returns(T::Array[::Idl::ElseIfAst]) }
  def elseifs; end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#9185
  def execute(symtab); end

  # nothing to do for a function call
  #
  # source://idlc//lib/idlc/ast.rb#9231
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#9014
  sig { returns(::Idl::IfBodyAst) }
  def final_else_body; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#331
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#34
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#9008
  sig { returns(::Idl::IfBodyAst) }
  def if_body; end

  # source://idlc//lib/idlc/ast.rb#9005
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def if_cond; end

  # source://idlc//lib/idlc/passes/find_return_values.rb#35
  def pass_find_return_values(values, current_conditions, symtab); end

  # source://idlc//lib/idlc/passes/prune.rb#355
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#101
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#84
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#9078
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # Evaluate the compile-time return value of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on the taken path), execute the node
  # and update the symtab
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  # @return [Integer] The return value, if it is integral
  # @return [Boolean] The return value, if it is boolean
  # @return [nil] if the return value is not compile-time-known
  #
  # source://idlc//lib/idlc/ast.rb#9087
  def return_value(symtab); end

  # Returns a list of all possible return values, if known. Otherwise, raises a ValueError
  #
  # @param symtab [SymbolTable] Context for the evaluation
  # @raise ValueError if it is not possible to determine all return values at compile time
  # @return [Array<Integer,Bool>] List of all possible return values
  #
  # source://idlc//lib/idlc/ast.rb#9128
  def return_values(symtab); end

  # @raise ValueError if the take path is not known at compile time
  # @return [Boolean] true if the taken path is knowable at compile-time
  #
  # source://idlc//lib/idlc/ast.rb#9065
  def taken_body(symtab); end

  # source://idlc//lib/idlc/ast.rb#9254
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#9238
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#9027
  def type_check(symtab); end

  private

  # return values starting at the first else if
  #
  # source://idlc//lib/idlc/ast.rb#9146
  def execute_after_if(symtab); end

  # return values starting at the first else if
  #
  # source://idlc//lib/idlc/ast.rb#9222
  def execute_unknown_after_if(symtab); end

  # return values starting at the first else if
  #
  # source://idlc//lib/idlc/ast.rb#9096
  def return_values_after_if(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9264
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::IfAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#8717
class Idl::IfBodyAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#8730
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      body_stmts: T::Array[::Idl::StatementAst]
    ).void
  end
  def initialize(input, interval, body_stmts); end

  # source://idlc//lib/idlc/ast.rb#8722
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#8807
  def execute(symtab); end

  # nothing to do for a function call
  #
  # source://idlc//lib/idlc/ast.rb#8833
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#35
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#71
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/prune.rb#331
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#8752
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # Evaluate the compile-time return value of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on the taken path), execute the node
  # and update the symtab
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  # @return [Integer] The return value, if it is integral
  # @return [Boolean] The return value, if it is boolean
  # @return [nil] if the return value is not compile-time-known
  #
  # source://idlc//lib/idlc/ast.rb#8758
  def return_value(symtab); end

  # Evaluate all possible compile-time return values of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on a possible path), execute the node
  # and update the symtab
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  # @return [Array<Integer>] The possible return values. Will be an empty array if there are no return values
  # @return [Array<Boolean>] The possible return values. Will be an empty array if there are no return values
  #
  # source://idlc//lib/idlc/ast.rb#8779
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#8727
  sig { returns(T::Array[::Idl::StatementAst]) }
  def stmts; end

  # source://idlc//lib/idlc/ast.rb#8846
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#8841
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#8739
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#8853
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::IfBodyAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#8957
class Idl::IfSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#8958
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#8010
module Idl::ImplicationExpression0
  # source://idlc//lib/idlc/idl_parser.rb#8011
  def antecedent; end

  # source://idlc//lib/idlc/idl_parser.rb#8015
  def consequent; end
end

# source://idlc//lib/idlc/idl_parser.rb#8021
module Idl::ImplicationExpression1
  # source://idlc//lib/idlc/idl_parser.rb#8022
  def antecedent; end

  # source://idlc//lib/idlc/idl_parser.rb#8026
  def consequent; end
end

# source://idlc//lib/idlc/ast.rb#3977
class Idl::ImplicationExpressionAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#3986
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      antecedent: T.all(::Idl::AstNode, ::Idl::Rvalue),
      consequent: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, antecedent, consequent); end

  # source://idlc//lib/idlc/ast.rb#3997
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def antecedent; end

  # source://idlc//lib/idlc/ast.rb#4000
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def consequent; end

  # source://idlc//lib/idlc/ast.rb#3992
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4009
  sig { params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def satisfied?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4018
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4015
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#25
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#4003
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4026
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ImplicationExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3966
class Idl::ImplicationExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3968
  sig { override.returns(::Idl::ImplicationExpressionAst) }
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#8222
module Idl::ImplicationForLoop0
  # source://idlc//lib/idlc/idl_parser.rb#8223
  def s; end
end

# source://idlc//lib/idlc/idl_parser.rb#8229
module Idl::ImplicationForLoop1
  # source://idlc//lib/idlc/idl_parser.rb#8238
  def action; end

  # source://idlc//lib/idlc/idl_parser.rb#8234
  def condition; end

  # source://idlc//lib/idlc/idl_parser.rb#8230
  def for_loop_iteration_variable_declaration; end

  # source://idlc//lib/idlc/idl_parser.rb#8242
  def stmts; end
end

# source://idlc//lib/idlc/idl_parser.rb#8544
module Idl::ImplicationStatement0
  # source://idlc//lib/idlc/idl_parser.rb#8545
  def implication_expression; end
end

# source://idlc//lib/idlc/ast.rb#4046
class Idl::ImplicationStatementAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#4054
  sig do
    params(
      input: ::String,
      interval: T::Range[::Integer],
      implication_expression: ::Idl::ImplicationExpressionAst
    ).void
  end
  def initialize(input, interval, implication_expression); end

  # source://idlc//lib/idlc/ast.rb#4059
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4062
  sig { returns(::Idl::ImplicationExpressionAst) }
  def expression; end

  # source://idlc//lib/idlc/ast.rb#4070
  sig { params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def satisfied?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4078
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4075
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#46
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#4065
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4085
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ImplicationExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4039
class Idl::ImplicationStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4041
  sig { override.returns(::Idl::ImplicationStatementAst) }
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#189
module Idl::IncludeStatement0
  # source://idlc//lib/idlc/idl_parser.rb#190
  def string; end
end

# source://idlc//lib/idlc/ast.rb#844
class Idl::IncludeStatementAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#853
  sig { params(input: ::String, interval: T::Range[T.untyped], filename: ::Idl::AstNode).void }
  def initialize(input, interval, filename); end

  # source://idlc//lib/idlc/ast.rb#846
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#850
  sig { returns(::String) }
  def filename; end

  # source://idlc//lib/idlc/ast.rb#863
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#858
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#861
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#836
class Idl::IncludeStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#838
  sig { override.returns(::Idl::IncludeStatementAst) }
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16179
module Idl::InstructionOperation0
  # source://idlc//lib/idlc/idl_parser.rb#16180
  def choice; end
end

# source://idlc//lib/idlc/idl_parser.rb#16186
module Idl::InstructionOperation1
  # source://idlc//lib/idlc/idl_parser.rb#16187
  def op_stmt_list; end
end

# source://idlc//lib/idlc/ast.rb#7827
class Idl::InstructionOperationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7828
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#1478
module Idl::Int0; end

# source://idlc//lib/idlc/idl_parser.rb#1481
module Idl::Int1; end

# source://idlc//lib/idlc/idl_parser.rb#1508
module Idl::Int10; end

# source://idlc//lib/idlc/idl_parser.rb#1511
module Idl::Int11; end

# source://idlc//lib/idlc/idl_parser.rb#1514
module Idl::Int12; end

# source://idlc//lib/idlc/idl_parser.rb#1517
module Idl::Int13; end

# source://idlc//lib/idlc/idl_parser.rb#1520
module Idl::Int14; end

# source://idlc//lib/idlc/idl_parser.rb#1523
module Idl::Int15; end

# source://idlc//lib/idlc/idl_parser.rb#1526
module Idl::Int16; end

# source://idlc//lib/idlc/idl_parser.rb#1484
module Idl::Int2; end

# source://idlc//lib/idlc/idl_parser.rb#1487
module Idl::Int3; end

# source://idlc//lib/idlc/idl_parser.rb#1490
module Idl::Int4; end

# source://idlc//lib/idlc/idl_parser.rb#1493
module Idl::Int5; end

# source://idlc//lib/idlc/idl_parser.rb#1496
module Idl::Int6; end

# source://idlc//lib/idlc/idl_parser.rb#1499
module Idl::Int7; end

# source://idlc//lib/idlc/idl_parser.rb#1502
module Idl::Int8; end

# source://idlc//lib/idlc/idl_parser.rb#1505
module Idl::Int9; end

# represents an integer literal
#
# source://idlc//lib/idlc/ast.rb#7153
class Idl::IntLiteralAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#7160
  sig { params(input: T.nilable(::String), interval: T.nilable(T::Range[::Integer]), text: ::String).void }
  def initialize(input, interval, text); end

  # source://idlc//lib/idlc/ast.rb#7157
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7167
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#142
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#103
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#7424
  sig { returns(::Integer) }
  def radix; end

  # source://idlc//lib/idlc/ast.rb#7407
  sig { returns(T::Boolean) }
  def signed?; end

  # source://idlc//lib/idlc/ast.rb#7165
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#7462
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#7395
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7398
  sig { override.returns(::String) }
  def to_idl_verbose; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#7193
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#7177
  def type_check(symtab); end

  # @return [Integer] the unsigned value of this literal (i.e., treating it as unsigned even if the signed specifier is present)
  #
  # source://idlc//lib/idlc/ast.rb#7314
  def unsigned_value; end

  # Return the compile-time-known value of the node
  #
  # source://idlc//lib/idlc/ast.rb#7267
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#7228
  def width(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#7485
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::IntLiteralAst)
    end
    def from_h(yaml, source_mapper); end

    # source://idlc//lib/idlc/ast.rb#7473
    def radix_to_verilog(r); end
  end
end

# source://idlc//lib/idlc/ast.rb#7063
module Idl::IntLiteralSyntaxNode
  # source://idlc//lib/idlc/ast.rb#7064
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16
module Idl::Isa0
  # source://idlc//lib/idlc/idl_parser.rb#21
  def definitions; end

  # source://idlc//lib/idlc/idl_parser.rb#17
  def version_string; end
end

# top-level AST node
#
# source://idlc//lib/idlc/ast.rb#1256
class Idl::IsaAst < ::Idl::AstNode
  # Add all the global symbols to symtab
  #
  # @param symtab [SymbolTable] symbol table
  #
  # source://idlc//lib/idlc/ast.rb#1283
  def add_global_symbols(symtab); end

  # @return [Array<AstNode>] List of all bitfield definitions
  #
  # source://idlc//lib/idlc/ast.rb#1269
  def bitfields; end

  # source://idlc//lib/idlc/ast.rb#1260
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1257
  def definitions; end

  # @return [Array<AstNode>] List of all enum definitions
  #
  # source://idlc//lib/idlc/ast.rb#1266
  def enums; end

  # @return [FetchAst] Fetch body
  #
  # source://idlc//lib/idlc/ast.rb#1278
  def fetch; end

  # @return [Array<AstNode>] List of all function definitions
  #
  # source://idlc//lib/idlc/ast.rb#1275
  def functions; end

  # @return [Array<AstNode>] List of all global variable definitions
  #
  # source://idlc//lib/idlc/ast.rb#1263
  def globals; end

  # replaces an include statement with the ast in that file, making
  # it a direct child of this IsaAst
  #
  # @param include_ast [IncludeStatementAst] The include, which must be a child of this IsaAst
  #
  # source://idlc//lib/idlc/ast.rb#1298
  def replace_include!(include_ast, isa_ast); end

  # @return [Array<AstNode>] List of all struct definitions
  #
  # source://idlc//lib/idlc/ast.rb#1272
  def structs; end

  # source://idlc//lib/idlc/ast.rb#1331
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1317
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#1308
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1338
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# @api private
#
# source://idlc//lib/idlc/ast.rb#1243
class Idl::IsaSyntaxNode < ::Idl::SyntaxNode
  # @api private
  #
  # source://idlc//lib/idlc/ast.rb#1244
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#15040
module Idl::Keyword0; end

# source://idlc//lib/idlc/idl_parser.rb#15043
module Idl::Keyword1; end

# source://idlc//lib/idlc/idl_parser.rb#15070
module Idl::Keyword10; end

# source://idlc//lib/idlc/idl_parser.rb#15073
module Idl::Keyword11; end

# source://idlc//lib/idlc/idl_parser.rb#15076
module Idl::Keyword12; end

# source://idlc//lib/idlc/idl_parser.rb#15079
module Idl::Keyword13; end

# source://idlc//lib/idlc/idl_parser.rb#15082
module Idl::Keyword14; end

# source://idlc//lib/idlc/idl_parser.rb#15085
module Idl::Keyword15; end

# source://idlc//lib/idlc/idl_parser.rb#15046
module Idl::Keyword2; end

# source://idlc//lib/idlc/idl_parser.rb#15049
module Idl::Keyword3; end

# source://idlc//lib/idlc/idl_parser.rb#15052
module Idl::Keyword4; end

# source://idlc//lib/idlc/idl_parser.rb#15055
module Idl::Keyword5; end

# source://idlc//lib/idlc/idl_parser.rb#15058
module Idl::Keyword6; end

# source://idlc//lib/idlc/idl_parser.rb#15061
module Idl::Keyword7; end

# source://idlc//lib/idlc/idl_parser.rb#15064
module Idl::Keyword8; end

# source://idlc//lib/idlc/idl_parser.rb#15067
module Idl::Keyword9; end

# represents assignment of multiple variable from a function call that returns multiple values
#
# for example:
#   (match_result, cfg) = pmp_match<access_size>(paddr);
#
# source://idlc//lib/idlc/ast.rb#3313
class Idl::MultiVariableAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # @return [MultiVariableAssignmentAst] a new instance of MultiVariableAssignmentAst
  #
  # source://idlc//lib/idlc/ast.rb#3335
  def initialize(input, interval, variables, function_call); end

  # source://idlc//lib/idlc/ast.rb#3317
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#3380
  def execute(symtab); end

  # "execute" the statement, forcing any variable assignments to an unknown state
  # This is used down unknown conditional paths.
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#3404
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#3333
  def function_call; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#71
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3344
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#3415
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#3412
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#3349
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#3332
  def variables; end

  # @return [Array<AstNode>] The variables being assigned, in order
  #
  # source://idlc//lib/idlc/ast.rb#3340
  def vars; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3423
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::MultiVariableAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3303
class Idl::MultiVariableAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3304
  def to_ast; end
end

# represents the declaration of multiple variables
#
# for example:
#   Bits<64> a, b;
#   Bits<64> a, b, c, d;
#
# source://idlc//lib/idlc/ast.rb#3447
class Idl::MultiVariableDeclarationAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#3463
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      type_name: T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst),
      var_names: T::Array[::Idl::IdAst]
    ).void
  end
  def initialize(input, interval, type_name, var_names); end

  # source://idlc//lib/idlc/ast.rb#3496
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#3451
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#180
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # mark this declaration as being in global scope
  #
  # source://idlc//lib/idlc/ast.rb#3470
  def make_global; end

  # source://idlc//lib/idlc/ast.rb#3507
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#3504
  sig { override.returns(::String) }
  def to_idl; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#3487
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#3480
  def type_check(symtab); end

  # @return [AstNode] Declared type
  #
  # source://idlc//lib/idlc/ast.rb#3457
  def type_name; end

  # @return [Array<AstNode>] Variable names
  #
  # source://idlc//lib/idlc/ast.rb#3460
  def var_name_nodes; end

  # @return [Array<String>] Variables being declared
  #
  # source://idlc//lib/idlc/ast.rb#3475
  def var_names; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3515
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::MultiVariableDeclarationAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3436
class Idl::MultiVariableDeclarationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3437
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#6220
class Idl::NoopAst < ::Idl::AstNode
  # @return [NoopAst] a new instance of NoopAst
  #
  # source://idlc//lib/idlc/ast.rb#6224
  def initialize; end

  # source://idlc//lib/idlc/ast.rb#6222
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#6232
  def execute(symtab); end

  # "execute" the statement, forcing any variable assignments to an unknown state
  # This is used down unknown conditional paths.
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#6235
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#17
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6242
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6239
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#6229
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6248
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::NoopAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/idl_parser.rb#3497
module Idl::P0BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#3498
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#3502
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3507
module Idl::P0BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#3508
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#3512
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3615
module Idl::P1BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#3616
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#3620
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3625
module Idl::P1BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#3626
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#3630
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3733
module Idl::P2BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#3734
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#3738
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3743
module Idl::P2BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#3744
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#3748
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3851
module Idl::P3BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#3852
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#3856
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3861
module Idl::P3BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#3862
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#3866
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4087
module Idl::P4BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4088
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4092
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4097
module Idl::P4BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4098
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4102
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4323
module Idl::P5BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4324
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4328
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4333
module Idl::P5BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4334
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4338
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3257
module Idl::P5BinaryOperator0; end

# source://idlc//lib/idlc/idl_parser.rb#4559
module Idl::P6BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4560
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4564
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4569
module Idl::P6BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4570
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4574
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4795
module Idl::P7BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4796
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4800
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4805
module Idl::P7BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4806
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4810
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3337
module Idl::P7BinaryOperator0; end

# source://idlc//lib/idlc/idl_parser.rb#5031
module Idl::P8BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5032
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#5036
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5041
module Idl::P8BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#5042
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#5046
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5267
module Idl::P9BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5268
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#5272
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5277
module Idl::P9BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#5278
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#5282
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5503
module Idl::ParenExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5504
  def e; end
end

# represents a parenthesized expression
#
# for example:
#  (a + b)
#
# source://idlc//lib/idlc/ast.rb#5211
class Idl::ParenExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # @return [ParenExpressionAst] a new instance of ParenExpressionAst
  #
  # source://idlc//lib/idlc/ast.rb#5217
  def initialize(input, interval, exp); end

  # source://idlc//lib/idlc/ast.rb#5215
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5219
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#137
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5221
  def invert(symtab); end

  # source://idlc//lib/idlc/ast.rb#5237
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#5234
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#39
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#5227
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#5224
  def type_check(symtab); end

  # Return the compile-time-known value of the node
  #
  # source://idlc//lib/idlc/ast.rb#5230
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5244
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ParenExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5201
class Idl::ParenExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5202
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#2619
class Idl::PcAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#2630
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      rval: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, rval); end

  # source://idlc//lib/idlc/ast.rb#2623
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @raise ValueError if some part of the statement cannot be executed at compile time
  #
  # source://idlc//lib/idlc/ast.rb#2636
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute(symtab); end

  # "execute" the statement, forcing any variable assignments to an unknown state
  # This is used down unknown conditional paths.
  #
  # @raise ValueError if some part of the statement cannot be executed at compile time
  #
  # source://idlc//lib/idlc/ast.rb#2640
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#247
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2627
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#2653
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#2650
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  #
  # source://idlc//lib/idlc/ast.rb#2644
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2660
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::PcAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2613
class Idl::PcAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2614
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#6455
module Idl::PostDec0
  # source://idlc//lib/idlc/idl_parser.rb#6456
  def rval; end
end

# represents a post-decrement expression
#
# for example:
#   i--
#
# source://idlc//lib/idlc/ast.rb#5509
class Idl::PostDecrementExpressionAst < ::Idl::AstNode
  include ::Idl::Executable

  # @return [PostDecrementExpressionAst] a new instance of PostDecrementExpressionAst
  #
  # source://idlc//lib/idlc/ast.rb#5518
  def initialize(input, interval, rval); end

  # source://idlc//lib/idlc/ast.rb#5513
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#5535
  def execute(symtab); end

  # "execute" the statement, forcing any variable assignments to an unknown state
  # This is used down unknown conditional paths.
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#5551
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#50
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5516
  sig { returns(T.any(::Idl::BuiltinVariableAst, ::Idl::IdAst, ::Idl::IntLiteralAst, ::Idl::StringLiteralAst)) }
  def rval; end

  # source://idlc//lib/idlc/ast.rb#5559
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5556
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5530
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5522
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5566
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::PostDecrementExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5499
class Idl::PostDecrementExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5500
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#6512
module Idl::PostInc0
  # source://idlc//lib/idlc/idl_parser.rb#6513
  def rval; end
end

# represents a post-increment expression
#
# for example:
#   i++
#
# source://idlc//lib/idlc/ast.rb#5664
class Idl::PostIncrementExpressionAst < ::Idl::AstNode
  include ::Idl::Executable

  # @return [PostIncrementExpressionAst] a new instance of PostIncrementExpressionAst
  #
  # source://idlc//lib/idlc/ast.rb#5672
  def initialize(input, interval, rval); end

  # source://idlc//lib/idlc/ast.rb#5668
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#5692
  def execute(symtab); end

  # "execute" the statement, forcing any variable assignments to an unknown state
  # This is used down unknown conditional paths.
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#5709
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#45
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5670
  def rval; end

  # source://idlc//lib/idlc/ast.rb#5718
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#5715
  sig { override.returns(::String) }
  def to_idl; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#5687
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#5677
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5725
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::PostIncrementExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5654
class Idl::PostIncrementExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5655
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#5583
module Idl::ReplicationExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5584
  def n; end

  # source://idlc//lib/idlc/idl_parser.rb#5588
  def v; end
end

# represents a replication expression
#
# for example:
#   {5{5'd3}}
#
# source://idlc//lib/idlc/ast.rb#5427
class Idl::ReplicationExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # @return [ReplicationExpressionAst] a new instance of ReplicationExpressionAst
  #
  # source://idlc//lib/idlc/ast.rb#5437
  def initialize(input, interval, n, v); end

  # source://idlc//lib/idlc/ast.rb#5431
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#277
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5434
  def n; end

  # source://idlc//lib/idlc/ast.rb#5478
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#5475
  sig { override.returns(::String) }
  def to_idl; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#5463
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#5442
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5435
  def v; end

  # Return the compile-time-known value of the node
  #
  # source://idlc//lib/idlc/ast.rb#5454
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5486
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ReplicationExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5417
class Idl::ReplicationExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5418
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#12698
module Idl::ReturnExpression0
  # source://idlc//lib/idlc/idl_parser.rb#12699
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#12704
module Idl::ReturnExpression1
  # source://idlc//lib/idlc/idl_parser.rb#12705
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#12710
module Idl::ReturnExpression2
  # source://idlc//lib/idlc/idl_parser.rb#12711
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#12715
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#12720
module Idl::ReturnExpression3
  # source://idlc//lib/idlc/idl_parser.rb#12721
  def vals; end
end

# source://idlc//lib/idlc/ast.rb#6616
class Idl::ReturnExpressionAst < ::Idl::AstNode
  include ::Idl::Returns

  # @return [ReturnExpressionAst] a new instance of ReturnExpressionAst
  #
  # source://idlc//lib/idlc/ast.rb#6624
  def initialize(input, interval, return_nodes); end

  # source://idlc//lib/idlc/ast.rb#6620
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6668
  def enclosing_function; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#30
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#115
  def gen_option_adoc; end

  # @return [Type] The actual return type
  #
  # source://idlc//lib/idlc/ast.rb#6641
  def return_type(symtab); end

  # @return [Array<Type>] List of actual return types
  #
  # source://idlc//lib/idlc/ast.rb#6630
  def return_types(symtab); end

  # Evaluate the compile-time return value of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on the taken path), execute the node
  # and update the symtab
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  # @return [Integer] The return value, if it is integral
  # @return [Boolean] The return value, if it is boolean
  # @return [nil] if the return value is not compile-time-known
  #
  # source://idlc//lib/idlc/ast.rb#6673
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#6622
  def return_value_nodes; end

  # Evaluate all possible compile-time return values of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on a possible path), execute the node
  # and update the symtab
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  # @return [Array<Integer>] The possible return values. Will be an empty array if there are no return values
  # @return [Array<Boolean>] The possible return values. Will be an empty array if there are no return values
  #
  # source://idlc//lib/idlc/ast.rb#6684
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#6698
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6695
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#6653
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6705
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ReturnExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6603
class Idl::ReturnExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6604
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#12890
module Idl::ReturnStatement0
  # source://idlc//lib/idlc/idl_parser.rb#12895
  def expression; end

  # source://idlc//lib/idlc/idl_parser.rb#12891
  def return_expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#12901
module Idl::ReturnStatement1
  # source://idlc//lib/idlc/idl_parser.rb#12902
  def return_expression; end
end

# represents a function return statement
#
# for example:
#   return 5;
#   return X[rs1] + 1;
#
# source://idlc//lib/idlc/ast.rb#6527
class Idl::ReturnStatementAst < ::Idl::AstNode
  include ::Idl::Returns

  # @return [ReturnStatementAst] a new instance of ReturnStatementAst
  #
  # source://idlc//lib/idlc/ast.rb#6537
  def initialize(input, interval, return_expression); end

  # source://idlc//lib/idlc/ast.rb#6531
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6566
  def enclosing_function; end

  # @return [Type] The expected return type (as defined by the encolsing function)
  #
  # source://idlc//lib/idlc/ast.rb#6552
  def expected_return_type(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#271
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#77
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/find_return_values.rb#19
  def pass_find_return_values(values, current_conditions, symtab); end

  # source://idlc//lib/idlc/ast.rb#6533
  def return_expression; end

  # @return [Type] The actual return type
  #
  # source://idlc//lib/idlc/ast.rb#6547
  def return_type(symtab); end

  # @return [Array<Type>] List of actual return types
  #
  # source://idlc//lib/idlc/ast.rb#6542
  def return_types(symtab); end

  # Evaluate the compile-time return value of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on the taken path), execute the node
  # and update the symtab
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  # @return [Integer] The return value, if it is integral
  # @return [Boolean] The return value, if it is boolean
  # @return [nil] if the return value is not compile-time-known
  #
  # source://idlc//lib/idlc/ast.rb#6571
  def return_value(symtab); end

  # @return [Array<AstNode>] List of return value nodes
  #
  # source://idlc//lib/idlc/ast.rb#6562
  def return_value_nodes; end

  # Evaluate all possible compile-time return values of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on a possible path), execute the node
  # and update the symtab
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  # @return [Array<Integer>] The possible return values. Will be an empty array if there are no return values
  # @return [Array<Boolean>] The possible return values. Will be an empty array if there are no return values
  #
  # source://idlc//lib/idlc/ast.rb#6576
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#6584
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6581
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#6557
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6591
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ReturnStatementAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6516
class Idl::ReturnStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6517
  def to_ast; end
end

# interface for nodes that *might* return a value in a function body
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://idlc//lib/idlc/ast.rb#626
module Idl::Returns
  abstract!

  # source://idlc//lib/idlc/ast.rb#667
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def expected_return_type(symtab); end

  # returns the return type, or nil if the type is void
  #
  # @abstract
  #
  # source://idlc//lib/idlc/ast.rb#644
  sig { abstract.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # Evaluate the compile-time return value of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on the taken path), execute the node
  # and update the symtab
  #
  # return value or nil if there is no return in a potentionally-returning node (like an if body)
  # Evaluate the compile-time return value of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on the taken path), execute the node
  # and update the symtab
  #
  # @abstract
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  #
  # source://idlc//lib/idlc/ast.rb#649
  sig do
    abstract
      .params(
        symtab: ::Idl::SymbolTable
      ).returns(T.nilable(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)])))
  end
  def return_value(symtab); end

  # Evaluate all possible compile-time return values of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on a possible path), execute the node
  # and update the symtab
  # Evaluate all possible compile-time return values of this node, or, if the node does not return
  # (e.g., because it is an IfAst but there is no return on a possible path), execute the node
  # and update the symtab
  #
  # @abstract
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  # @raise ValueError if, during evaluation, a node without a compile-time value is found
  #
  # source://idlc//lib/idlc/ast.rb#663
  sig do
    abstract
      .params(
        symtab: ::Idl::SymbolTable
      ).returns(T::Array[T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)])])
  end
  def return_values(symtab); end
end

# interface for a parameter that may only be known at runtime
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://idlc//lib/idlc/interfaces.rb#13
module Idl::RuntimeParam
  include ::Kernel

  interface!

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#27
  sig { abstract.returns(::String) }
  def description; end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#48
  sig { abstract.returns(::Idl::Type) }
  def idl_type; end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#24
  sig { abstract.returns(::String) }
  def name; end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#33
  sig { abstract.returns(::Idl::Schema) }
  def schema; end


  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#45
  sig do
    abstract
      .returns(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean))
  end
  def value; end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#42
  sig { abstract.returns(T::Boolean) }
  def value_known?; end
end

# source://idlc//lib/idlc/interfaces.rb#20
Idl::RuntimeParam::ValueType = T.type_alias { T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean) }

# interface for R-values (e.g., expressions that have a value)
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://idlc//lib/idlc/ast.rb#718
module Idl::Rvalue
  abstract!

  # source://idlc//lib/idlc/ast.rb#768
  sig { params(symtab: ::Idl::SymbolTable).returns(T.any(::Integer, ::Symbol)) }
  def max_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#778
  sig { params(symtab: ::Idl::SymbolTable).returns(T.any(::Integer, ::Symbol)) }
  def min_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#803
  sig { params(value: ::Integer, width: ::Integer, signed: T::Boolean).returns(::Integer) }
  def truncate(value, width, signed); end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @abstract
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  #
  # source://idlc//lib/idlc/ast.rb#741
  sig { abstract.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # Return the compile-time-known value of the node
  # Return the compile-time-known value of the node
  #
  # @abstract
  #
  # source://idlc//lib/idlc/ast.rb#765
  sig do
    abstract
      .params(
        symtab: ::Idl::SymbolTable
      ).returns(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)]))
  end
  def value(symtab); end

  # Return a complete list of possible compile-time-known values of the node, or raise a ValueError if
  # the full list cannot be determined
  #
  # For most AstNodes, this will just be a single-entry array
  # Return a complete list of possible compile-time-known values of the node, or raise a ValueError if
  # the full list cannot be determined
  #
  # For most AstNodes, this will just be a single-entry array
  #
  # source://idlc//lib/idlc/ast.rb#800
  sig do
    params(
      symtab: ::Idl::SymbolTable
    ).returns(T::Array[T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)])])
  end
  def values(symtab); end
end

# source://idlc//lib/idlc/ast.rb#820
Idl::RvalueAst = T.type_alias { T.all(::Idl::AstNode, ::Idl::Rvalue) }

# basic interface for objects that are described with JSON Schema
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://idlc//lib/idlc/interfaces.rb#52
module Idl::Schema
  interface!

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#61
  sig { abstract.returns(::Integer) }
  def max_val; end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#58
  sig { abstract.returns(T::Boolean) }
  def max_val_known?; end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#67
  sig { abstract.returns(::Integer) }
  def min_val; end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#64
  sig { abstract.returns(T::Boolean) }
  def min_val_known?; end

  # @abstract
  #
  # source://idlc//lib/idlc/interfaces.rb#70
  sig { abstract.returns(::Idl::Type) }
  def to_idl_type; end
end

# source://idlc//lib/idlc/ast.rb#4239
class Idl::SignCastAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # @return [SignCastAst] a new instance of SignCastAst
  #
  # source://idlc//lib/idlc/ast.rb#4247
  def initialize(input, interval, exp); end

  # source://idlc//lib/idlc/ast.rb#4243
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4245
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#163
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#4276
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#4273
  sig { override.returns(::String) }
  def to_idl; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#4255
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#4250
  def type_check(symtab); end

  # Return the compile-time-known value of the node
  #
  # source://idlc//lib/idlc/ast.rb#4258
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4283
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::SignCastAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4233
class Idl::SignCastSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4234
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#12362
module Idl::SingleDeclaration0
  # source://idlc//lib/idlc/idl_parser.rb#12363
  def ary_size_decl; end
end

# source://idlc//lib/idlc/idl_parser.rb#12368
module Idl::SingleDeclaration1
  # source://idlc//lib/idlc/idl_parser.rb#12377
  def ary_size; end

  # source://idlc//lib/idlc/idl_parser.rb#12373
  def id; end

  # source://idlc//lib/idlc/idl_parser.rb#12369
  def type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#11931
module Idl::SingleDeclarationWithInitialization0
  # source://idlc//lib/idlc/idl_parser.rb#11940
  def ary_size; end

  # source://idlc//lib/idlc/idl_parser.rb#11936
  def id; end

  # source://idlc//lib/idlc/idl_parser.rb#11944
  def rval; end

  # source://idlc//lib/idlc/idl_parser.rb#11932
  def type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#16722
module Idl::Space0
  # @return [Boolean]
  #
  # source://idlc//lib/idlc/idl_parser.rb#16723
  def space?; end
end

# source://idlc//lib/idlc/idl_parser.rb#12462
module Idl::Statement0
  # source://idlc//lib/idlc/idl_parser.rb#12463
  def a; end

  # source://idlc//lib/idlc/idl_parser.rb#12467
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#12473
module Idl::Statement1
  # source://idlc//lib/idlc/idl_parser.rb#12474
  def a; end
end

# represents a simple, one-line statement
#
# for example:
#   Bits<64> new_variable;
#   new_variable = 4;
#   func();
#
# source://idlc//lib/idlc/ast.rb#6261
class Idl::StatementAst < ::Idl::AstNode
  include ::Idl::Executable

  # @return [StatementAst] a new instance of StatementAst
  #
  # source://idlc//lib/idlc/ast.rb#6269
  def initialize(input, interval, action); end

  # source://idlc//lib/idlc/ast.rb#6267
  def action; end

  # source://idlc//lib/idlc/ast.rb#6265
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#6279
  def execute(symtab); end

  # "execute" the statement, forcing any variable assignments to an unknown state
  # This is used down unknown conditional paths.
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#6289
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#259
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#83
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/prune.rb#222
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#82
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#69
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6303
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#6300
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#6274
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6310
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::StatementAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6214
class Idl::StatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6215
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16625
module Idl::String0; end

# source://idlc//lib/idlc/idl_parser.rb#16628
module Idl::String1; end

# represents a string literal
#
# @example
#   ">= 1.0"
#   "sequential_bytes"
#
# source://idlc//lib/idlc/ast.rb#7013
class Idl::StringLiteralAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#7020
  sig { params(input: T.nilable(::String), interval: T.nilable(T::Range[::Integer]), text: ::String).void }
  def initialize(input, interval, text); end

  # source://idlc//lib/idlc/ast.rb#7017
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#55
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7027
  sig { override.returns(::String) }
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#7045
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#7042
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7032
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#7030
  def type_check(_symtab); end

  # Return the compile-time-known value of the node
  #
  # source://idlc//lib/idlc/ast.rb#7037
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#7052
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::StringLiteralAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#7001
module Idl::StringLiteralSyntaxNode
  # source://idlc//lib/idlc/ast.rb#7002
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#1004
Idl::StringType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/idl_parser.rb#1191
module Idl::StructDefinition0
  # source://idlc//lib/idlc/idl_parser.rb#1196
  def id; end

  # source://idlc//lib/idlc/idl_parser.rb#1192
  def type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#1202
module Idl::StructDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#1207
  def member; end

  # source://idlc//lib/idlc/idl_parser.rb#1203
  def user_type_name; end
end

# Structure declaration
#
# for example, this maps to a StructDefinitionAst:
#
# struct TranslationResult {
#   Bits<PHYS_ADDR_SIZE> paddr;
#   Pbmt pbmt;
#   ...
# }
#
# source://idlc//lib/idlc/ast.rb#2258
class Idl::StructDefinitionAst < ::Idl::AstNode
  include ::Idl::Declaration

  # @return [StructDefinitionAst] a new instance of StructDefinitionAst
  #
  # source://idlc//lib/idlc/ast.rb#2273
  def initialize(input, interval, name, member_types, member_names); end

  # source://idlc//lib/idlc/ast.rb#2301
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#2271
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # @return [Array<String>] Member names
  #
  # source://idlc//lib/idlc/ast.rb#2268
  def member_names; end

  # @param name [String] Member name
  # @param symtab [SymbolTable] Context
  # @return [Type] Type of member +name+
  # @return [nil] if there is no member +name+
  #
  # source://idlc//lib/idlc/ast.rb#2312
  def member_type(name, symtab); end

  # @return [Array<AstNode>] Types of each member
  #
  # source://idlc//lib/idlc/ast.rb#2265
  def member_types; end

  # @return [String] Struct name
  #
  # source://idlc//lib/idlc/ast.rb#2262
  def name; end

  # @return [Integer] Number of members
  #
  # source://idlc//lib/idlc/ast.rb#2319
  def num_members; end

  # source://idlc//lib/idlc/ast.rb#2331
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2322
  sig { override.returns(::String) }
  def to_idl; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#2290
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#2282
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2344
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2237
class Idl::StructDefinitionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2238
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#599
class Idl::StructType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#604
  sig { params(type_name: ::String, member_types: T::Array[::Idl::Type], member_names: T::Array[::String]).void }
  def initialize(type_name, member_types, member_names); end

  # source://idlc//lib/idlc/type.rb#614
  def clone; end

  # source://idlc//lib/idlc/type.rb#618
  def default; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/type.rb#626
  def member?(name); end

  # source://idlc//lib/idlc/type.rb#628
  def member_type(member_name); end

  # source://idlc//lib/idlc/type.rb#612
  sig { returns(::String) }
  def name; end

  # does this struct have any members whose type depends on a runtime parameter?
  #
  # @return [Boolean]
  #
  # source://idlc//lib/idlc/type.rb#636
  def runtime?; end

  # source://idlc//lib/idlc/type.rb#601
  sig { returns(::String) }
  def type_name; end
end

# scoped symbol table holding known symbols at a current point in parsing
#
# source://idlc//lib/idlc/symbol_table.rb#122
class Idl::SymbolTable
  # source://idlc//lib/idlc/symbol_table.rb#237
  sig do
    params(
      mxlen: T.nilable(::Integer),
      possible_xlens_cb: T.nilable(T.proc.returns(T::Array[::Integer])),
      builtin_global_vars: T::Array[::Idl::Var],
      builtin_enums: T::Array[::Idl::SymbolTable::EnumDef],
      builtin_funcs: T.nilable(::Idl::SymbolTable::BuiltinFunctionCallbacks),
      csrs: T::Array[::Idl::Csr],
      params: T::Array[::Idl::RuntimeParam],
      name: ::String
    ).void
  end
  def initialize(mxlen: T.unsafe(nil), possible_xlens_cb: T.unsafe(nil), builtin_global_vars: T.unsafe(nil), builtin_enums: T.unsafe(nil), builtin_funcs: T.unsafe(nil), csrs: T.unsafe(nil), params: T.unsafe(nil), name: T.unsafe(nil)); end

  # add a new symbol at the outermost scope
  #
  # @param name [#to_s] Symbol name
  # @param var [Object] Symbol object (usually a Var or a Type)
  #
  # source://idlc//lib/idlc/symbol_table.rb#409
  def add(name, var); end

  # add a new symbol at the outermost scope, unless that symbol is already defined
  #
  # @param name [#to_s] Symbol name
  # @param var [Object] Symbol object (usually a Var or a Type)
  # @raise [DuplicationSymError] if 'name' is already in the symbol table
  #
  # source://idlc//lib/idlc/symbol_table.rb#418
  def add!(name, var); end

  # add to the scope above the tail, and make sure name is unique at that scope
  #
  # source://idlc//lib/idlc/symbol_table.rb#435
  def add_above!(name, var); end

  # add to the scope at level, and make sure name is unique at that scope
  #
  # source://idlc//lib/idlc/symbol_table.rb#444
  def add_at!(level, name, var); end

  # @return [Boolean] true if the symbol table is at the global scope
  #
  # source://idlc//lib/idlc/symbol_table.rb#468
  def at_global_scope?; end

  # Returns the value of attribute builtin_funcs.
  #
  # source://idlc//lib/idlc/symbol_table.rb#206
  def builtin_funcs; end

  # source://idlc//lib/idlc/symbol_table.rb#343
  def callstack; end

  # source://idlc//lib/idlc/symbol_table.rb#215
  sig { params(csr_name: ::String).returns(T.nilable(::Idl::Csr)) }
  def csr(csr_name); end

  # source://idlc//lib/idlc/symbol_table.rb#209
  sig { params(csr_name: ::String).returns(T::Boolean) }
  def csr?(csr_name); end

  # source://idlc//lib/idlc/symbol_table.rb#212
  sig { returns(T::Hash[::String, ::Idl::Csr]) }
  def csr_hash; end

  # @return [SymbolTable] a deep clone of this SymbolTable
  #
  # source://idlc//lib/idlc/symbol_table.rb#518
  def deep_clone(clone_values: T.unsafe(nil), freeze_global: T.unsafe(nil)); end

  # do a deep freeze to protect the sym table and all its entries from modification
  #
  # source://idlc//lib/idlc/symbol_table.rb#287
  def deep_freeze; end

  # delete a new symbol at the outermost scopea
  #
  # @param name [#to_s] Symbol name
  # @param var [Object] Symbol object (usually a Var or a Type)
  #
  # source://idlc//lib/idlc/symbol_table.rb#428
  def del(name); end

  # searches the symbol table scope-by-scope to find all entries for which the block returns true
  #
  # @param single_scope [Boolean] If true, stop searching more scope as soon as there are matches
  # @raise [ArgumentError]
  # @return [Array<Object>] All matches
  # @yieldparam obj [Object] A object stored in the symbol table
  # @yieldreturn [Boolean] Whether or not the object is the one you are looking for
  #
  # source://idlc//lib/idlc/symbol_table.rb#389
  def find_all(single_scope: T.unsafe(nil), &block); end

  # searches the symbol table scope-by-scope to find 'name'
  #
  # @return [Object] A symbol named 'name', or nil if not found
  #
  # source://idlc//lib/idlc/symbol_table.rb#359
  def get(name); end

  # @raise [ArgumentError]
  #
  # source://idlc//lib/idlc/symbol_table.rb#367
  def get_from(name, level); end

  # @return [Object] the symbol named 'name' from global scope, or nil if not found
  #
  # source://idlc//lib/idlc/symbol_table.rb#379
  def get_global(name); end

  # @return [SymbolTable] a mutable clone of the global scope of this SymbolTable
  #
  # source://idlc//lib/idlc/symbol_table.rb#473
  def global_clone; end

  # source://idlc//lib/idlc/symbol_table.rb#136
  def hash; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/symbol_table.rb#515
  def in_use?; end

  # source://idlc//lib/idlc/symbol_table.rb#282
  sig { returns(::String) }
  def inspect; end

  # @return [Boolean] whether or not any symbol 'name' is defined at any level in the symbol table
  #
  # source://idlc//lib/idlc/symbol_table.rb#348
  def key?(name); end

  # source://idlc//lib/idlc/symbol_table.rb#352
  def keys_pretty; end

  # @return [Integer] Number of scopes on the symbol table (global at 1)
  #
  # source://idlc//lib/idlc/symbol_table.rb#453
  def levels; end

  # source://idlc//lib/idlc/symbol_table.rb#159
  sig { returns(T::Boolean) }
  def multi_xlen?; end

  # source://idlc//lib/idlc/symbol_table.rb#128
  sig { returns(T.nilable(::Integer)) }
  def mxlen; end

  # source://idlc//lib/idlc/symbol_table.rb#131
  sig { returns(::String) }
  def name; end

  # source://idlc//lib/idlc/symbol_table.rb#218
  sig { params(param_name: ::String).returns(T.nilable(::Idl::RuntimeParam)) }
  def param(param_name); end

  # source://idlc//lib/idlc/symbol_table.rb#221
  sig { returns(T::Hash[::String, ::Idl::RuntimeParam]) }
  def params_hash; end

  # pops the top of the scope stack
  #
  # source://idlc//lib/idlc/symbol_table.rb#333
  def pop; end

  # source://idlc//lib/idlc/symbol_table.rb#167
  sig { returns(T::Array[::Integer]) }
  def possible_xlens; end

  # pretty-print the symbol table contents
  #
  # source://idlc//lib/idlc/symbol_table.rb#459
  sig { void }
  def print; end

  # pushes a new scope
  #
  # @return [SymbolTable] self
  #
  # source://idlc//lib/idlc/symbol_table.rb#321
  def push(ast); end

  # source://idlc//lib/idlc/symbol_table.rb#504
  def release; end

  class << self
    # some ugliness to capture proc types
    #
    # @see https://sorbet.org/docs/procs#what-can-i-do-for-better-proc-and-lambda-types
    #
    # source://idlc//lib/idlc/symbol_table.rb#184
    sig do
      params(
        blk: T.proc.params(arg0: ::String).returns(T.nilable(T::Boolean))
      ).returns(T.proc.params(arg0: ::String).returns(T.nilable(T::Boolean)))
    end
    def make_implemented_callback(&blk); end

    # some ugliness to capture proc types
    #
    # @see https://sorbet.org/docs/procs#what-can-i-do-for-better-proc-and-lambda-types
    #
    # source://idlc//lib/idlc/symbol_table.rb#198
    sig do
      params(
        blk: T.proc.params(arg0: ::Integer).returns(T.nilable(T::Boolean))
      ).returns(T.proc.params(arg0: ::Integer).returns(T.nilable(T::Boolean)))
    end
    def make_implemented_csr_callback(&blk); end

    # some ugliness to capture proc types
    #
    # @see https://sorbet.org/docs/procs#what-can-i-do-for-better-proc-and-lambda-types
    #
    # source://idlc//lib/idlc/symbol_table.rb#191
    sig do
      params(
        blk: T.proc.params(arg0: ::String, arg1: ::String).returns(T.nilable(T::Boolean))
      ).returns(T.proc.params(arg0: ::String, arg1: ::String).returns(T.nilable(T::Boolean)))
    end
    def make_implemented_version_callback(&blk); end
  end
end

# source://idlc//lib/idlc/symbol_table.rb#200
class Idl::SymbolTable::BuiltinFunctionCallbacks < ::T::Struct
  prop :implemented, T.proc.params(arg0: ::String).returns(T.nilable(T::Boolean))
  prop :implemented_version, T.proc.params(arg0: ::String, arg1: ::String).returns(T.nilable(T::Boolean))
  prop :implemented_csr, T.proc.params(arg0: ::Integer).returns(T.nilable(T::Boolean))

  class << self
    # source://sorbet-runtime/0.6.12690/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://idlc//lib/idlc/symbol_table.rb#133
class Idl::SymbolTable::DuplicateSymError < ::StandardError; end

# source://idlc//lib/idlc/symbol_table.rb#142
class Idl::SymbolTable::EnumDef < ::T::Struct
  prop :name, ::String
  prop :element_values, T::Array[::Integer]
  prop :element_names, T::Array[::String]

  # source://idlc//lib/idlc/symbol_table.rb#150
  sig { params(name: ::String, element_values: T::Array[::Integer], element_names: T::Array[::String]).void }
  def initialize(name:, element_values:, element_names:); end

  class << self
    # source://sorbet-runtime/0.6.12690/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://idlc//lib/idlc/symbol_table.rb#179
Idl::SymbolTable::ImplementedCallbackType = T.type_alias { T.proc.params(arg0: ::String).returns(T.nilable(T::Boolean)) }

# source://idlc//lib/idlc/symbol_table.rb#193
Idl::SymbolTable::ImplementedCsrCallbackType = T.type_alias { T.proc.params(arg0: ::Integer).returns(T.nilable(T::Boolean)) }

# source://idlc//lib/idlc/symbol_table.rb#186
Idl::SymbolTable::ImplementedVersionCallbackType = T.type_alias { T.proc.params(arg0: ::String, arg1: ::String).returns(T.nilable(T::Boolean)) }

# source://idlc//lib/idlc/symbol_table.rb#161
class Idl::SymbolTable::MemoizedState < ::T::Struct
  prop :possible_xlens, T.nilable(T::Array[::Integer])
  prop :params_hash, T.nilable(T::Hash[::String, ::Idl::RuntimeParam])

  class << self
    # source://sorbet-runtime/0.6.12690/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://idlc//lib/idlc/symbol_table.rb#156
Idl::SymbolTable::PossibleXlensCallbackType = T.type_alias { T.proc.returns(T::Array[::Integer]) }

# source://idlc//lib/idlc/syntax_node.rb#49
class Idl::SyntaxNode < ::Treetop::Runtime::SyntaxNode
  # source://idlc//lib/idlc/syntax_node.rb#54
  sig { overridable.returns(::Idl::AstNode) }
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#3969
module Idl::TemplateSafeP3BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#3970
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#3974
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3979
module Idl::TemplateSafeP3BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#3980
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#3984
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4205
module Idl::TemplateSafeP4BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4206
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4210
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4215
module Idl::TemplateSafeP4BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4216
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4220
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4441
module Idl::TemplateSafeP5BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4442
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4446
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4451
module Idl::TemplateSafeP5BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4452
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4456
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4677
module Idl::TemplateSafeP6BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4678
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4682
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4687
module Idl::TemplateSafeP6BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4688
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4692
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4913
module Idl::TemplateSafeP7BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4914
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4918
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4923
module Idl::TemplateSafeP7BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4924
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4928
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5149
module Idl::TemplateSafeP8BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5150
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#5154
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5159
module Idl::TemplateSafeP8BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#5160
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#5164
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5385
module Idl::TemplateSafeP9BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5386
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#5390
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5395
module Idl::TemplateSafeP9BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#5396
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#5400
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#7889
module Idl::TemplateSafeTernaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#7890
  def e; end

  # source://idlc//lib/idlc/idl_parser.rb#7898
  def f; end

  # source://idlc//lib/idlc/idl_parser.rb#7894
  def t; end
end

# source://idlc//lib/idlc/idl_parser.rb#7768
module Idl::TernaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#7769
  def e; end

  # source://idlc//lib/idlc/idl_parser.rb#7777
  def f; end

  # source://idlc//lib/idlc/idl_parser.rb#7773
  def t; end
end

# Represents a ternary operator
#
# for example:
#   condition ? a : b
#   (a < b) ? c : d
#
# source://idlc//lib/idlc/ast.rb#6089
class Idl::TernaryOperatorExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # @return [TernaryOperatorExpressionAst] a new instance of TernaryOperatorExpressionAst
  #
  # source://idlc//lib/idlc/ast.rb#6099
  def initialize(input, interval, condition, true_expression, false_expression); end

  # source://idlc//lib/idlc/ast.rb#6095
  def condition; end

  # source://idlc//lib/idlc/ast.rb#6093
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6097
  def false_expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#186
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#123
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/prune.rb#456
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#6191
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#6188
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6096
  def true_expression; end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#6131
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#6104
  def type_check(symtab); end

  # Return the compile-time-known value of the node
  #
  # source://idlc//lib/idlc/ast.rb#6172
  def value(symtab); end

  # Return a complete list of possible compile-time-known values of the node, or raise a ValueError if
  # the full list cannot be determined
  #
  # For most AstNodes, this will just be a single-entry array
  #
  # @param symtab [SymbolTable] The context for the evaluation
  # @return [Array<Integer>] The complete list of compile-time-known values, when they are integral
  # @return [Array<Boolean>] The complete list of compile-time-known values, when they are booleans
  # @return [AstNode::ValueError] if the list of values is not knowable at compile time
  #
  # source://idlc//lib/idlc/ast.rb#6177
  def values(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6200
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::TernaryOperatorExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6078
class Idl::TernaryOperatorExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6079
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#872
class Idl::TrueExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#876
  sig { params(input: ::String, interval: T::Range[::Integer]).void }
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#881
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#148
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#89
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#896
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#893
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#66
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#887
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#884
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#890
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::TrueClass) }
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#902
    sig do
      override
        .params(
          yaml: T::Hash[::String, T.untyped],
          source_mapper: T::Hash[::String, ::String]
        ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#868
class Idl::TrueExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#869
  def to_ast; end
end

# Data types
#
# source://idlc//lib/idlc/type.rb#15
class Idl::Type
  # @return [Type] a new instance of Type
  #
  # source://idlc//lib/idlc/type.rb#132
  def initialize(kind, qualifiers: T.unsafe(nil), width: T.unsafe(nil), width_ast: T.unsafe(nil), max_width: T.unsafe(nil), sub_type: T.unsafe(nil), name: T.unsafe(nil), tuple_types: T.unsafe(nil), return_type: T.unsafe(nil), arguments: T.unsafe(nil), enum_class: T.unsafe(nil), csr: T.unsafe(nil)); end

  # source://idlc//lib/idlc/type.rb#48
  def ==(other); end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/type.rb#397
  def ary?; end

  # given an N-dimensional array type, return the primitive type
  #
  # source://idlc//lib/idlc/type.rb#248
  def ary_type(ary); end

  # source://idlc//lib/idlc/type.rb#173
  def clone; end

  # returns true if 'type' can be compared (e.g., >=, <, etc) to self
  # 'type' can be a Type object or a kind (as a Symbol)
  #
  # @return [Boolean]
  #
  # source://idlc//lib/idlc/type.rb#188
  def comparable_to?(type); end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/type.rb#401
  def const?; end

  # returns true if self can be converted to 'type'
  # 'type' can be a Type object or a kind (as a Symbol)
  #
  # @return [Boolean]
  #
  # source://idlc//lib/idlc/type.rb#258
  def convertable_to?(type); end

  # source://idlc//lib/idlc/type.rb#69
  def default; end

  # source://idlc//lib/idlc/type.rb#111
  sig { returns(::Idl::EnumerationType) }
  def enum_class; end

  # returns true if identical to type, excluding qualifiers
  #
  # @return [Boolean]
  #
  # source://idlc//lib/idlc/type.rb#220
  def equal_to?(type); end

  # source://idlc//lib/idlc/type.rb#347
  def fully_qualified_name; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/type.rb#413
  def global?; end

  # true for any type that can generally be treated as a scalar integer
  #
  # source://idlc//lib/idlc/type.rb#44
  sig { returns(T::Boolean) }
  def integral?; end

  # source://idlc//lib/idlc/type.rb#93
  sig { returns(::Symbol) }
  def kind; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/type.rb#421
  def known?; end

  # make a clone of this Type, add a constant qualifier, and return the new type
  #
  # source://idlc//lib/idlc/type.rb#439
  sig { returns(::Idl::Type) }
  def make_const; end

  # make this Type constant, and return self
  #
  # source://idlc//lib/idlc/type.rb#432
  sig { returns(::Idl::Type) }
  def make_const!; end

  # source://idlc//lib/idlc/type.rb#444
  def make_global; end

  # source://idlc//lib/idlc/type.rb#449
  def make_known; end

  # source://idlc//lib/idlc/type.rb#425
  def make_signed; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/type.rb#405
  def mutable?; end

  # source://idlc//lib/idlc/type.rb#379
  def name; end

  # source://idlc//lib/idlc/type.rb#96
  sig { returns(T::Array[::Symbol]) }
  def qualifiers; end

  # source://idlc//lib/idlc/type.rb#113
  def qualify(qualifier); end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/type.rb#61
  def runtime?; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/type.rb#409
  def signed?; end

  # source://idlc//lib/idlc/type.rb#105
  sig { returns(::Idl::Type) }
  def sub_type; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/type.rb#417
  def template_var?; end

  # return IDL representation of the type
  #
  # source://idlc//lib/idlc/type.rb#327
  sig { returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/type.rb#347
  def to_s; end

  # source://idlc//lib/idlc/type.rb#108
  sig { returns(T::Array[::Idl::Type]) }
  def tuple_types; end

  # source://idlc//lib/idlc/type.rb#99
  sig { returns(T.any(::Integer, ::Symbol)) }
  def width; end

  # source://idlc//lib/idlc/type.rb#102
  sig { returns(T.nilable(::Idl::AstNode)) }
  def width_ast; end

  class << self
    # source://idlc//lib/idlc/type.rb#582
    sig { params(schema: T::Hash[::String, T.untyped]).returns(T.nilable(::Idl::Type)) }
    def from_json_schema(schema); end

    # source://idlc//lib/idlc/type.rb#119
    def from_typename(type_name, cfg_arch); end

    private

    # source://idlc//lib/idlc/type.rb#544
    sig { params(schema: T::Hash[::String, T.untyped]).returns(::Idl::Type) }
    def from_json_schema_array_type(schema); end

    # source://idlc//lib/idlc/type.rb#457
    sig { params(schema: T::Hash[::String, T.untyped]).returns(T.nilable(::Idl::Type)) }
    def from_json_schema_scalar_type(schema); end
  end
end

# source://idlc//lib/idlc/type.rb#18
Idl::Type::KINDS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/type.rb#34
Idl::Type::QUALIFIERS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/type.rb#171
Idl::Type::TYPE_FROM_KIND = T.let(T.unsafe(nil), Hash)

# source://idlc//lib/idlc/ast.rb#7825
Idl::TypeNameAst = T.type_alias { T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst) }

# source://idlc//lib/idlc/idl_parser.rb#6782
module Idl::UnaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#6783
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#6788
module Idl::UnaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#6789
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#6793
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#6799
module Idl::UnaryExpression2
  # source://idlc//lib/idlc/idl_parser.rb#6800
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#6806
module Idl::UnaryExpression3
  # source://idlc//lib/idlc/idl_parser.rb#6807
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#6813
module Idl::UnaryExpression4
  # source://idlc//lib/idlc/idl_parser.rb#6814
  def user_type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#6820
module Idl::UnaryExpression5
  # source://idlc//lib/idlc/idl_parser.rb#6821
  def user_type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#6827
module Idl::UnaryExpression6
  # source://idlc//lib/idlc/idl_parser.rb#6832
  def expression; end

  # source://idlc//lib/idlc/idl_parser.rb#6828
  def user_type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#6838
module Idl::UnaryExpression7
  # source://idlc//lib/idlc/idl_parser.rb#6839
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#6845
module Idl::UnaryExpression8
  # source://idlc//lib/idlc/idl_parser.rb#6846
  def ary; end

  # source://idlc//lib/idlc/idl_parser.rb#6850
  def value; end
end

# source://idlc//lib/idlc/idl_parser.rb#6856
module Idl::UnaryExpression9
  # source://idlc//lib/idlc/idl_parser.rb#6861
  def e; end

  # source://idlc//lib/idlc/idl_parser.rb#6857
  def o; end
end

# represents a unary operator
#
# for example:
#   -value
#   ~value
#   !bool_variable
#
# source://idlc//lib/idlc/ast.rb#5946
class Idl::UnaryOperatorExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # @return [UnaryOperatorExpressionAst] a new instance of UnaryOperatorExpressionAst
  #
  # source://idlc//lib/idlc/ast.rb#5954
  def initialize(input, interval, op, expression); end

  # source://idlc//lib/idlc/ast.rb#5950
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # @return [AstNode] the operated-on expression
  #
  # source://idlc//lib/idlc/ast.rb#6043
  def exp; end

  # source://idlc//lib/idlc/ast.rb#5952
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#265
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5960
  def invert(symtab); end

  # @return [String] The operator
  #
  # source://idlc//lib/idlc/ast.rb#6048
  def op; end

  # source://idlc//lib/idlc/ast.rb#6057
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#6054
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/lib/udb/idl/condition_to_udb.rb#126
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # Given a specific symbol table, return the type of this node.
  #
  # Should not be called until {#type_check} is called with the same arguments
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::InternalError] if the type is dependent on symtab, and type_check was not called first
  # @return [Type] The type of the node
  #
  # source://idlc//lib/idlc/ast.rb#5971
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#5987
  def type_check(symtab); end

  # Return the compile-time-known value of the node
  #
  # source://idlc//lib/idlc/ast.rb#6015
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6065
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::UnaryOperatorExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5934
class Idl::UnaryOperatorExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5935
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#7070
class Idl::UnknownLiteral
  # @return [UnknownLiteral] a new instance of UnknownLiteral
  #
  # source://idlc//lib/idlc/ast.rb#7072
  def initialize(known_value, unknown_mask); end

  # source://idlc//lib/idlc/ast.rb#7080
  def &(other); end

  # source://idlc//lib/idlc/ast.rb#7101
  def ==(other); end

  # source://idlc//lib/idlc/ast.rb#7076
  def bit_length; end

  # Returns the value of attribute known_value.
  #
  # source://idlc//lib/idlc/ast.rb#7071
  def known_value; end

  # source://idlc//lib/idlc/ast.rb#7131
  def to_s; end

  # Returns the value of attribute unknown_mask.
  #
  # source://idlc//lib/idlc/ast.rb#7071
  def unknown_mask; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/ast.rb#7079
  def zero?; end

  # source://idlc//lib/idlc/ast.rb#7110
  def |(other); end
end

# source://idlc//lib/idlc/idl_parser.rb#15764
module Idl::UserTypeName0; end

# source://idlc//lib/idlc/ast.rb#7773
class Idl::UserTypeNameAst < ::Idl::AstNode
  # @return [UserTypeNameAst] a new instance of UserTypeNameAst
  #
  # source://idlc//lib/idlc/ast.rb#7777
  def initialize(input, interval, name); end

  # source://idlc//lib/idlc/ast.rb#7775
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#66
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7783
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#7806
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#7803
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7794
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#7786
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#7813
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::UserTypeNameAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#7767
class Idl::UserTypeNameSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7768
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#27
Idl::ValueRbType = T.type_alias { T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)]) }

# Objects to represent variables in the ISA def
#
# source://idlc//lib/idlc/symbol_table.rb#17
class Idl::Var
  # @raise [ArgumentError]
  # @return [Var] a new instance of Var
  #
  # source://idlc//lib/idlc/symbol_table.rb#22
  def initialize(name, type, value = T.unsafe(nil), decode_var: T.unsafe(nil), template_index: T.unsafe(nil), function_name: T.unsafe(nil), param: T.unsafe(nil), for_loop_iter: T.unsafe(nil)); end

  # source://idlc//lib/idlc/symbol_table.rb#68
  def clone; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/symbol_table.rb#80
  def const?; end

  # source://idlc//lib/idlc/symbol_table.rb#47
  sig { returns(T::Boolean) }
  def const_eval?; end

  # source://idlc//lib/idlc/symbol_table.rb#42
  sig { void }
  def const_incompatible!; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/symbol_table.rb#84
  def decode_var?; end

  # source://idlc//lib/idlc/symbol_table.rb#56
  sig { returns(T::Boolean) }
  def for_loop_iter?; end

  # source://idlc//lib/idlc/symbol_table.rb#60
  def hash; end

  # Returns the value of attribute name.
  #
  # source://idlc//lib/idlc/symbol_table.rb#20
  def name; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/symbol_table.rb#88
  def param?; end

  # @raise if Var is not a template value
  # @return [Integer] the template value position
  #
  # source://idlc//lib/idlc/symbol_table.rb#102
  def template_index; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/symbol_table.rb#108
  def template_val?; end

  # @return [Boolean]
  #
  # source://idlc//lib/idlc/symbol_table.rb#98
  def template_value?; end

  # @param function_name [#to_s] A function name
  # @return [Boolean] whether or not this variable is a function template argument from a call site for the function 'function_name'
  #
  # source://idlc//lib/idlc/symbol_table.rb#94
  def template_value_for?(function_name); end

  # source://idlc//lib/idlc/symbol_table.rb#112
  def to_cxx; end

  # source://idlc//lib/idlc/symbol_table.rb#64
  def to_s; end

  # Returns the value of attribute type.
  #
  # source://idlc//lib/idlc/symbol_table.rb#20
  def type; end

  # Returns the value of attribute value.
  #
  # source://idlc//lib/idlc/symbol_table.rb#20
  def value; end

  # source://idlc//lib/idlc/symbol_table.rb#116
  def value=(new_value); end
end

# source://idlc//lib/idlc/idl_parser.rb#16508
module Idl::VarWrite0
  # source://idlc//lib/idlc/idl_parser.rb#16509
  def csr_name; end
end

# represents a scalar variable assignment statement
#
# for example, these will result in a VariableAssignmentAst
#   # given: Bits<XLEN> zero;
#   zero = XLEN'b0
#
# source://idlc//lib/idlc/ast.rb#2683
class Idl::VariableAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # @return [VariableAssignmentAst] a new instance of VariableAssignmentAst
  #
  # source://idlc//lib/idlc/ast.rb#2707
  def initialize(input, interval, lhs_ast, rhs_ast); end

  # source://idlc//lib/idlc/ast.rb#2687
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#2738
  def execute(symtab); end

  # "execute" the statement, forcing any variable assignments to an unknown state
  # This is used down unknown conditional paths.
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#2759
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#241
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2702
  sig { returns(::Idl::IdAst) }
  def lhs; end

  # source://idlc//lib/idlc/passes/prune.rb#74
  def nullify_assignments(symtab); end

  # source://idlc//lib/idlc/passes/prune.rb#69
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#2705
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#2776
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#2773
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#2713
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2728
  def var(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2784
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::VariableAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2672
class Idl::VariableAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2673
  def to_ast; end
end

# represents a single variable declaration (without assignment)
#
# for example:
#   Bits<64> doubleword
#   Boolean has_property
#
# source://idlc//lib/idlc/ast.rb#3539
class Idl::VariableDeclarationAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#3569
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      type_name: T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst),
      id: ::Idl::IdAst,
      ary_size: T.nilable(T.all(::Idl::AstNode, ::Idl::Rvalue))
    ).void
  end
  def initialize(input, interval, type_name, id, ary_size); end

  # source://idlc//lib/idlc/ast.rb#3639
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#3555
  sig { returns(T.nilable(T.all(::Idl::AstNode, ::Idl::Rvalue))) }
  def ary_size; end

  # source://idlc//lib/idlc/ast.rb#3543
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3585
  sig { params(symtab: ::Idl::SymbolTable).returns(T.nilable(::Idl::Type)) }
  def decl_type(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#174
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3552
  sig { returns(::Idl::IdAst) }
  def id; end

  # source://idlc//lib/idlc/ast.rb#3580
  sig { void }
  def make_global; end

  # source://idlc//lib/idlc/ast.rb#3558
  sig { returns(::String) }
  def name; end

  # source://idlc//lib/idlc/ast.rb#3660
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#3651
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#3610
  def type(symtab); end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#3613
  def type_check(symtab, add_sym = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3549
  sig { returns(T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst)) }
  def type_name; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3672
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::VariableDeclarationAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3528
class Idl::VariableDeclarationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3529
  def to_ast; end
end

# represents a single variable declaration with initialization
#
# for example:
#   Bits<64> doubleword = 64'hdeadbeef
#   Boolean has_property = true
#
# source://idlc//lib/idlc/ast.rb#3722
class Idl::VariableDeclarationWithInitializationAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#3764
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      type_name_ast: T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst),
      var_write_ast: ::Idl::IdAst,
      ary_size: T.nilable(T.all(::Idl::AstNode, ::Idl::Rvalue)),
      rval_ast: T.all(::Idl::AstNode, ::Idl::Rvalue),
      is_for_loop_iteration_var: T::Boolean
    ).void
  end
  def initialize(input, interval, type_name_ast, var_write_ast, ary_size, rval_ast, is_for_loop_iteration_var); end

  # source://idlc//lib/idlc/ast.rb#3838
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#3745
  sig { returns(T.nilable(T.all(::Idl::AstNode, ::Idl::Rvalue))) }
  def ary_size; end

  # source://idlc//lib/idlc/ast.rb#3727
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # "execute" the statement by updating the variables in the symbol table
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#3868
  def execute(symtab); end

  # "execute" the statement, forcing any variable assignments to an unknown state
  # This is used down unknown conditional paths.
  #
  # @param symtab [SymbolTable] The symbol table for the context
  # @raise ValueError if some part of the statement cannot be executed at compile time
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#3884
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#219
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3751
  sig { returns(::String) }
  def id; end

  # source://idlc//lib/idlc/ast.rb#3742
  sig { returns(::Idl::IdAst) }
  def lhs; end

  # source://idlc//lib/idlc/ast.rb#3778
  def lhs_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#3774
  def make_global; end

  # source://idlc//lib/idlc/passes/prune.rb#93
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#3748
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#3899
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # Return valid IDL representation of the node (and its subtree)
  # Return valid IDL representation of the node (and its subtree)
  #
  # source://idlc//lib/idlc/ast.rb#3890
  sig { override.returns(::String) }
  def to_idl; end

  # type check this node and all children
  #
  # Calls to {#type} and/or {#value} may depend on type_check being called first
  # with the same symtab. If not, those functions may raise an AstNode::InternalError
  #
  # @param symtab [SymbolTable] Symbol table for lookup
  # @raise [AstNode::TypeError] if there is a type error
  # @raise [AstNode::InternalError] if there is an internal compiler error during type check
  # @return [void]
  #
  # source://idlc//lib/idlc/ast.rb#3805
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#3739
  sig { returns(T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst)) }
  def type_name; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3913
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::VariableDeclarationWithInitializationAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3695
class Idl::VariableDeclarationWithInitializationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3696
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#1394
module Idl::VersionString0; end

# source://idlc//lib/idlc/type.rb#1003
Idl::VoidType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#4172
class Idl::WidthRevealAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4182
  sig { params(input: T.nilable(::String), interval: T.nilable(T::Range[::Integer]), e: ::Idl::AstNode).void }
  def initialize(input, interval, e); end

  # source://idlc//lib/idlc/ast.rb#4176
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4179
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def expression; end

  # source://idlc//lib/idlc/ast.rb#4214
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4211
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4195
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4187
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#4204
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Integer) }
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4221
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::WidthRevealAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4166
class Idl::WidthRevealSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4167
  def to_ast; end
end

# XReg is really a Bits<> type, so we override it just to get
# prettier prints
#
# source://idlc//lib/idlc/type.rb#981
class Idl::XregType < ::Idl::Type
  # @return [XregType] a new instance of XregType
  #
  # source://idlc//lib/idlc/type.rb#982
  def initialize(xlen); end

  # source://idlc//lib/idlc/type.rb#990
  def to_cxx; end

  # source://idlc//lib/idlc/type.rb#986
  def to_s; end
end

# source://idlc//lib/idlc.rb#13
class IdlParser < ::Treetop::Runtime::CompiledParser
  include ::Idl

  # Returns the value of attribute input_file.
  #
  # source://idlc//lib/idlc.rb#14
  def input_file; end

  # override instatiate_node so we can set the input file
  #
  # source://idlc//lib/idlc.rb#35
  def instantiate_node(node_type, *args); end

  # source://idlc//lib/idlc.rb#16
  def set_input_file(filename, starting_line = T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#21
  def set_pb(pb); end

  # source://idlc//lib/idlc.rb#27
  def unset_pb; end

  protected

  # alias instantiate_node so we can call it from the override
  #
  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#98
  def idlc_instantiate_node(node_type, *args); end
end

class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin
  include ::Udb::Helpers::WavedromUtil

  private

  # source://idlc//lib/idlc/passes/prune.rb#19
  def create_bool_literal(value); end

  # source://idlc//lib/idlc/passes/prune.rb#14
  def create_int_literal(value); end

  # source://idlc//lib/idlc/passes/prune.rb#27
  def create_literal(symtab, value, type); end
end

# adds a few functions to Treetop's syntax node
#
# source://idlc//lib/idlc/syntax_node.rb#11
module Treetop
  class << self
    # source://treetop/1.6.12/lib/treetop/compiler/grammar_compiler.rb#35
    def load(path); end

    # source://treetop/1.6.12/lib/treetop/compiler/grammar_compiler.rb#48
    def load_from_string(s); end
  end
end

# source://idlc//lib/idlc/syntax_node.rb#12
module Treetop::Runtime; end

# source://idlc//lib/idlc/syntax_node.rb#13
class Treetop::Runtime::SyntaxNode
  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#7
  def initialize(input, interval, elements = T.unsafe(nil)); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#47
  def <=>(other); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#98
  def dot_id; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#15
  def elements; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#43
  def empty?; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#51
  def extension_modules; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#4
  def input; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#91
  def inspect(indent = T.unsafe(nil)); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#78
  def inspect_children(indent = T.unsafe(nil)); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#63
  def inspect_self(indent = T.unsafe(nil)); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#4
  def interval; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#35
  def nonterminal?; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#5
  def parent; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#5
  def parent=(_arg0); end

  # remember where the code comes from
  #
  # source://idlc//lib/idlc/syntax_node.rb#20
  sig { params(filename: T.nilable(::String), starting_line: ::Integer).void }
  def set_input_file(filename, starting_line = T.unsafe(nil)); end

  # Sets the input file for this syntax node unless it has already been set.
  #
  # If the input file has not been set, it will be set with the given filename and starting line number.
  #
  # source://idlc//lib/idlc/syntax_node.rb#39
  sig { params(filename: T.nilable(::String), starting_line: ::Integer).void }
  def set_input_file_unless_already_set(filename, starting_line = T.unsafe(nil)); end

  # source://idlc//lib/idlc/syntax_node.rb#30
  sig { returns(T::Boolean) }
  def space?; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#31
  def terminal?; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#39
  def text_value; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#102
  def write_dot(io); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#113
  def write_dot_file(fname); end
end

# version requirements for common gem dependencies
module UdbGems; end
