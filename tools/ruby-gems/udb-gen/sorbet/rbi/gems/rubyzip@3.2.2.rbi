# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubyzip` gem.
# Please instead update this file by running `bin/tapioca gem rubyzip`.


# source://rubyzip//lib/zip/version.rb#3
module Zip
  extend ::Zip

  # source://rubyzip//lib/zip.rb#48
  def case_insensitive_match; end

  # source://rubyzip//lib/zip.rb#48
  def case_insensitive_match=(_arg0); end

  # source://rubyzip//lib/zip.rb#48
  def continue_on_exists_proc; end

  # source://rubyzip//lib/zip.rb#48
  def continue_on_exists_proc=(_arg0); end

  # source://rubyzip//lib/zip.rb#48
  def default_compression; end

  # source://rubyzip//lib/zip.rb#48
  def default_compression=(_arg0); end

  # source://rubyzip//lib/zip.rb#48
  def force_entry_names_encoding; end

  # source://rubyzip//lib/zip.rb#48
  def force_entry_names_encoding=(_arg0); end

  # source://rubyzip//lib/zip.rb#48
  def on_exists_proc; end

  # source://rubyzip//lib/zip.rb#48
  def on_exists_proc=(_arg0); end

  # source://rubyzip//lib/zip.rb#69
  def reset!; end

  # source://rubyzip//lib/zip.rb#84
  def setup; end

  # source://rubyzip//lib/zip.rb#48
  def sort_entries; end

  # source://rubyzip//lib/zip.rb#48
  def sort_entries=(_arg0); end

  # source://rubyzip//lib/zip.rb#48
  def unicode_names; end

  # source://rubyzip//lib/zip.rb#48
  def unicode_names=(_arg0); end

  # source://rubyzip//lib/zip.rb#48
  def validate_entry_sizes; end

  # source://rubyzip//lib/zip.rb#48
  def validate_entry_sizes=(_arg0); end

  # source://rubyzip//lib/zip.rb#48
  def warn_invalid_date; end

  # source://rubyzip//lib/zip.rb#48
  def warn_invalid_date=(_arg0); end

  # source://rubyzip//lib/zip.rb#48
  def write_zip64_support; end

  # source://rubyzip//lib/zip.rb#48
  def write_zip64_support=(_arg0); end
end

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#64
class Zip::AESDecrypter < ::Zip::Decrypter
  include ::Zip::AESEncryption

  # source://rubyzip//lib/zip/crypto/aes_encryption.rb#115
  def check_integrity!(io); end

  # source://rubyzip//lib/zip/crypto/aes_encryption.rb#67
  def decrypt(encrypted_data); end

  # source://rubyzip//lib/zip/crypto/aes_encryption.rb#90
  def reset!(header); end
end

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#6
module Zip::AESEncryption
  # source://rubyzip//lib/zip/crypto/aes_encryption.rb#47
  def initialize(password, strength); end

  # source://rubyzip//lib/zip/crypto/aes_encryption.rb#59
  def gp_flags; end

  # source://rubyzip//lib/zip/crypto/aes_encryption.rb#55
  def header_bytesize; end
end

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#9
Zip::AESEncryption::AUTHENTICATION_CODE_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#29
Zip::AESEncryption::BITS = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#8
Zip::AESEncryption::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#35
Zip::AESEncryption::KEY_LENGTHS = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#41
Zip::AESEncryption::SALT_LENGTHS = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#23
Zip::AESEncryption::STRENGTHS = T.let(T.unsafe(nil), Array)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#19
Zip::AESEncryption::STRENGTH_128_BIT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#20
Zip::AESEncryption::STRENGTH_192_BIT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#21
Zip::AESEncryption::STRENGTH_256_BIT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#7
Zip::AESEncryption::VERIFIER_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#14
Zip::AESEncryption::VERSIONS = T.let(T.unsafe(nil), Array)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#11
Zip::AESEncryption::VERSION_AE_1 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#12
Zip::AESEncryption::VERSION_AE_2 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#9
Zip::CDIR_ENTRY_STATIC_HEADER_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#8
Zip::CENTRAL_DIRECTORY_ENTRY_SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#95
Zip::COMPRESSION_METHODS = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/constants.rb#93
Zip::COMPRESSION_METHOD_AES = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#82
Zip::COMPRESSION_METHOD_BZIP2 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#78
Zip::COMPRESSION_METHOD_DEFLATE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#79
Zip::COMPRESSION_METHOD_DEFLATE_64 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#86
Zip::COMPRESSION_METHOD_IBM_CMPSC = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#89
Zip::COMPRESSION_METHOD_IBM_LZ77 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#88
Zip::COMPRESSION_METHOD_IBM_TERSE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#76
Zip::COMPRESSION_METHOD_IMPLODE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#90
Zip::COMPRESSION_METHOD_JPEG = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#84
Zip::COMPRESSION_METHOD_LZMA = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#80
Zip::COMPRESSION_METHOD_PKWARE_DCLI = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#92
Zip::COMPRESSION_METHOD_PPMD = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#72
Zip::COMPRESSION_METHOD_REDUCE_1 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#73
Zip::COMPRESSION_METHOD_REDUCE_2 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#74
Zip::COMPRESSION_METHOD_REDUCE_3 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#75
Zip::COMPRESSION_METHOD_REDUCE_4 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#71
Zip::COMPRESSION_METHOD_SHRINK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#70
Zip::COMPRESSION_METHOD_STORE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#91
Zip::COMPRESSION_METHOD_WAVPACK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#8
class Zip::CentralDirectory
  include ::Zip::Dirtyable
  extend ::Forwardable
  extend ::Zip::Dirtyable::ClassMethods

  # source://rubyzip//lib/zip/central_directory.rb#31
  def initialize(entries = T.unsafe(nil), comment = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/central_directory.rb#25
  def <<(param); end

  # source://rubyzip//lib/zip/central_directory.rb#66
  def ==(other); end

  # source://rubyzip//lib/zip/central_directory.rb#23
  def comment; end

  # source://rubyzip//lib/zip/central_directory.rb#23
  def comment=(param); end

  # source://rubyzip//lib/zip/central_directory.rb#61
  def count_entries(io); end

  # source://rubyzip//lib/zip/central_directory.rb#25
  def delete(param); end

  # source://rubyzip//lib/zip/central_directory.rb#25
  def each(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/central_directory.rb#25
  def entries(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/central_directory.rb#25
  def find_entry(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/central_directory.rb#25
  def glob(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/central_directory.rb#25
  def include?(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/central_directory.rb#29
  def orig_comment=(_arg0); end

  # source://rubyzip//lib/zip/central_directory.rb#29
  def orig_delete(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/central_directory.rb#37
  def read_from_stream(io); end

  # source://rubyzip//lib/zip/central_directory.rb#25
  def size(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/central_directory.rb#42
  def write_to_stream(io, suppress_extra_fields: T.unsafe(nil)); end

  private

  # source://rubyzip//lib/zip/central_directory.rb#252
  def eocd_data(io); end

  # source://rubyzip//lib/zip/central_directory.rb#169
  def read_central_directory_entries(io); end

  # source://rubyzip//lib/zip/central_directory.rb#213
  def read_eocds(io); end

  # source://rubyzip//lib/zip/central_directory.rb#202
  def read_local_extra_field(io); end

  # source://rubyzip//lib/zip/central_directory.rb#115
  def unpack_64_e_o_c_d(buffer); end

  # source://rubyzip//lib/zip/central_directory.rb#139
  def unpack_64_eocd_locator(buffer); end

  # source://rubyzip//lib/zip/central_directory.rb#148
  def unpack_e_o_c_d(buffer); end

  # source://rubyzip//lib/zip/central_directory.rb#89
  def write_64_e_o_c_d(io, offset, cdir_size); end

  # source://rubyzip//lib/zip/central_directory.rb#105
  def write_64_eocd_locator(io, zip64_eocd_offset); end

  # source://rubyzip//lib/zip/central_directory.rb#74
  def write_e_o_c_d(io, offset, cdir_size); end
end

# source://rubyzip//lib/zip/central_directory.rb#12
Zip::CentralDirectory::END_OF_CD_SIG = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#20
Zip::CentralDirectory::MAX_END_OF_CD_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#19
Zip::CentralDirectory::MAX_FILE_COMMENT_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#16
Zip::CentralDirectory::STATIC_EOCD_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#13
Zip::CentralDirectory::ZIP64_END_OF_CD_SIG = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#14
Zip::CentralDirectory::ZIP64_EOCD_LOCATOR_SIG = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#18
Zip::CentralDirectory::ZIP64_EOCD_LOC_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#17
Zip::CentralDirectory::ZIP64_STATIC_EOCD_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/errors.rb#9
class Zip::CompressionMethodError < ::Zip::Error
  # source://rubyzip//lib/zip/errors.rb#15
  def initialize(method); end

  # source://rubyzip//lib/zip/errors.rb#11
  def compression_method; end

  # source://rubyzip//lib/zip/errors.rb#21
  def message; end
end

# source://rubyzip//lib/zip/compressor.rb#4
class Zip::Compressor
  # source://rubyzip//lib/zip/compressor.rb#5
  def finish; end
end

# source://rubyzip//lib/zip.rb#59
Zip::DEFAULT_RESTORE_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/dos_time.rb#7
class Zip::DOSTime < ::Time
  include ::Zip::DOSTime::JRubyCMP

  # source://rubyzip//lib/zip/dos_time.rb#46
  def <=>(other); end

  # source://rubyzip//lib/zip/dos_time.rb#19
  def absolute_time=(_arg0); end

  # source://rubyzip//lib/zip/dos_time.rb#21
  def absolute_time?; end

  # source://rubyzip//lib/zip/dos_time.rb#40
  def dos_equals(other); end

  # source://rubyzip//lib/zip/dos_time.rb#33
  def to_binary_dos_date; end

  # source://rubyzip//lib/zip/dos_time.rb#27
  def to_binary_dos_time; end

  class << self
    # source://rubyzip//lib/zip/dos_time.rb#53
    def from_time(time); end

    # source://rubyzip//lib/zip/dos_time.rb#57
    def parse_binary_dos_format(bin_dos_date, bin_dos_time); end
  end
end

# source://rubyzip//lib/zip/dos_time.rb#71
module Zip::DOSTime::JRubyCMP
  # source://rubyzip//lib/zip/dos_time.rb#76
  def <(other); end

  # source://rubyzip//lib/zip/dos_time.rb#80
  def <=(other); end

  # source://rubyzip//lib/zip/dos_time.rb#72
  def ==(other); end

  # source://rubyzip//lib/zip/dos_time.rb#84
  def >(other); end

  # source://rubyzip//lib/zip/dos_time.rb#88
  def >=(other); end
end

# source://rubyzip//lib/zip/errors.rb#27
class Zip::DecompressionError < ::Zip::Error
  # source://rubyzip//lib/zip/errors.rb#33
  def initialize(zlib_error); end

  # source://rubyzip//lib/zip/errors.rb#39
  def message; end

  # source://rubyzip//lib/zip/errors.rb#29
  def zlib_error; end
end

# source://rubyzip//lib/zip/decompressor.rb#4
class Zip::Decompressor
  # source://rubyzip//lib/zip/decompressor.rb#21
  def initialize(input_stream, decompressed_size = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/decompressor.rb#19
  def decompressed_size; end

  # source://rubyzip//lib/zip/decompressor.rb#19
  def input_stream; end

  class << self
    # source://rubyzip//lib/zip/decompressor.rb#7
    def decompressor_classes; end

    # source://rubyzip//lib/zip/decompressor.rb#15
    def find_by_compression_method(compression_method); end

    # source://rubyzip//lib/zip/decompressor.rb#11
    def register(compression_method, decompressor_class); end
  end
end

# source://rubyzip//lib/zip/decompressor.rb#5
Zip::Decompressor::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/decrypted_io.rb#4
class Zip::DecryptedIo
  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#7
  def initialize(io, decrypter, compressed_size); end

  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#14
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  private

  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#30
  def eof?; end

  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#34
  def input_finished?; end

  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#38
  def produce_input; end
end

# source://rubyzip//lib/zip/crypto/decrypted_io.rb#5
Zip::DecryptedIo::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/encryption.rb#7
class Zip::Decrypter; end

# source://rubyzip//lib/zip/deflater.rb#4
class Zip::Deflater < ::Zip::Compressor
  # source://rubyzip//lib/zip/deflater.rb#5
  def initialize(output_stream, level = T.unsafe(nil), encrypter = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/deflater.rb#14
  def <<(data); end

  # source://rubyzip//lib/zip/deflater.rb#32
  def crc; end

  # source://rubyzip//lib/zip/deflater.rb#26
  def finish; end

  # source://rubyzip//lib/zip/deflater.rb#32
  def size; end
end

# source://rubyzip//lib/zip/errors.rb#46
class Zip::DestinationExistsError < ::Zip::Error
  # source://rubyzip//lib/zip/errors.rb#48
  def initialize(destination); end

  # source://rubyzip//lib/zip/errors.rb#54
  def message; end
end

# source://rubyzip//lib/zip/dirtyable.rb#4
module Zip::Dirtyable
  mixes_in_class_methods ::Zip::Dirtyable::ClassMethods

  # source://rubyzip//lib/zip/dirtyable.rb#5
  def initialize(dirty_on_create: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/dirtyable.rb#9
  def dirty?; end

  class << self
    # source://rubyzip//lib/zip/dirtyable.rb#28
    def included(base); end
  end
end

# source://rubyzip//lib/zip/dirtyable.rb#13
module Zip::Dirtyable::ClassMethods
  # source://rubyzip//lib/zip/dirtyable.rb#14
  def mark_dirty(*symbols); end
end

# source://rubyzip//lib/zip/crypto/encryption.rb#4
class Zip::Encrypter; end

# source://rubyzip//lib/zip/entry.rb#10
class Zip::Entry
  include ::Zip::Dirtyable
  extend ::Zip::Dirtyable::ClassMethods

  # source://rubyzip//lib/zip/entry.rb#76
  def initialize(zipfile = T.unsafe(nil), name = T.unsafe(nil), comment: T.unsafe(nil), size: T.unsafe(nil), compressed_size: T.unsafe(nil), crc: T.unsafe(nil), compression_method: T.unsafe(nil), compression_level: T.unsafe(nil), time: T.unsafe(nil), extra: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#636
  def <=>(other); end

  # source://rubyzip//lib/zip/entry.rb#627
  def ==(other); end

  # source://rubyzip//lib/zip/entry.rb#181
  def absolute_time?; end

  # source://rubyzip//lib/zip/entry.rb#207
  def aes?; end

  # source://rubyzip//lib/zip/entry.rb#144
  def atime; end

  # source://rubyzip//lib/zip/entry.rb#171
  def atime=(value); end

  # source://rubyzip//lib/zip/entry.rb#259
  def calculate_local_header_size; end

  # source://rubyzip//lib/zip/entry.rb#275
  def cdir_header_size; end

  # source://rubyzip//lib/zip/entry.rb#492
  def check_c_dir_entry_comment_size; end

  # source://rubyzip//lib/zip/entry.rb#486
  def check_c_dir_entry_signature; end

  # source://rubyzip//lib/zip/entry.rb#480
  def check_c_dir_entry_static_header_length(buf); end

  # source://rubyzip//lib/zip/entry.rb#70
  def check_name(name); end

  # source://rubyzip//lib/zip/entry.rb#730
  def clean_up; end

  # source://rubyzip//lib/zip/entry.rb#27
  def comment; end

  # source://rubyzip//lib/zip/entry.rb#27
  def comment=(param); end

  # source://rubyzip//lib/zip/entry.rb#255
  def comment_size; end

  # source://rubyzip//lib/zip/entry.rb#27
  def compressed_size; end

  # source://rubyzip//lib/zip/entry.rb#27
  def compressed_size=(param); end

  # source://rubyzip//lib/zip/entry.rb#34
  def compression_level; end

  # source://rubyzip//lib/zip/entry.rb#189
  def compression_method; end

  # source://rubyzip//lib/zip/entry.rb#196
  def compression_method=(method); end

  # source://rubyzip//lib/zip/entry.rb#31
  def crc; end

  # source://rubyzip//lib/zip/entry.rb#31
  def crc=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#149
  def ctime; end

  # source://rubyzip//lib/zip/entry.rb#176
  def ctime=(value); end

  # source://rubyzip//lib/zip/entry.rb#221
  def directory?; end

  # source://rubyzip//lib/zip/entry.rb#112
  def encrypted?; end

  # source://rubyzip//lib/zip/entry.rb#31
  def external_file_attributes; end

  # source://rubyzip//lib/zip/entry.rb#31
  def external_file_attributes=(param); end

  # source://rubyzip//lib/zip/entry.rb#34
  def extra; end

  # source://rubyzip//lib/zip/entry.rb#251
  def extra_size; end

  # source://rubyzip//lib/zip/entry.rb#289
  def extract(entry_path = T.unsafe(nil), destination_directory: T.unsafe(nil), &block); end

  # source://rubyzip//lib/zip/entry.rb#221
  def file?; end

  # source://rubyzip//lib/zip/entry.rb#528
  def file_stat(path); end

  # source://rubyzip//lib/zip/entry.rb#211
  def file_type_is?(type); end

  # source://rubyzip//lib/zip/entry.rb#34
  def filepath; end

  # source://rubyzip//lib/zip/entry.rb#27
  def follow_symlinks; end

  # source://rubyzip//lib/zip/entry.rb#27
  def follow_symlinks=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#31
  def fstype; end

  # source://rubyzip//lib/zip/entry.rb#31
  def fstype=(param); end

  # source://rubyzip//lib/zip/entry.rb#215
  def ftype; end

  # source://rubyzip//lib/zip/entry.rb#674
  def gather_fileinfo_from_srcpath(src_path); end

  # source://rubyzip//lib/zip/entry.rb#536
  def get_extra_attributes_from_path(path); end

  # source://rubyzip//lib/zip/entry.rb#642
  def get_input_stream(&block); end

  # source://rubyzip//lib/zip/entry.rb#722
  def get_raw_input_stream(&block); end

  # source://rubyzip//lib/zip/entry.rb#31
  def gp_flags; end

  # source://rubyzip//lib/zip/entry.rb#31
  def gp_flags=(param); end

  # source://rubyzip//lib/zip/entry.rb#116
  def incomplete?; end

  # source://rubyzip//lib/zip/entry.rb#31
  def internal_file_attributes; end

  # source://rubyzip//lib/zip/entry.rb#31
  def internal_file_attributes=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#243
  def local_entry_offset; end

  # source://rubyzip//lib/zip/entry.rb#31
  def local_header_offset; end

  # source://rubyzip//lib/zip/entry.rb#31
  def local_header_offset=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#141
  def mtime(component: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#168
  def mtime=(value, component: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#27
  def name; end

  # source://rubyzip//lib/zip/entry.rb#27
  def name=(param); end

  # source://rubyzip//lib/zip/entry.rb#226
  def name_is_directory?; end

  # source://rubyzip//lib/zip/entry.rb#233
  def name_safe?; end

  # source://rubyzip//lib/zip/entry.rb#247
  def name_size; end

  # source://rubyzip//lib/zip/entry.rb#280
  def next_header_offset; end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_comment=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_compressed_size=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_external_file_attributes=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_fstype=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_gp_flags=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_name=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_size=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_unix_gid=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_unix_perms=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_unix_uid=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#573
  def pack_c_dir_entry; end

  # source://rubyzip//lib/zip/entry.rb#394
  def pack_local_entry; end

  # source://rubyzip//lib/zip/entry.rb#716
  def parent_as_string; end

  # source://rubyzip//lib/zip/entry.rb#506
  def read_c_dir_entry(io); end

  # source://rubyzip//lib/zip/entry.rb#498
  def read_extra_field(buf, local: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#350
  def read_local_entry(io); end

  # source://rubyzip//lib/zip/entry.rb#27
  def restore_ownership; end

  # source://rubyzip//lib/zip/entry.rb#27
  def restore_ownership=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#27
  def restore_permissions; end

  # source://rubyzip//lib/zip/entry.rb#27
  def restore_permissions=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#27
  def restore_times; end

  # source://rubyzip//lib/zip/entry.rb#27
  def restore_times=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#42
  def set_default_vars_values; end

  # source://rubyzip//lib/zip/entry.rb#559
  def set_extra_attributes_on_path(dest_path); end

  # source://rubyzip//lib/zip/entry.rb#450
  def set_ftype_from_c_dir_entry; end

  # source://rubyzip//lib/zip/entry.rb#547
  def set_unix_attributes_on_path(dest_path); end

  # source://rubyzip//lib/zip/entry.rb#121
  def size; end

  # source://rubyzip//lib/zip/entry.rb#36
  def size=(param); end

  # source://rubyzip//lib/zip/entry.rb#221
  def symlink?; end

  # source://rubyzip//lib/zip/entry.rb#128
  def time(component: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#156
  def time=(value, component: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#306
  def to_s; end

  # source://rubyzip//lib/zip/entry.rb#27
  def unix_gid; end

  # source://rubyzip//lib/zip/entry.rb#27
  def unix_gid=(param); end

  # source://rubyzip//lib/zip/entry.rb#27
  def unix_perms; end

  # source://rubyzip//lib/zip/entry.rb#27
  def unix_perms=(param); end

  # source://rubyzip//lib/zip/entry.rb#27
  def unix_uid; end

  # source://rubyzip//lib/zip/entry.rb#27
  def unix_uid=(param); end

  # source://rubyzip//lib/zip/entry.rb#429
  def unpack_c_dir_entry(buf); end

  # source://rubyzip//lib/zip/entry.rb#335
  def unpack_local_entry(buf); end

  # source://rubyzip//lib/zip/entry.rb#265
  def verify_local_header_size!; end

  # source://rubyzip//lib/zip/entry.rb#597
  def write_c_dir_entry(io, suppress_extra_fields: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#409
  def write_local_entry(io, suppress_extra_fields: T.unsafe(nil), rewrite: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#703
  def write_to_zip_output_stream(zip_output_stream); end

  # source://rubyzip//lib/zip/entry.rb#202
  def zip64?; end

  private

  # source://rubyzip//lib/zip/entry.rb#779
  def create_directory(dest_path); end

  # source://rubyzip//lib/zip/entry.rb#752
  def create_file(dest_path, _continue_on_exists_proc = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#793
  def create_symlink(dest_path); end

  # source://rubyzip//lib/zip/entry.rb#813
  def parse_aes_extra; end

  # source://rubyzip//lib/zip/entry.rb#801
  def parse_zip64_extra(for_local_header); end

  # source://rubyzip//lib/zip/entry.rb#865
  def prep_cdir_zip64_extra; end

  # source://rubyzip//lib/zip/entry.rb#849
  def prep_local_zip64_extra; end

  # source://rubyzip//lib/zip/entry.rb#736
  def read_local_header_fields(io); end

  # source://rubyzip//lib/zip/entry.rb#835
  def set_compression_level_flags; end

  # source://rubyzip//lib/zip/entry.rb#746
  def set_time(binary_dos_date, binary_dos_time); end

  class << self
    # source://rubyzip//lib/zip/entry.rb#311
    def read_c_dir_entry(io); end

    # source://rubyzip//lib/zip/entry.rb#324
    def read_local_entry(io); end
  end
end

# source://rubyzip//lib/zip/entry.rb#24
Zip::Entry::COMPRESSION_LEVEL_FAST_GPFLAG = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/entry.rb#25
Zip::Entry::COMPRESSION_LEVEL_MAX_GPFLAG = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/entry.rb#23
Zip::Entry::COMPRESSION_LEVEL_SUPERFAST_GPFLAG = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/entry.rb#17
Zip::Entry::DEFLATED = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/entry.rb#20
Zip::Entry::EFS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/entry.rb#14
Zip::Entry::STORED = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/errors.rb#62
class Zip::EntryExistsError < ::Zip::Error
  # source://rubyzip//lib/zip/errors.rb#64
  def initialize(source, name); end

  # source://rubyzip//lib/zip/errors.rb#71
  def message; end
end

# source://rubyzip//lib/zip/errors.rb#77
class Zip::EntryNameError < ::Zip::Error
  # source://rubyzip//lib/zip/errors.rb#79
  def initialize(name = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/errors.rb#85
  def message; end
end

# source://rubyzip//lib/zip/entry_set.rb#4
class Zip::EntrySet
  include ::Enumerable

  # source://rubyzip//lib/zip/entry_set.rb#10
  def initialize(an_enumerable = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry_set.rb#24
  def <<(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#53
  def ==(other); end

  # source://rubyzip//lib/zip/entry_set.rb#36
  def delete(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#49
  def dup; end

  # source://rubyzip//lib/zip/entry_set.rb#40
  def each(&block); end

  # source://rubyzip//lib/zip/entry_set.rb#44
  def entries; end

  # source://rubyzip//lib/zip/entry_set.rb#20
  def find_entry(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#63
  def glob(pattern, flags = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry_set.rb#16
  def include?(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#34
  def length; end

  # source://rubyzip//lib/zip/entry_set.rb#59
  def parent(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#28
  def push(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#30
  def size; end

  protected

  # source://rubyzip//lib/zip/entry_set.rb#7
  def entry_set; end

  # source://rubyzip//lib/zip/entry_set.rb#74
  def sorted_entries; end

  private

  # source://rubyzip//lib/zip/entry_set.rb#80
  def to_key(entry); end
end

# source://rubyzip//lib/zip/errors.rb#96
class Zip::EntrySizeError < ::Zip::Error
  # source://rubyzip//lib/zip/errors.rb#101
  def initialize(entry); end

  # source://rubyzip//lib/zip/errors.rb#98
  def entry; end

  # source://rubyzip//lib/zip/errors.rb#107
  def message; end
end

# source://rubyzip//lib/zip/errors.rb#6
class Zip::Error < ::StandardError; end

# source://rubyzip//lib/zip/extra_field.rb#4
class Zip::ExtraField < ::Hash
  # source://rubyzip//lib/zip/extra_field.rb#7
  def initialize(binstr = T.unsafe(nil), local: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field.rb#81
  def c_dir_size; end

  # source://rubyzip//lib/zip/extra_field.rb#48
  def create(name); end

  # source://rubyzip//lib/zip/extra_field.rb#11
  def extra_field_type_exist(binstr, id, len, index); end

  # source://rubyzip//lib/zip/extra_field.rb#21
  def extra_field_type_unknown(binstr, len, index, local); end

  # source://rubyzip//lib/zip/extra_field.rb#89
  def length; end

  # source://rubyzip//lib/zip/extra_field.rb#85
  def local_size; end

  # source://rubyzip//lib/zip/extra_field.rb#32
  def merge(binstr, local: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field.rb#58
  def ordered_values; end

  # source://rubyzip//lib/zip/extra_field.rb#90
  def size; end

  # source://rubyzip//lib/zip/extra_field.rb#65
  def suppress_fields!(fields); end

  # source://rubyzip//lib/zip/extra_field.rb#77
  def to_c_dir_bin; end

  # source://rubyzip//lib/zip/extra_field.rb#71
  def to_local_bin; end

  # source://rubyzip//lib/zip/extra_field.rb#75
  def to_s; end
end

# source://rubyzip//lib/zip/extra_field/aes.rb#5
class Zip::ExtraField::AES < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/aes.rb#11
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/aes.rb#19
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/aes.rb#6
  def compression_method; end

  # source://rubyzip//lib/zip/extra_field/aes.rb#6
  def encryption_strength; end

  # source://rubyzip//lib/zip/extra_field/aes.rb#26
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/aes.rb#46
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/aes.rb#41
  def pack_for_local; end

  # source://rubyzip//lib/zip/extra_field/aes.rb#37
  def suppress?; end

  # source://rubyzip//lib/zip/extra_field/aes.rb#6
  def vendor_id; end

  # source://rubyzip//lib/zip/extra_field/aes.rb#6
  def vendor_version; end
end

# source://rubyzip//lib/zip/extra_field/aes.rb#8
Zip::ExtraField::AES::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/generic.rb#4
class Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/generic.rb#16
  def initial_parse(binstr); end

  # source://rubyzip//lib/zip/extra_field/generic.rb#29
  def suppress?; end

  # source://rubyzip//lib/zip/extra_field/generic.rb#38
  def to_c_dir_bin; end

  # source://rubyzip//lib/zip/extra_field/generic.rb#33
  def to_local_bin; end

  class << self
    # source://rubyzip//lib/zip/extra_field/generic.rb#11
    def name; end

    # source://rubyzip//lib/zip/extra_field/generic.rb#5
    def register_map; end
  end
end

# source://rubyzip//lib/zip/extra_field.rb#5
Zip::ExtraField::ID_MAP = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/extra_field/unix.rb#5
class Zip::ExtraField::IUnix < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/unix.rb#9
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/unix.rb#29
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/unix.rb#15
  def gid; end

  # source://rubyzip//lib/zip/extra_field/unix.rb#15
  def gid=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/unix.rb#17
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/unix.rb#37
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/unix.rb#33
  def pack_for_local; end

  # source://rubyzip//lib/zip/extra_field/unix.rb#15
  def uid; end

  # source://rubyzip//lib/zip/extra_field/unix.rb#15
  def uid=(_arg0); end
end

# source://rubyzip//lib/zip/extra_field/unix.rb#6
Zip::ExtraField::IUnix::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/ntfs.rb#6
class Zip::ExtraField::NTFS < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/ntfs.rb#13
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#40
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#20
  def atime; end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#20
  def atime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#20
  def ctime; end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#20
  def ctime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#22
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#20
  def mtime; end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#20
  def mtime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#52
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#47
  def pack_for_local; end

  private

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#88
  def from_ntfs_time(ntfs_time); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#70
  def parse_tags(content); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#92
  def to_ntfs_time(time); end
end

# source://rubyzip//lib/zip/extra_field/ntfs.rb#7
Zip::ExtraField::NTFS::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/ntfs.rb#11
Zip::ExtraField::NTFS::SEC_TO_UNIX_EPOCH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/extra_field/ntfs.rb#10
Zip::ExtraField::NTFS::WINDOWS_TICK = T.let(T.unsafe(nil), Float)

# source://rubyzip//lib/zip/extra_field/old_unix.rb#5
class Zip::ExtraField::OldUnix < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/old_unix.rb#9
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#33
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def atime; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def atime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def gid; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def gid=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#19
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def mtime; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def mtime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#44
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#40
  def pack_for_local; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def uid; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def uid=(_arg0); end
end

# source://rubyzip//lib/zip/extra_field/old_unix.rb#6
Zip::ExtraField::OldUnix::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/universal_time.rb#5
class Zip::ExtraField::UniversalTime < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/universal_time.rb#13
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#59
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#22
  def atime; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#24
  def atime=(time); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#22
  def ctime; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#29
  def ctime=(time); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#22
  def flag; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#39
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#22
  def mtime; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#34
  def mtime=(time); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#73
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#65
  def pack_for_local; end
end

# source://rubyzip//lib/zip/extra_field/universal_time.rb#9
Zip::ExtraField::UniversalTime::ATIME_MASK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/extra_field/universal_time.rb#10
Zip::ExtraField::UniversalTime::CTIME_MASK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/extra_field/universal_time.rb#6
Zip::ExtraField::UniversalTime::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/universal_time.rb#11
Zip::ExtraField::UniversalTime::MTIME_MASK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/extra_field/unknown.rb#7
class Zip::ExtraField::Unknown < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/unknown.rb#8
  def initialize; end

  # source://rubyzip//lib/zip/extra_field/unknown.rb#31
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/unknown.rb#13
  def merge(binstr, local: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/unknown.rb#27
  def to_c_dir_bin; end

  # source://rubyzip//lib/zip/extra_field/unknown.rb#23
  def to_local_bin; end
end

# source://rubyzip//lib/zip/extra_field/zip64.rb#5
class Zip::ExtraField::Zip64 < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/zip64.rb#12
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#24
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#6
  def compressed_size; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#6
  def compressed_size=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#6
  def disk_start_number; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#6
  def disk_start_number=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#31
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#6
  def original_size; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#6
  def original_size=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#74
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#66
  def pack_for_local; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#40
  def parse(original_size, compressed_size, relative_header_offset = T.unsafe(nil), disk_start_number = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#6
  def relative_header_offset; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#6
  def relative_header_offset=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#61
  def suppress?; end

  private

  # source://rubyzip//lib/zip/extra_field/zip64.rb#54
  def extract(size, format); end
end

# source://rubyzip//lib/zip/extra_field/zip64.rb#9
Zip::ExtraField::Zip64::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/constants.rb#21
Zip::FILE_TYPE_DIR = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#20
Zip::FILE_TYPE_FILE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#22
Zip::FILE_TYPE_SYMLINK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#46
Zip::FSTYPES = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/constants.rb#37
Zip::FSTYPE_ACORN = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#25
Zip::FSTYPE_AMIGA = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#29
Zip::FSTYPE_ATARI = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#44
Zip::FSTYPE_ATHEOS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#40
Zip::FSTYPE_BEOS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#33
Zip::FSTYPE_CPM = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#24
Zip::FSTYPE_FAT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#30
Zip::FSTYPE_HPFS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#31
Zip::FSTYPE_MAC = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#43
Zip::FSTYPE_MAC_OSX = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#39
Zip::FSTYPE_MVS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#35
Zip::FSTYPE_NTFS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#36
Zip::FSTYPE_QDOS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#41
Zip::FSTYPE_TANDEM = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#42
Zip::FSTYPE_THEOS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#34
Zip::FSTYPE_TOPS20 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#27
Zip::FSTYPE_UNIX = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#38
Zip::FSTYPE_VFAT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#26
Zip::FSTYPE_VMS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#28
Zip::FSTYPE_VM_CMS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#32
Zip::FSTYPE_Z_SYSTEM = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/file.rb#52
class Zip::File
  include ::Enumerable
  include ::Zip::FileSystem
  extend ::Forwardable
  extend ::Zip::FileSplit

  # source://rubyzip//lib/zip/file.rb#75
  def initialize(path_or_io, create: T.unsafe(nil), buffer: T.unsafe(nil), restore_ownership: T.unsafe(nil), restore_permissions: T.unsafe(nil), restore_times: T.unsafe(nil), compression_level: T.unsafe(nil), suppress_extra_fields: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/file.rb#231
  def add(entry, src_path, &continue_on_exists_proc); end

  # source://rubyzip//lib/zip/file.rb#248
  def add_stored(entry, src_path, &continue_on_exists_proc); end

  # source://rubyzip//lib/zip/file.rb#318
  def close; end

  # source://rubyzip//lib/zip/file.rb#71
  def comment(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/file.rb#71
  def comment=(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/file.rb#291
  def commit; end

  # source://rubyzip//lib/zip/file.rb#324
  def commit_required?; end

  # source://rubyzip//lib/zip/file.rb#71
  def each(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/file.rb#71
  def entries(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/file.rb#282
  def extract(entry, entry_path = T.unsafe(nil), destination_directory: T.unsafe(nil), &block); end

  # source://rubyzip//lib/zip/file.rb#336
  def find_entry(entry_name); end

  # source://rubyzip//lib/zip/file.rb#348
  def get_entry(entry); end

  # source://rubyzip//lib/zip/file.rb#186
  def get_input_stream(entry, &a_proc); end

  # source://rubyzip//lib/zip/file.rb#195
  def get_output_stream(entry, permissions: T.unsafe(nil), comment: T.unsafe(nil), extra: T.unsafe(nil), compressed_size: T.unsafe(nil), crc: T.unsafe(nil), compression_method: T.unsafe(nil), compression_level: T.unsafe(nil), size: T.unsafe(nil), time: T.unsafe(nil), &a_proc); end

  # source://rubyzip//lib/zip/file.rb#71
  def glob(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/file.rb#356
  def mkdir(entry_name, permission = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/file.rb#60
  def name; end

  # source://rubyzip//lib/zip/file.rb#226
  def read(entry); end

  # source://rubyzip//lib/zip/file.rb#256
  def remove(entry); end

  # source://rubyzip//lib/zip/file.rb#261
  def rename(entry, new_name, &continue_on_exists_proc); end

  # source://rubyzip//lib/zip/file.rb#271
  def replace(entry, src_path); end

  # source://rubyzip//lib/zip/file.rb#63
  def restore_ownership; end

  # source://rubyzip//lib/zip/file.rb#63
  def restore_ownership=(_arg0); end

  # source://rubyzip//lib/zip/file.rb#66
  def restore_permissions; end

  # source://rubyzip//lib/zip/file.rb#66
  def restore_permissions=(_arg0); end

  # source://rubyzip//lib/zip/file.rb#69
  def restore_times; end

  # source://rubyzip//lib/zip/file.rb#69
  def restore_times=(_arg0); end

  # source://rubyzip//lib/zip/file.rb#71
  def size(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/file.rb#221
  def to_s; end

  # source://rubyzip//lib/zip/file.rb#308
  def write_buffer(io = T.unsafe(nil)); end

  private

  # source://rubyzip//lib/zip/file.rb#398
  def check_entry_exists(entry_name, continue_on_exists_proc, proc_name); end

  # source://rubyzip//lib/zip/file.rb#407
  def check_file(path); end

  # source://rubyzip//lib/zip/file.rb#366
  def initialize_cdir(path_or_io, buffer: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/file.rb#411
  def on_success_replace; end

  class << self
    # source://rubyzip//lib/zip/file.rb#170
    def count_entries(path_or_io); end

    # source://rubyzip//lib/zip/file.rb#162
    def foreach(zip_file_name, &block); end

    # source://rubyzip//lib/zip/file.rb#99
    def open(file_name, create: T.unsafe(nil), restore_ownership: T.unsafe(nil), restore_permissions: T.unsafe(nil), restore_times: T.unsafe(nil), compression_level: T.unsafe(nil), suppress_extra_fields: T.unsafe(nil)); end

    # source://rubyzip//lib/zip/file.rb#125
    def open_buffer(io = T.unsafe(nil), create: T.unsafe(nil), restore_ownership: T.unsafe(nil), restore_permissions: T.unsafe(nil), restore_times: T.unsafe(nil), compression_level: T.unsafe(nil), suppress_extra_fields: T.unsafe(nil)); end
  end
end

# source://rubyzip//lib/zip/file.rb#57
Zip::File::IO_METHODS = T.let(T.unsafe(nil), Array)

# source://rubyzip//lib/zip/file_split.rb#4
module Zip::FileSplit
  # source://rubyzip//lib/zip/file_split.rb#13
  def get_partial_zip_file_name(zip_file_name, partial_zip_file_name); end

  # source://rubyzip//lib/zip/file_split.rb#24
  def get_segment_count_for_split(zip_file_size, segment_size); end

  # source://rubyzip//lib/zip/file_split.rb#9
  def get_segment_size_for_split(segment_size); end

  # source://rubyzip//lib/zip/file_split.rb#29
  def put_split_signature(szip_file, segment_size); end

  # source://rubyzip//lib/zip/file_split.rb#38
  def save_splited_part(zip_file, partial_zip_file_name, zip_file_size, szip_file_index, segment_size, segment_count); end

  # source://rubyzip//lib/zip/file_split.rb#63
  def split(zip_file_name, segment_size: T.unsafe(nil), delete_original: T.unsafe(nil), partial_zip_file_name: T.unsafe(nil)); end
end

# source://rubyzip//lib/zip/file_split.rb#7
Zip::FileSplit::DATA_BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/file_split.rb#5
Zip::FileSplit::MAX_SEGMENT_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/file_split.rb#6
Zip::FileSplit::MIN_SEGMENT_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/filesystem/zip_file_name_mapper.rb#4
module Zip::FileSystem
  # source://rubyzip//lib/zip/filesystem.rb#44
  def initialize; end

  # source://rubyzip//lib/zip/filesystem.rb#55
  def dir; end

  # source://rubyzip//lib/zip/filesystem.rb#62
  def file; end
end

# source://rubyzip//lib/zip/filesystem/dir.rb#5
class Zip::FileSystem::Dir
  # source://rubyzip//lib/zip/filesystem/dir.rb#6
  def initialize(mapped_zip); end

  # source://rubyzip//lib/zip/filesystem/dir.rb#34
  def chdir(directory_name); end

  # source://rubyzip//lib/zip/filesystem/dir.rb#81
  def chroot(*_args); end

  # source://rubyzip//lib/zip/filesystem/dir.rb#67
  def delete(entry_name); end

  # source://rubyzip//lib/zip/filesystem/dir.rb#42
  def entries(directory_name); end

  # source://rubyzip//lib/zip/filesystem/dir.rb#10
  def file=(_arg0); end

  # source://rubyzip//lib/zip/filesystem/dir.rb#52
  def foreach(directory_name); end

  # source://rubyzip//lib/zip/filesystem/dir.rb#32
  def getwd; end

  # source://rubyzip//lib/zip/filesystem/dir.rb#48
  def glob(*_arg0, **_arg1, &_arg2); end

  # source://rubyzip//lib/zip/filesystem/dir.rb#77
  def mkdir(entry_name, permissions = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/filesystem/dir.rb#12
  def new(directory_name); end

  # source://rubyzip//lib/zip/filesystem/dir.rb#16
  def open(directory_name); end

  # source://rubyzip//lib/zip/filesystem/dir.rb#29
  def pwd; end

  # source://rubyzip//lib/zip/filesystem/dir.rb#74
  def rmdir(entry_name); end

  # source://rubyzip//lib/zip/filesystem/dir.rb#75
  def unlink(entry_name); end
end

# source://rubyzip//lib/zip/filesystem/directory_iterator.rb#5
class Zip::FileSystem::DirectoryIterator
  include ::Enumerable

  # source://rubyzip//lib/zip/filesystem/directory_iterator.rb#8
  def initialize(filenames); end

  # source://rubyzip//lib/zip/filesystem/directory_iterator.rb#13
  def close; end

  # source://rubyzip//lib/zip/filesystem/directory_iterator.rb#17
  def each(&a_proc); end

  # source://rubyzip//lib/zip/filesystem/directory_iterator.rb#23
  def read; end

  # source://rubyzip//lib/zip/filesystem/directory_iterator.rb#29
  def rewind; end

  # source://rubyzip//lib/zip/filesystem/directory_iterator.rb#35
  def seek(position); end

  # source://rubyzip//lib/zip/filesystem/directory_iterator.rb#41
  def tell; end
end

# source://rubyzip//lib/zip/filesystem/file_stat.rb#5
class Zip::FileSystem::File
  # source://rubyzip//lib/zip/filesystem/file.rb#16
  def initialize(mapped_zip); end

  # source://rubyzip//lib/zip/filesystem/file.rb#170
  def atime(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#148
  def basename(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#182
  def blockdev?(_filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#186
  def chardev?(_filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#122
  def chmod(mode, *filenames); end

  # source://rubyzip//lib/zip/filesystem/file.rb#112
  def chown(owner, group, *filenames); end

  # source://rubyzip//lib/zip/filesystem/file.rb#174
  def ctime(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#242
  def delete(*args); end

  # source://rubyzip//lib/zip/filesystem/file.rb#14
  def dir=(_arg0); end

  # source://rubyzip//lib/zip/filesystem/file.rb#80
  def directory?(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#144
  def dirname(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#55
  def executable?(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#58
  def executable_real?(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#39
  def exist?(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#36
  def exists?(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#258
  def expand_path(path); end

  # source://rubyzip//lib/zip/filesystem/file.rb#139
  def file?(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#20
  def find_entry(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#238
  def foreach(filename, sep = T.unsafe(nil), &a_proc); end

  # source://rubyzip//lib/zip/filesystem/file.rb#198
  def ftype(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#43
  def grpowned?(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#156
  def join(*fragments); end

  # source://rubyzip//lib/zip/filesystem/file.rb#210
  def link(_filename, _symlink_name); end

  # source://rubyzip//lib/zip/filesystem/file.rb#224
  def lstat(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#166
  def mtime(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#97
  def new(filename, mode = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/filesystem/file.rb#85
  def open(filename, mode = T.unsafe(nil), permissions = T.unsafe(nil), &block); end

  # source://rubyzip//lib/zip/filesystem/file.rb#42
  def owned?(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#214
  def pipe; end

  # source://rubyzip//lib/zip/filesystem/file.rb#178
  def pipe?(_filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#234
  def popen(*args, &a_proc); end

  # source://rubyzip//lib/zip/filesystem/file.rb#230
  def read(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#45
  def readable?(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#48
  def readable_real?(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#226
  def readlines(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#202
  def readlink(_filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#252
  def rename(file_to_rename, new_name); end

  # source://rubyzip//lib/zip/filesystem/file.rb#64
  def setgid?(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#60
  def setuid?(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#101
  def size(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#107
  def size?(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#194
  def socket?(_filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#152
  def split(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#218
  def stat(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#68
  def sticky?(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#206
  def symlink(_filename, _symlink_name); end

  # source://rubyzip//lib/zip/filesystem/file.rb#190
  def symlink?(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#76
  def truncate(_filename, _len); end

  # source://rubyzip//lib/zip/filesystem/file.rb#72
  def umask(*args); end

  # source://rubyzip//lib/zip/filesystem/file.rb#256
  def unlink(*args); end

  # source://rubyzip//lib/zip/filesystem/file.rb#160
  def utime(modified_time, *filenames); end

  # source://rubyzip//lib/zip/filesystem/file.rb#50
  def writable?(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#53
  def writable_real?(filename); end

  # source://rubyzip//lib/zip/filesystem/file.rb#132
  def zero?(filename); end

  private

  # source://rubyzip//lib/zip/filesystem/file.rb#28
  def unix_mode_cmp(filename, mode); end
end

# source://rubyzip//lib/zip/filesystem/file_stat.rb#6
class Zip::FileSystem::File::Stat
  # source://rubyzip//lib/zip/filesystem/file_stat.rb#19
  def initialize(zip_fs_file, entry_name); end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def atime; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#89
  def blksize; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def blockdev?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#33
  def blocks; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def chardev?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def ctime; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#59
  def dev; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def directory?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def executable?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def executable_real?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def file?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#75
  def ftype; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#37
  def gid; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def grpowned?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#55
  def ino; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#24
  def kind_of?(type); end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#93
  def mode; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def mtime; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#85
  def nlink; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def owned?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def pipe?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#63
  def rdev; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#67
  def rdev_major; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#71
  def rdev_minor; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def readable?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def readable_real?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def setgid?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def setuid?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def size; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def size?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def socket?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def sticky?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def symlink?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#46
  def uid; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def writable?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def writable_real?; end

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#11
  def zero?; end

  private

  # source://rubyzip//lib/zip/filesystem/file_stat.rb#104
  def find_entry; end

  class << self
    # source://rubyzip//lib/zip/filesystem/file_stat.rb#8
    def delegate_to_fs_file(*methods); end
  end
end

# source://rubyzip//lib/zip/filesystem/zip_file_name_mapper.rb#7
class Zip::FileSystem::ZipFileNameMapper
  include ::Enumerable

  # source://rubyzip//lib/zip/filesystem/zip_file_name_mapper.rb#10
  def initialize(zip_file); end

  # source://rubyzip//lib/zip/filesystem/zip_file_name_mapper.rb#61
  def each; end

  # source://rubyzip//lib/zip/filesystem/zip_file_name_mapper.rb#67
  def expand_path(path); end

  # source://rubyzip//lib/zip/filesystem/zip_file_name_mapper.rb#17
  def find_entry(filename); end

  # source://rubyzip//lib/zip/filesystem/zip_file_name_mapper.rb#21
  def get_entry(filename); end

  # source://rubyzip//lib/zip/filesystem/zip_file_name_mapper.rb#25
  def get_input_stream(filename, &a_proc); end

  # source://rubyzip//lib/zip/filesystem/zip_file_name_mapper.rb#29
  def get_output_stream(filename, permissions = T.unsafe(nil), &a_proc); end

  # source://rubyzip//lib/zip/filesystem/zip_file_name_mapper.rb#35
  def glob(pattern, *flags, &block); end

  # source://rubyzip//lib/zip/filesystem/zip_file_name_mapper.rb#55
  def mkdir(filename, permissions = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/filesystem/zip_file_name_mapper.rb#15
  def pwd; end

  # source://rubyzip//lib/zip/filesystem/zip_file_name_mapper.rb#15
  def pwd=(_arg0); end

  # source://rubyzip//lib/zip/filesystem/zip_file_name_mapper.rb#39
  def read(filename); end

  # source://rubyzip//lib/zip/filesystem/zip_file_name_mapper.rb#43
  def remove(filename); end

  # source://rubyzip//lib/zip/filesystem/zip_file_name_mapper.rb#47
  def rename(filename, new_name, &continue_on_exists_proc); end

  private

  # source://rubyzip//lib/zip/filesystem/zip_file_name_mapper.rb#76
  def expand_to_entry(path); end
end

# source://rubyzip//lib/zip/ioextras.rb#4
module Zip::IOExtras
  class << self
    # source://rubyzip//lib/zip/ioextras.rb#8
    def copy_stream(ostream, istream); end

    # source://rubyzip//lib/zip/ioextras.rb#12
    def copy_stream_n(ostream, istream, nbytes); end
  end
end

# source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#8
module Zip::IOExtras::AbstractInputStream
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#12
  def initialize; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#118
  def each(a_sep_string = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#112
  def each_line(a_sep_string = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#125
  def eof; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#120
  def eof?; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#99
  def flush; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#60
  def gets(a_sep_string = T.unsafe(nil), number_of_bytes = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#19
  def lineno; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#19
  def lineno=(_arg0); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#20
  def pos; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#22
  def read(number_of_bytes = T.unsafe(nil), buf = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#105
  def readline(a_sep_string = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#54
  def readlines(a_sep_string = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#95
  def ungetc(byte); end
end

# source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#7
module Zip::IOExtras::AbstractOutputStream
  include ::Zip::IOExtras::FakeIO

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#15
  def print(*params); end

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#26
  def printf(a_format_string, *params); end

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#31
  def putc(an_object); end

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#43
  def puts(*params); end

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#10
  def write(data); end
end

# source://rubyzip//lib/zip/ioextras.rb#5
Zip::IOExtras::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/ioextras.rb#23
module Zip::IOExtras::FakeIO
  # source://rubyzip//lib/zip/ioextras.rb#24
  def kind_of?(object); end
end

# source://rubyzip//lib/zip/inflater.rb#4
class Zip::Inflater < ::Zip::Decompressor
  # source://rubyzip//lib/zip/inflater.rb#5
  def initialize(*args); end

  # source://rubyzip//lib/zip/inflater.rb#29
  def eof; end

  # source://rubyzip//lib/zip/inflater.rb#24
  def eof?; end

  # source://rubyzip//lib/zip/inflater.rb#12
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  private

  # source://rubyzip//lib/zip/inflater.rb#47
  def input_finished?; end

  # source://rubyzip//lib/zip/inflater.rb#33
  def produce_input; end
end

# source://rubyzip//lib/zip/input_stream.rb#43
class Zip::InputStream
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO
  include ::Zip::IOExtras::AbstractInputStream

  # source://rubyzip//lib/zip/input_stream.rb#54
  def initialize(context, offset: T.unsafe(nil), decrypter: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/input_stream.rb#64
  def close; end

  # source://rubyzip//lib/zip/input_stream.rb#72
  def get_next_entry; end

  # source://rubyzip//lib/zip/input_stream.rb#83
  def rewind; end

  # source://rubyzip//lib/zip/input_stream.rb#98
  def size; end

  # source://rubyzip//lib/zip/input_stream.rb#93
  def sysread(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  protected

  # source://rubyzip//lib/zip/input_stream.rb#147
  def assemble_io; end

  # source://rubyzip//lib/zip/input_stream.rb#179
  def get_decompressor(io); end

  # source://rubyzip//lib/zip/input_stream.rb#159
  def get_decrypted_io; end

  # source://rubyzip//lib/zip/input_stream.rb#122
  def get_io(io_or_file, offset = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/input_stream.rb#204
  def input_finished?; end

  # source://rubyzip//lib/zip/input_stream.rb#134
  def open_entry; end

  # source://rubyzip//lib/zip/input_stream.rb#200
  def produce_input; end

  class << self
    # source://rubyzip//lib/zip/input_stream.rb#108
    def open(filename_or_io, offset: T.unsafe(nil), decrypter: T.unsafe(nil)); end
  end
end

# source://rubyzip//lib/zip/input_stream.rb#44
Zip::InputStream::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#11
Zip::LOCAL_ENTRY_SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#12
Zip::LOCAL_ENTRY_STATIC_HEADER_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#13
Zip::LOCAL_ENTRY_TRAILING_DESCRIPTOR_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/null_compressor.rb#4
class Zip::NullCompressor < ::Zip::Compressor
  include ::Singleton::SingletonInstanceMethods
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # source://rubyzip//lib/zip/null_compressor.rb#7
  def <<(_data); end

  # source://rubyzip//lib/zip/null_compressor.rb#11
  def compressed_size; end

  # source://rubyzip//lib/zip/null_compressor.rb#11
  def size; end

  class << self
    private

    # source://rubyzip//lib/zip/null_compressor.rb#5
    def allocate; end

    # source://rubyzip//lib/zip/null_compressor.rb#5
    def new(*_arg0); end
  end
end

# source://rubyzip//lib/zip/null_decompressor.rb#4
module Zip::NullDecompressor
  private

  # source://rubyzip//lib/zip/null_decompressor.rb#16
  def eof; end

  # source://rubyzip//lib/zip/null_decompressor.rb#11
  def eof?; end

  # source://rubyzip//lib/zip/null_decompressor.rb#7
  def read(_length = T.unsafe(nil), _outbuf = T.unsafe(nil)); end

  class << self
    # source://rubyzip//lib/zip/null_decompressor.rb#11
    def eof?; end

    # source://rubyzip//lib/zip/null_decompressor.rb#7
    def read(_length = T.unsafe(nil), _outbuf = T.unsafe(nil)); end
  end
end

# source://rubyzip//lib/zip/crypto/null_encryption.rb#14
class Zip::NullEncrypter < ::Zip::Encrypter
  include ::Zip::NullEncryption

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#25
  def data_descriptor(_crc32, _compressed_size, _uncompressed_size); end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#21
  def encrypt(data); end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#17
  def header(_mtime); end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#29
  def reset!; end
end

# source://rubyzip//lib/zip/crypto/null_encryption.rb#4
module Zip::NullEncryption
  # source://rubyzip//lib/zip/crypto/null_encryption.rb#9
  def gp_flags; end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#5
  def header_bytesize; end
end

# source://rubyzip//lib/zip/null_input_stream.rb#4
module Zip::NullInputStream
  include ::Zip::NullDecompressor
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO
  include ::Zip::IOExtras::AbstractInputStream
end

# source://rubyzip//lib/zip/output_stream.rb#24
class Zip::OutputStream
  include ::Zip::IOExtras::FakeIO
  include ::Zip::IOExtras::AbstractOutputStream
  extend ::Forwardable

  # source://rubyzip//lib/zip/output_stream.rb#32
  def initialize(file_name, stream: T.unsafe(nil), encrypter: T.unsafe(nil), suppress_extra_fields: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/output_stream.rb#199
  def <<(data); end

  # source://rubyzip//lib/zip/output_stream.rb#76
  def close; end

  # source://rubyzip//lib/zip/output_stream.rb#87
  def close_buffer; end

  # source://rubyzip//lib/zip/output_stream.rb#28
  def comment(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/output_stream.rb#28
  def comment=(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/output_stream.rb#120
  def copy_raw_entry(entry); end

  # source://rubyzip//lib/zip/output_stream.rb#100
  def put_next_entry(entry_name, comment = T.unsafe(nil), extra = T.unsafe(nil), compression_method = T.unsafe(nil), level = T.unsafe(nil)); end

  protected

  # source://rubyzip//lib/zip/output_stream.rb#192
  def finish; end

  private

  # source://rubyzip//lib/zip/output_stream.rb#141
  def finalize_current_entry; end

  # source://rubyzip//lib/zip/output_stream.rb#169
  def get_compressor(entry); end

  # source://rubyzip//lib/zip/output_stream.rb#160
  def init_next_entry(entry); end

  # source://rubyzip//lib/zip/output_stream.rb#180
  def update_local_headers; end

  class << self
    # source://rubyzip//lib/zip/output_stream.rb#55
    def open(file_name, encrypter: T.unsafe(nil), suppress_extra_fields: T.unsafe(nil)); end

    # source://rubyzip//lib/zip/output_stream.rb#66
    def write_buffer(io = T.unsafe(nil), encrypter: T.unsafe(nil), suppress_extra_fields: T.unsafe(nil)); end
  end
end

# source://rubyzip//lib/zip/pass_thru_compressor.rb#4
class Zip::PassThruCompressor < ::Zip::Compressor
  # source://rubyzip//lib/zip/pass_thru_compressor.rb#5
  def initialize(output_stream); end

  # source://rubyzip//lib/zip/pass_thru_compressor.rb#12
  def <<(data); end

  # source://rubyzip//lib/zip/pass_thru_compressor.rb#19
  def crc; end

  # source://rubyzip//lib/zip/pass_thru_compressor.rb#19
  def size; end
end

# source://rubyzip//lib/zip/pass_thru_decompressor.rb#4
class Zip::PassThruDecompressor < ::Zip::Decompressor
  # source://rubyzip//lib/zip/pass_thru_decompressor.rb#5
  def initialize(*args); end

  # source://rubyzip//lib/zip/pass_thru_decompressor.rb#26
  def eof; end

  # source://rubyzip//lib/zip/pass_thru_decompressor.rb#21
  def eof?; end

  # source://rubyzip//lib/zip/pass_thru_decompressor.rb#10
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end
end

# source://rubyzip//lib/zip/constants.rb#6
Zip::RUNNING_ON_WINDOWS = T.let(T.unsafe(nil), T.untyped)

# source://rubyzip//lib/zip/constants.rb#18
Zip::SPLIT_FILE_SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/errors.rb#114
class Zip::SplitArchiveError < ::Zip::Error
  # source://rubyzip//lib/zip/errors.rb#116
  def message; end
end

# source://rubyzip//lib/zip/streamable_directory.rb#4
class Zip::StreamableDirectory < ::Zip::Entry
  # source://rubyzip//lib/zip/streamable_directory.rb#5
  def initialize(zipfile, entry, src_path = T.unsafe(nil), permission = T.unsafe(nil)); end
end

# source://rubyzip//lib/zip/streamable_stream.rb#4
class Zip::StreamableStream
  # source://rubyzip//lib/zip/streamable_stream.rb#5
  def initialize(entry); end

  # source://rubyzip//lib/zip/streamable_stream.rb#46
  def clean_up; end

  # source://rubyzip//lib/zip/streamable_stream.rb#23
  def get_input_stream; end

  # source://rubyzip//lib/zip/streamable_stream.rb#11
  def get_output_stream; end

  # source://rubyzip//lib/zip/streamable_stream.rb#41
  def write_to_zip_output_stream(output_stream); end
end

# source://rubyzip//lib/zip/errors.rb#122
class Zip::StreamingError < ::Zip::Error
  # source://rubyzip//lib/zip/errors.rb#127
  def initialize(entry); end

  # source://rubyzip//lib/zip/errors.rb#124
  def entry; end

  # source://rubyzip//lib/zip/errors.rb#133
  def message; end
end

# source://rubyzip//lib/zip/crypto/traditional_encryption.rb#75
class Zip::TraditionalDecrypter < ::Zip::Decrypter
  include ::Zip::TraditionalEncryption

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#89
  def check_integrity!(_io); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#78
  def decrypt(data); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#82
  def reset!(header); end

  private

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#93
  def decode(num); end
end

# source://rubyzip//lib/zip/crypto/traditional_encryption.rb#41
class Zip::TraditionalEncrypter < ::Zip::Encrypter
  include ::Zip::TraditionalEncryption

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#58
  def data_descriptor(crc32, compressed_size, uncompressed_size); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#54
  def encrypt(data); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#44
  def header(mtime); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#62
  def reset!; end

  private

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#68
  def encode(num); end
end

# source://rubyzip//lib/zip/crypto/traditional_encryption.rb#4
module Zip::TraditionalEncryption
  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#5
  def initialize(password); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#14
  def gp_flags; end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#10
  def header_bytesize; end

  protected

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#35
  def decrypt_byte; end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#20
  def reset_keys!; end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#29
  def update_keys(num); end
end

# source://rubyzip//lib/zip/version.rb#5
Zip::VERSION = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/constants.rb#14
Zip::VERSION_MADE_BY = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#15
Zip::VERSION_NEEDED_TO_EXTRACT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#16
Zip::VERSION_NEEDED_TO_EXTRACT_ZIP64 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip.rb#67
Zip::ZLIB_FLUSHING_STRATEGY = T.let(T.unsafe(nil), Integer)
