# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `idlc` gem.
# Please instead update this file by running `bin/tapioca gem idlc`.


# source://idlc//lib/idlc/syntax_node.rb#48
module Idl
  include ::Treetop::Runtime

  # source://idlc//lib/idlc/idl_parser.rb#6275
  def _nt_ary_access; end

  # source://idlc//lib/idlc/idl_parser.rb#6173
  def _nt_ary_eligible_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#11858
  def _nt_ary_size_decl; end

  # source://idlc//lib/idlc/idl_parser.rb#11104
  def _nt_assignment; end

  # source://idlc//lib/idlc/idl_parser.rb#889
  def _nt_bitfield_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#6576
  def _nt_bits_cast; end

  # source://idlc//lib/idlc/idl_parser.rb#9614
  def _nt_body_function_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#10378
  def _nt_builtin_function_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#16350
  def _nt_builtin_read_only_var; end

  # source://idlc//lib/idlc/idl_parser.rb#16374
  def _nt_builtin_read_write_var; end

  # source://idlc//lib/idlc/idl_parser.rb#14711
  def _nt_builtin_type_name; end

  # source://idlc//lib/idlc/idl_parser.rb#15960
  def _nt_comment; end

  # source://idlc//lib/idlc/idl_parser.rb#5747
  def _nt_concatenation_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#8614
  def _nt_constraint_body; end

  # source://idlc//lib/idlc/idl_parser.rb#5888
  def _nt_csr_field_access_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#16456
  def _nt_csr_field_name; end

  # source://idlc//lib/idlc/idl_parser.rb#16401
  def _nt_csr_name; end

  # source://idlc//lib/idlc/idl_parser.rb#5962
  def _nt_csr_register_access_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#12210
  def _nt_declaration; end

  # source://idlc//lib/idlc/idl_parser.rb#12650
  def _nt_dontcare_lvalue; end

  # source://idlc//lib/idlc/idl_parser.rb#12674
  def _nt_dontcare_return; end

  # source://idlc//lib/idlc/idl_parser.rb#468
  def _nt_enum_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#780
  def _nt_enum_ref; end

  # source://idlc//lib/idlc/idl_parser.rb#6699
  def _nt_enum_to_a; end

  # source://idlc//lib/idlc/idl_parser.rb#13759
  def _nt_execute_if_block; end

  # source://idlc//lib/idlc/idl_parser.rb#8704
  def _nt_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#10833
  def _nt_fetch; end

  # source://idlc//lib/idlc/idl_parser.rb#6058
  def _nt_field_access_eligible_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#6106
  def _nt_field_access_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#15834
  def _nt_field_name; end

  # source://idlc//lib/idlc/idl_parser.rb#14368
  def _nt_for_loop; end

  # source://idlc//lib/idlc/idl_parser.rb#12078
  def _nt_for_loop_iteration_variable_declaration; end

  # source://idlc//lib/idlc/idl_parser.rb#9432
  def _nt_function_arg_list; end

  # source://idlc//lib/idlc/idl_parser.rb#16108
  def _nt_function_body; end

  # source://idlc//lib/idlc/idl_parser.rb#8917
  def _nt_function_call; end

  # source://idlc//lib/idlc/idl_parser.rb#8784
  def _nt_function_call_template_arguments; end

  # source://idlc//lib/idlc/idl_parser.rb#10929
  def _nt_function_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#13101
  def _nt_function_if_block; end

  # source://idlc//lib/idlc/idl_parser.rb#9337
  def _nt_function_name; end

  # source://idlc//lib/idlc/idl_parser.rb#16051
  def _nt_function_statement; end

  # source://idlc//lib/idlc/idl_parser.rb#290
  def _nt_global_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#16286
  def _nt_id; end

  # source://idlc//lib/idlc/idl_parser.rb#8031
  def _nt_implication_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#8248
  def _nt_implication_for_loop; end

  # source://idlc//lib/idlc/idl_parser.rb#8551
  def _nt_implication_statement; end

  # source://idlc//lib/idlc/idl_parser.rb#196
  def _nt_include_statement; end

  # source://idlc//lib/idlc/idl_parser.rb#16192
  def _nt_instruction_operation; end

  # source://idlc//lib/idlc/idl_parser.rb#1529
  def _nt_int; end

  # source://idlc//lib/idlc/idl_parser.rb#26
  def _nt_isa; end

  # source://idlc//lib/idlc/idl_parser.rb#15088
  def _nt_keyword; end

  # source://idlc//lib/idlc/idl_parser.rb#3517
  def _nt_p0_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#2897
  def _nt_p0_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#3635
  def _nt_p1_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#2965
  def _nt_p1_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#3753
  def _nt_p2_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3033
  def _nt_p2_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#3871
  def _nt_p3_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3101
  def _nt_p3_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#3169
  def _nt_p3_template_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#4107
  def _nt_p4_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3213
  def _nt_p4_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#4343
  def _nt_p5_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3260
  def _nt_p5_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#4579
  def _nt_p6_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3313
  def _nt_p6_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#4815
  def _nt_p7_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3340
  def _nt_p7_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#5051
  def _nt_p8_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3393
  def _nt_p8_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#5287
  def _nt_p9_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3417
  def _nt_p9_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#5510
  def _nt_paren_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#6462
  def _nt_post_dec; end

  # source://idlc//lib/idlc/idl_parser.rb#6519
  def _nt_post_inc; end

  # source://idlc//lib/idlc/idl_parser.rb#5594
  def _nt_replication_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#15918
  def _nt_reserved; end

  # source://idlc//lib/idlc/idl_parser.rb#12726
  def _nt_return_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#12908
  def _nt_return_statement; end

  # source://idlc//lib/idlc/idl_parser.rb#10961
  def _nt_rval; end

  # source://idlc//lib/idlc/idl_parser.rb#12382
  def _nt_single_declaration; end

  # source://idlc//lib/idlc/idl_parser.rb#11949
  def _nt_single_declaration_with_initialization; end

  # source://idlc//lib/idlc/idl_parser.rb#16726
  def _nt_space; end

  # source://idlc//lib/idlc/idl_parser.rb#12480
  def _nt_statement; end

  # source://idlc//lib/idlc/idl_parser.rb#16631
  def _nt_string; end

  # source://idlc//lib/idlc/idl_parser.rb#1213
  def _nt_struct_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#8736
  def _nt_template_safe_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3989
  def _nt_template_safe_p3_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#4225
  def _nt_template_safe_p4_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#4461
  def _nt_template_safe_p5_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#4697
  def _nt_template_safe_p6_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#4933
  def _nt_template_safe_p7_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#5169
  def _nt_template_safe_p8_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#5405
  def _nt_template_safe_p9_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#7903
  def _nt_template_safe_ternary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#7782
  def _nt_ternary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#15886
  def _nt_type_name; end

  # source://idlc//lib/idlc/idl_parser.rb#6866
  def _nt_unary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3441
  def _nt_unary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#15767
  def _nt_user_type_name; end

  # source://idlc//lib/idlc/idl_parser.rb#16515
  def _nt_var_write; end

  # source://idlc//lib/idlc/idl_parser.rb#1397
  def _nt_version_string; end

  # source://idlc//lib/idlc/idl_parser.rb#12
  def root; end

  class << self
    # source://idlc//lib/idlc/log.rb#15
    sig { returns(::Logger) }
    def logger; end

    # source://idlc//lib/idlc/log.rb#20
    sig { params(logger: ::Logger).returns(::Logger) }
    def set_logger(logger); end
  end
end

# source://idlc//lib/idlc/ast.rb#1375
class Idl::ArrayIncludesAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1385
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      ary: T.all(::Idl::AstNode, ::Idl::Rvalue),
      value: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, ary, value); end

  # source://idlc//lib/idlc/ast.rb#1379
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def ary; end

  # source://idlc//lib/idlc/ast.rb#1413
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1382
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def expr; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#305
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1419
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1416
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1403
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1390
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1408
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1427
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1369
class Idl::ArrayIncludesSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1370
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#5259
class Idl::ArrayLiteralAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5263
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5267
  def element_nodes; end

  # source://idlc//lib/idlc/ast.rb#5265
  def entries; end

  # source://idlc//lib/idlc/ast.rb#5294
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5291
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5282
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5272
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5286
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5301
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ArrayLiteralAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5253
class Idl::ArrayLiteralSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5254
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1446
class Idl::ArraySizeAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1455
  def initialize(input, interval, expression); end

  # source://idlc//lib/idlc/ast.rb#1453
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1450
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#299
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1487
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1484
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1466
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1459
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1477
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Integer) }
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1494
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1440
class Idl::ArraySizeSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1441
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#6247
module Idl::AryAccess0
  # source://idlc//lib/idlc/idl_parser.rb#6248
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#6254
module Idl::AryAccess1
  # source://idlc//lib/idlc/idl_parser.rb#6259
  def lsb; end

  # source://idlc//lib/idlc/idl_parser.rb#6255
  def msb; end
end

# source://idlc//lib/idlc/idl_parser.rb#6265
module Idl::AryAccess2
  # source://idlc//lib/idlc/idl_parser.rb#6266
  def a; end

  # source://idlc//lib/idlc/idl_parser.rb#6270
  def brackets; end
end

# source://idlc//lib/idlc/ast.rb#2381
class Idl::AryAccessSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2385
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#2401
class Idl::AryElementAccessAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#2416
  def initialize(input, interval, var, index); end

  # source://idlc//lib/idlc/ast.rb#2405
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#229
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2414
  def index; end

  # source://idlc//lib/idlc/ast.rb#2489
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2486
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2451
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#2421
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2466
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#2413
  def var; end

  class << self
    # source://idlc//lib/idlc/ast.rb#2497
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2804
class Idl::AryElementAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#2826
  def initialize(input, interval, lhs, idx, rhs); end

  # source://idlc//lib/idlc/ast.rb#2808
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2865
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#2895
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#253
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2823
  def idx; end

  # source://idlc//lib/idlc/ast.rb#2822
  def lhs; end

  # source://idlc//lib/idlc/ast.rb#2824
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#2933
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2930
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2831
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2942
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AryElementAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2794
class Idl::AryElementAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2795
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#2510
class Idl::AryRangeAccessAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#2528
  def initialize(input, interval, var, msb, lsb); end

  # source://idlc//lib/idlc/ast.rb#2514
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#168
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2526
  def lsb; end

  # source://idlc//lib/idlc/ast.rb#2525
  def msb; end

  # source://idlc//lib/idlc/ast.rb#2584
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2581
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2558
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#2533
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2574
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#2524
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def var; end

  class << self
    # source://idlc//lib/idlc/ast.rb#2595
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2966
class Idl::AryRangeAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#2989
  def initialize(input, interval, variable, msb, lsb, write_value); end

  # source://idlc//lib/idlc/ast.rb#2970
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3026
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#3054
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#20
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2986
  def lsb; end

  # source://idlc//lib/idlc/ast.rb#2985
  def msb; end

  # source://idlc//lib/idlc/ast.rb#3021
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#3063
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#3060
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2994
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2984
  def variable; end

  # source://idlc//lib/idlc/ast.rb#2987
  def write_value; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3075
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AryRangeAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2956
class Idl::AryRangeAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2957
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#11851
module Idl::ArySizeDecl0
  # source://idlc//lib/idlc/idl_parser.rb#11852
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#11011
module Idl::Assignment0
  # source://idlc//lib/idlc/idl_parser.rb#11012
  def var; end
end

# source://idlc//lib/idlc/idl_parser.rb#11018
module Idl::Assignment1
  # source://idlc//lib/idlc/idl_parser.rb#11019
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#11027
  def function_call; end

  # source://idlc//lib/idlc/idl_parser.rb#11023
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#11032
module Idl::Assignment2
  # source://idlc//lib/idlc/idl_parser.rb#11033
  def rval; end
end

# source://idlc//lib/idlc/idl_parser.rb#11038
module Idl::Assignment3
  # source://idlc//lib/idlc/idl_parser.rb#11043
  def rval; end

  # source://idlc//lib/idlc/idl_parser.rb#11039
  def var; end
end

# source://idlc//lib/idlc/idl_parser.rb#11048
module Idl::Assignment4
  # source://idlc//lib/idlc/idl_parser.rb#11049
  def csr_field_access_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#11053
  def rval; end
end

# source://idlc//lib/idlc/idl_parser.rb#11058
module Idl::Assignment5
  # source://idlc//lib/idlc/idl_parser.rb#11063
  def field_name; end

  # source://idlc//lib/idlc/idl_parser.rb#11059
  def id; end

  # source://idlc//lib/idlc/idl_parser.rb#11067
  def rval; end
end

# source://idlc//lib/idlc/idl_parser.rb#11072
module Idl::Assignment6
  # source://idlc//lib/idlc/idl_parser.rb#11081
  def lsb; end

  # source://idlc//lib/idlc/idl_parser.rb#11077
  def msb; end

  # source://idlc//lib/idlc/idl_parser.rb#11085
  def rval; end

  # source://idlc//lib/idlc/idl_parser.rb#11073
  def var; end
end

# source://idlc//lib/idlc/idl_parser.rb#11090
module Idl::Assignment7
  # source://idlc//lib/idlc/idl_parser.rb#11095
  def idx; end

  # source://idlc//lib/idlc/idl_parser.rb#11099
  def rval; end

  # source://idlc//lib/idlc/idl_parser.rb#11091
  def var; end
end

# source://idlc//lib/idlc/type.rb#11
class Idl::AstNode
  abstract!

  # source://idlc//lib/idlc/ast.rb#204
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      children: T::Array[::Idl::AstNode]
    ).void
  end
  def initialize(input, interval, children); end

  # source://idlc//lib/idlc/ast.rb#80
  sig { returns(T::Array[::Idl::AstNode]) }
  def children; end

  # source://idlc//lib/idlc/ast.rb#198
  sig { abstract.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#259
  sig { params(klass: ::Class).returns(T.nilable(::Idl::AstNode)) }
  def find_ancestor(klass); end

  # source://idlc//lib/idlc/ast.rb#436
  sig { params(global_symtab: ::Idl::SymbolTable).returns(::Idl::AstNode) }
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#10
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#16
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#61
  sig { returns(T.nilable(::String)) }
  def input; end

  # source://idlc//lib/idlc/ast.rb#53
  sig { returns(T.nilable(::Pathname)) }
  def input_file; end

  # source://idlc//lib/idlc/ast.rb#587
  sig { returns(::String) }
  def inspect; end

  # source://idlc//lib/idlc/ast.rb#370
  sig { params(reason: ::String).returns(T.noreturn) }
  def internal_error(reason); end

  # source://idlc//lib/idlc/ast.rb#65
  sig { returns(T.nilable(T::Range[::Integer])) }
  def interval; end

  # source://idlc//lib/idlc/ast.rb#252
  sig { returns(::Integer) }
  def lineno; end

  # source://idlc//lib/idlc/ast.rb#277
  sig { returns(::Idl::AstNode::LinesDescriptor) }
  def lines_around; end

  # source://idlc//lib/idlc/passes/prune.rb#64
  def nullify_assignments(symtab); end

  # source://idlc//lib/idlc/ast.rb#76
  sig { returns(T.nilable(::Idl::AstNode)) }
  def parent; end

  # source://idlc//lib/idlc/passes/find_return_values.rb#11
  def pass_find_return_values(values, current_conditions); end

  # source://idlc//lib/idlc/ast.rb#445
  sig { returns(::String) }
  def path; end

  # source://idlc//lib/idlc/ast.rb#419
  sig { params(indent: ::Integer, indent_size: ::Integer, io: ::IO).void }
  def print_ast(indent = T.unsafe(nil), indent_size: T.unsafe(nil), io: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#45
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#13
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#12
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#241
  sig { params(filename: T.any(::Pathname, ::String), starting_line: ::Integer).void }
  def set_input_file(filename, starting_line = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#225
  sig { params(filename: T.any(::Pathname, ::String), starting_line: ::Integer).void }
  def set_input_file_unless_already_set(filename, starting_line = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#484
  sig { returns(T::Hash[::String, T.untyped]) }
  def source_yaml; end

  # source://idlc//lib/idlc/ast.rb#57
  sig { returns(::Integer) }
  def starting_line; end

  # source://idlc//lib/idlc/ast.rb#69
  sig { returns(::String) }
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#504
  sig { abstract.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#477
  sig { abstract.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#480
  sig { overridable.returns(::String) }
  def to_idl_verbose; end

  # source://idlc//lib/idlc/ast.rb#305
  sig { params(reason: ::String).void }
  def truncation_warn(reason); end

  # source://idlc//lib/idlc/ast.rb#467
  sig { abstract.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#321
  sig { params(reason: ::String).returns(T.noreturn) }
  def type_error(reason); end

  # source://idlc//lib/idlc/ast.rb#409
  sig { params(s: ::String).returns(::String) }
  def unindent(s); end

  # source://idlc//lib/idlc/ast.rb#192
  sig { params(value_result: T.untyped, block: T.proc.returns(T.untyped)).returns(T.untyped) }
  def value_else(value_result, &block); end

  # source://idlc//lib/idlc/ast.rb#400
  sig { params(reason: ::String).returns(T.noreturn) }
  def value_error(reason); end

  # source://idlc//lib/idlc/ast.rb#182
  sig { params(block: T.proc.params(arg0: ::Object).returns(T.untyped)).returns(T.untyped) }
  def value_try(&block); end

  class << self
    # source://idlc//lib/idlc/ast.rb#507
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end

    # source://idlc//lib/idlc/ast.rb#493
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(T.nilable(::String))
    end
    def input_from_source_yaml(yaml, source_mapper); end

    # source://idlc//lib/idlc/ast.rb#499
    sig { params(yaml: T::Hash[::String, T.untyped]).returns(T.nilable(T::Range[::Integer])) }
    def interval_from_source_yaml(yaml); end

    # source://idlc//lib/idlc/ast.rb#185
    sig { params(value_result: T.untyped, _block: T.proc.returns(T.untyped)).returns(T.untyped) }
    def value_else(value_result, &_block); end

    # source://idlc//lib/idlc/ast.rb#391
    sig { params(reason: ::String, ast: T.nilable(::Idl::AstNode)).returns(T.noreturn) }
    def value_error(reason, ast = T.unsafe(nil)); end

    # source://idlc//lib/idlc/ast.rb#383
    def value_error_ast; end

    # source://idlc//lib/idlc/ast.rb#383
    def value_error_ast=(_arg0); end

    # source://idlc//lib/idlc/ast.rb#383
    def value_error_reason; end

    # source://idlc//lib/idlc/ast.rb#383
    def value_error_reason=(_arg0); end

    # source://idlc//lib/idlc/ast.rb#178
    sig { params(block: T.proc.params(arg0: ::Object).returns(T.untyped)).returns(T.untyped) }
    def value_try(&block); end
  end
end

# source://idlc//lib/idlc/ast.rb#40
Idl::AstNode::Bits1Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#42
Idl::AstNode::Bits32Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#44
Idl::AstNode::Bits64Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#47
Idl::AstNode::BoolType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#46
Idl::AstNode::ConstBoolType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#113
class Idl::AstNode::InternalError < ::StandardError
  # source://idlc//lib/idlc/ast.rb#129
  sig { params(what: ::String).void }
  def initialize(what); end

  # source://idlc//lib/idlc/ast.rb#126
  sig { returns(T::Array[::String]) }
  def bt; end

  # source://idlc//lib/idlc/ast.rb#118
  sig { returns(::String) }
  def what; end
end

# source://idlc//lib/idlc/ast.rb#269
class Idl::AstNode::LinesDescriptor < ::T::Struct
  const :lines, ::String
  const :problem_interval, T::Range[T.untyped]
  const :lines_interval, T::Range[T.untyped]
end

# source://idlc//lib/idlc/ast.rb#41
Idl::AstNode::PossiblyUnknownBits1Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#43
Idl::AstNode::PossiblyUnknownBits32Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#45
Idl::AstNode::PossiblyUnknownBits64Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#49
Idl::AstNode::StringType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#83
class Idl::AstNode::TypeError < ::StandardError
  # source://idlc//lib/idlc/ast.rb#100
  sig { params(what: ::String).void }
  def initialize(what); end

  # source://idlc//lib/idlc/ast.rb#96
  sig { returns(T::Array[::String]) }
  def bt; end

  # source://idlc//lib/idlc/ast.rb#88
  sig { returns(::String) }
  def what; end
end

# source://idlc//lib/idlc/ast.rb#143
class Idl::AstNode::ValueError < ::StandardError
  # source://idlc//lib/idlc/ast.rb#156
  sig { params(lineno: ::Integer, file: ::String, reason: ::String).void }
  def initialize(lineno, file, reason); end

  # source://idlc//lib/idlc/ast.rb#150
  sig { returns(::String) }
  def file; end

  # source://idlc//lib/idlc/ast.rb#147
  sig { returns(::Integer) }
  def lineno; end

  # source://idlc//lib/idlc/ast.rb#167
  sig { returns(::String) }
  def message; end

  # source://idlc//lib/idlc/ast.rb#153
  sig { returns(::String) }
  def reason; end

  # source://idlc//lib/idlc/ast.rb#164
  sig { returns(::String) }
  def what; end
end

# source://idlc//lib/idlc/ast.rb#48
Idl::AstNode::VoidType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#17
Idl::BasicValueRbType = T.type_alias { T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean) }

# source://idlc//lib/idlc/ast.rb#4392
class Idl::BinaryExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4411
  def initialize(input, interval, lhs, op, rhs); end

  # source://idlc//lib/idlc/ast.rb#4681
  def bits_needed(value, signed); end

  # source://idlc//lib/idlc/ast.rb#4401
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#235
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#4418
  def invert(symtab); end

  # source://idlc//lib/idlc/ast.rb#4407
  def lhs; end

  # source://idlc//lib/idlc/ast.rb#4708
  def max_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#4851
  def min_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#5195
  def op; end

  # source://idlc//lib/idlc/passes/prune.rb#239
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#4408
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#4454
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4449
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4477
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4577
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5001
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4463
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::BinaryExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4397
Idl::BinaryExpressionAst::ARITH_OPS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#4396
Idl::BinaryExpressionAst::BIT_OPS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#4395
Idl::BinaryExpressionAst::LOGICAL_OPS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#4398
Idl::BinaryExpressionAst::OPS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#3937
class Idl::BinaryExpressionRightSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3941
  def to_ast; end

  # source://idlc//lib/idlc/ast.rb#3958
  def type_check(_symtab); end
end

# source://idlc//lib/idlc/idl_parser.rb#847
module Idl::BitfieldDefinition0
  # source://idlc//lib/idlc/idl_parser.rb#848
  def int; end
end

# source://idlc//lib/idlc/idl_parser.rb#853
module Idl::BitfieldDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#854
  def int; end

  # source://idlc//lib/idlc/idl_parser.rb#858
  def lsb; end
end

# source://idlc//lib/idlc/idl_parser.rb#863
module Idl::BitfieldDefinition2
  # source://idlc//lib/idlc/idl_parser.rb#864
  def field_name; end

  # source://idlc//lib/idlc/idl_parser.rb#868
  def range; end
end

# source://idlc//lib/idlc/idl_parser.rb#874
module Idl::BitfieldDefinition3
  # source://idlc//lib/idlc/idl_parser.rb#883
  def e; end

  # source://idlc//lib/idlc/idl_parser.rb#875
  def int; end

  # source://idlc//lib/idlc/idl_parser.rb#879
  def user_type_name; end
end

# source://idlc//lib/idlc/ast.rb#2113
class Idl::BitfieldDefinitionAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#2119
  def initialize(input, interval, name, size, fields); end

  # source://idlc//lib/idlc/ast.rb#2172
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#2117
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2144
  def element_names; end

  # source://idlc//lib/idlc/ast.rb#2152
  def element_ranges(symtab); end

  # source://idlc//lib/idlc/ast.rb#2128
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/ast.rb#2194
  def name; end

  # source://idlc//lib/idlc/ast.rb#2139
  def size(symtab); end

  # source://idlc//lib/idlc/ast.rb#2211
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2201
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2182
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#2159
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2197
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2220
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2082
class Idl::BitfieldDefinitionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2083
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1997
class Idl::BitfieldFieldDefinitionAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#2004
  def initialize(input, interval, name, msb, lsb); end

  # source://idlc//lib/idlc/ast.rb#2002
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1999
  def name; end

  # source://idlc//lib/idlc/ast.rb#2039
  def range(symtab); end

  # source://idlc//lib/idlc/ast.rb#2057
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2048
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2017
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2068
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/type.rb#711
class Idl::BitfieldType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#712
  def initialize(type_name, width, field_names, field_ranges); end

  # source://idlc//lib/idlc/type.rb#732
  def clone; end

  # source://idlc//lib/idlc/type.rb#728
  def field_names; end

  # source://idlc//lib/idlc/type.rb#721
  def range(field_name); end
end

# source://idlc//lib/idlc/type.rb#996
Idl::Bits1Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/type.rb#997
Idl::Bits32Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/type.rb#998
Idl::Bits64Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/idl_parser.rb#6569
module Idl::BitsCast0
  # source://idlc//lib/idlc/idl_parser.rb#6570
  def expr; end
end

# source://idlc//lib/idlc/ast.rb#4303
class Idl::BitsCastAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4314
  def initialize(input, interval, exp); end

  # source://idlc//lib/idlc/ast.rb#4307
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4312
  def expr; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#102
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#506
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#4373
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4370
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4326
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4317
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#4347
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4380
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::BitsCastAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4292
class Idl::BitsCastSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4293
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#999
Idl::BitsUnknownType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/idl_parser.rb#9522
module Idl::BodyFunctionDefinition0; end

# source://idlc//lib/idlc/idl_parser.rb#9525
module Idl::BodyFunctionDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#9526
  def single_declaration; end
end

# source://idlc//lib/idlc/idl_parser.rb#9531
module Idl::BodyFunctionDefinition2
  # source://idlc//lib/idlc/idl_parser.rb#9532
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#9536
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#9542
module Idl::BodyFunctionDefinition3
  # source://idlc//lib/idlc/idl_parser.rb#9543
  def type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#9548
module Idl::BodyFunctionDefinition4
  # source://idlc//lib/idlc/idl_parser.rb#9549
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#9553
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#9559
module Idl::BodyFunctionDefinition5
  # source://idlc//lib/idlc/idl_parser.rb#9560
  def single_declaration; end
end

# source://idlc//lib/idlc/idl_parser.rb#9565
module Idl::BodyFunctionDefinition6
  # source://idlc//lib/idlc/idl_parser.rb#9566
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#9570
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#9576
module Idl::BodyFunctionDefinition7
  # source://idlc//lib/idlc/idl_parser.rb#9577
  def function_body; end
end

# source://idlc//lib/idlc/idl_parser.rb#9583
module Idl::BodyFunctionDefinition8
  # source://idlc//lib/idlc/idl_parser.rb#9600
  def args; end

  # source://idlc//lib/idlc/idl_parser.rb#9608
  def body_block; end

  # source://idlc//lib/idlc/idl_parser.rb#9604
  def desc; end

  # source://idlc//lib/idlc/idl_parser.rb#9588
  def function_name; end

  # source://idlc//lib/idlc/idl_parser.rb#9596
  def ret; end

  # source://idlc//lib/idlc/idl_parser.rb#9592
  def targs; end

  # source://idlc//lib/idlc/idl_parser.rb#9584
  def type; end
end

# source://idlc//lib/idlc/type.rb#1002
Idl::BoolType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#1932
class Idl::BuiltinEnumDefinitionAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#1939
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      user_type: ::Idl::UserTypeNameAst
    ).void
  end
  def initialize(input, interval, user_type); end

  # source://idlc//lib/idlc/ast.rb#1966
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#1936
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1952
  def element_names(symtab); end

  # source://idlc//lib/idlc/ast.rb#1956
  def element_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#1971
  def name; end

  # source://idlc//lib/idlc/ast.rb#1978
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1975
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1961
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1945
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1985
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1921
class Idl::BuiltinEnumDefinitionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1922
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#10331
module Idl::BuiltinFunctionDefinition0
  # source://idlc//lib/idlc/idl_parser.rb#10332
  def first; end
end

# source://idlc//lib/idlc/idl_parser.rb#10338
module Idl::BuiltinFunctionDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#10339
  def single_declaration; end
end

# source://idlc//lib/idlc/idl_parser.rb#10344
module Idl::BuiltinFunctionDefinition2
  # source://idlc//lib/idlc/idl_parser.rb#10345
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#10349
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#10355
module Idl::BuiltinFunctionDefinition3
  # source://idlc//lib/idlc/idl_parser.rb#10368
  def args; end

  # source://idlc//lib/idlc/idl_parser.rb#10372
  def desc; end

  # source://idlc//lib/idlc/idl_parser.rb#10360
  def function_name; end

  # source://idlc//lib/idlc/idl_parser.rb#10364
  def ret; end

  # source://idlc//lib/idlc/idl_parser.rb#10356
  def type; end
end

# source://idlc//lib/idlc/idl_parser.rb#14689
module Idl::BuiltinTypeName0; end

# source://idlc//lib/idlc/idl_parser.rb#14692
module Idl::BuiltinTypeName1
  # source://idlc//lib/idlc/idl_parser.rb#14693
  def i; end
end

# source://idlc//lib/idlc/idl_parser.rb#14699
module Idl::BuiltinTypeName2; end

# source://idlc//lib/idlc/idl_parser.rb#14702
module Idl::BuiltinTypeName3; end

# source://idlc//lib/idlc/idl_parser.rb#14705
module Idl::BuiltinTypeName4; end

# source://idlc//lib/idlc/idl_parser.rb#14708
module Idl::BuiltinTypeName5; end

# source://idlc//lib/idlc/ast.rb#6868
class Idl::BuiltinTypeNameAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#6875
  def initialize(input, interval, type_name, bits_expression); end

  # source://idlc//lib/idlc/ast.rb#6873
  def bits_expression; end

  # source://idlc//lib/idlc/ast.rb#6871
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6902
  def freeze_tree(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#192
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6964
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6955
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6921
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#6885
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6981
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::BuiltinTypeNameAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6847
class Idl::BuiltinTypeNameSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6848
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#5575
class Idl::BuiltinVariableAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5594
  sig { params(input: T.nilable(::String), interval: T.nilable(T::Range[::Integer]), name: ::String).void }
  def initialize(input, interval, name); end

  # source://idlc//lib/idlc/ast.rb#5579
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#213
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5590
  def name; end

  # source://idlc//lib/idlc/ast.rb#5591
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#5626
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5623
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5603
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5599
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5618
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5633
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::BuiltinVariableAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5645
class Idl::BuiltinVariableSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5646
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#15950
module Idl::Comment0; end

# source://idlc//lib/idlc/idl_parser.rb#15953
module Idl::Comment1
  # source://idlc//lib/idlc/idl_parser.rb#15954
  def content; end
end

# source://idlc//lib/idlc/ast.rb#6805
class Idl::CommentAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#6809
  def initialize(input, interval, text); end

  # source://idlc//lib/idlc/ast.rb#6807
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6822
  def content; end

  # source://idlc//lib/idlc/ast.rb#6814
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#6828
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6825
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6817
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6835
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CommentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6800
class Idl::CommentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6801
  def to_ast; end
end

# source://idlc//lib/idlc.rb#63
class Idl::Compiler
  # source://idlc//lib/idlc.rb#68
  def initialize; end

  # source://idlc//lib/idlc.rb#376
  sig { params(body: ::String, symtab: ::Idl::SymbolTable, pass_error: T::Boolean).returns(::Idl::ConstraintBodyAst) }
  def compile_constraint(body, symtab, pass_error: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#332
  def compile_expression(expression, symtab, pass_error: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#84
  def compile_file(path, source_mapper = T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#151
  sig { params(loop: ::String, symtab: ::Idl::SymbolTable, pass_error: T::Boolean).returns(::Idl::ForLoopAst) }
  def compile_for_loop(loop, symtab, pass_error: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#204
  def compile_func_body(body, return_type: T.unsafe(nil), symtab: T.unsafe(nil), name: T.unsafe(nil), input_file: T.unsafe(nil), input_line: T.unsafe(nil), no_rescue: T.unsafe(nil), extra_syms: T.unsafe(nil), type_check: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#293
  def compile_inst_operation(inst, symtab:, input_file: T.unsafe(nil), input_line: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#266
  def compile_inst_scope(idl, symtab:, input_file:, input_line: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#66
  def parser; end

  # source://idlc//lib/idlc.rb#73
  def pb=(pb); end

  # source://idlc//lib/idlc.rb#304
  def type_check(ast, symtab, what); end

  # source://idlc//lib/idlc.rb#79
  def unset_pb; end

  class << self
    # source://idlc//lib/idlc/version.rb#8
    def version; end
  end
end

# source://idlc//lib/idlc/idl_parser.rb#5730
module Idl::ConcatenationExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5731
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#5736
module Idl::ConcatenationExpression1
  # source://idlc//lib/idlc/idl_parser.rb#5737
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#5741
  def rest; end
end

# source://idlc//lib/idlc/ast.rb#5323
class Idl::ConcatenationExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5327
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5329
  def expressions; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#97
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5395
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5392
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5345
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5332
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5380
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5402
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ConcatenationExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5313
class Idl::ConcatenationExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5314
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#6720
class Idl::ConditionalReturnStatementAst < ::Idl::AstNode
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#6729
  def initialize(input, interval, return_expression, condition); end

  # source://idlc//lib/idlc/ast.rb#6727
  def condition; end

  # source://idlc//lib/idlc/ast.rb#6724
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#25
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#413
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#150
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#137
  def reachable_functions(symtab, cache); end

  # source://idlc//lib/idlc/ast.rb#6726
  def return_expression; end

  # source://idlc//lib/idlc/ast.rb#6741
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#6746
  def return_types(symtab); end

  # source://idlc//lib/idlc/ast.rb#6752
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#6761
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#6778
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6775
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6734
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6786
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ConditionalReturnStatementAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6714
class Idl::ConditionalReturnStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6715
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#6329
class Idl::ConditionalStatementAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#6336
  def initialize(input, interval, action, condition); end

  # source://idlc//lib/idlc/ast.rb#6330
  def action; end

  # source://idlc//lib/idlc/ast.rb#6331
  def condition; end

  # source://idlc//lib/idlc/ast.rb#6334
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6350
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#6366
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#283
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#428
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#166
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#154
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6377
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6372
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6341
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6385
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ConditionalStatementAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6319
class Idl::ConditionalStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6320
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#1000
Idl::ConstBitsUnknownType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/type.rb#1001
Idl::ConstBoolType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/idl_parser.rb#8601
module Idl::ConstraintBody0
  # source://idlc//lib/idlc/idl_parser.rb#8602
  def i; end
end

# source://idlc//lib/idlc/idl_parser.rb#8608
module Idl::ConstraintBody1
  # source://idlc//lib/idlc/idl_parser.rb#8609
  def b; end
end

# source://idlc//lib/idlc/ast.rb#4106
class Idl::ConstraintBodyAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#4114
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      stmts: T::Array[T.any(::Idl::ForLoopAst, ::Idl::ImplicationStatementAst)]
    ).void
  end
  def initialize(input, interval, stmts); end

  # source://idlc//lib/idlc/ast.rb#4119
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4132
  sig { params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def satisfied?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4122
  sig { returns(T::Array[T.any(::Idl::ForLoopAst, ::Idl::ImplicationStatementAst)]) }
  def stmts; end

  # source://idlc//lib/idlc/ast.rb#4144
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4139
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4125
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4151
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ConstraintBodyAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4095
class Idl::ConstraintBodySyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4097
  sig { override.returns(::Idl::ConstraintBodyAst) }
  def to_ast; end
end

# source://idlc//lib/idlc/interfaces.rb#119
module Idl::Csr
  interface!

  # source://idlc//lib/idlc/interfaces.rb#134
  sig { abstract.returns(T::Boolean) }
  def dynamic_length?; end

  # source://idlc//lib/idlc/interfaces.rb#137
  sig { abstract.returns(T::Array[::Idl::CsrField]) }
  def fields; end

  # source://idlc//lib/idlc/interfaces.rb#128
  sig { abstract.params(base: T.nilable(::Integer)).returns(T.nilable(::Integer)) }
  def length(base); end

  # source://idlc//lib/idlc/interfaces.rb#131
  sig { abstract.returns(::Integer) }
  def max_length; end

  # source://idlc//lib/idlc/interfaces.rb#125
  sig { abstract.returns(::String) }
  def name; end

  # source://idlc//lib/idlc/interfaces.rb#142
  sig { abstract.returns(T.nilable(::Integer)) }
  def value; end
end

# source://idlc//lib/idlc/interfaces.rb#73
module Idl::CsrField
  interface!

  # source://idlc//lib/idlc/interfaces.rb#97
  sig { abstract.returns(T::Boolean) }
  def base32_only?; end

  # source://idlc//lib/idlc/interfaces.rb#93
  sig { abstract.returns(T::Boolean) }
  def base64_only?; end

  # source://idlc//lib/idlc/interfaces.rb#83
  sig { abstract.returns(T::Boolean) }
  def defined_in_all_bases?; end

  # source://idlc//lib/idlc/interfaces.rb#86
  sig { abstract.returns(T::Boolean) }
  def defined_in_base32?; end

  # source://idlc//lib/idlc/interfaces.rb#89
  sig { abstract.returns(T::Boolean) }
  def defined_in_base64?; end

  # source://idlc//lib/idlc/interfaces.rb#113
  sig { abstract.returns(T::Boolean) }
  def exists?; end

  # source://idlc//lib/idlc/interfaces.rb#102
  sig { abstract.params(base: T.nilable(::Integer)).returns(T::Range[::Integer]) }
  def location(base); end

  # source://idlc//lib/idlc/interfaces.rb#79
  sig { abstract.returns(::String) }
  def name; end

  # source://idlc//lib/idlc/interfaces.rb#116
  sig do
    abstract
      .returns(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)]))
  end
  def reset_value; end

  # source://idlc//lib/idlc/interfaces.rb#108
  sig { abstract.params(base: T.nilable(::Integer)).returns(T.nilable(::String)) }
  def type(base); end

  # source://idlc//lib/idlc/interfaces.rb#105
  sig { abstract.params(base: T.nilable(::Integer)).returns(::Integer) }
  def width(base); end
end

# source://idlc//lib/idlc/idl_parser.rb#5878
module Idl::CsrFieldAccessExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5879
  def csr; end

  # source://idlc//lib/idlc/idl_parser.rb#5883
  def csr_field_name; end
end

# source://idlc//lib/idlc/ast.rb#3237
class Idl::CsrFieldAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#3247
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      csr_field: ::Idl::CsrFieldReadExpressionAst,
      write_value: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, csr_field, write_value); end

  # source://idlc//lib/idlc/ast.rb#3241
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3243
  def csr_field; end

  # source://idlc//lib/idlc/ast.rb#3268
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#3273
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#3256
  def field(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#112
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#476
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#3279
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#3276
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#3252
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#3260
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#3244
  def write_value; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3287
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrFieldAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3231
class Idl::CsrFieldAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3232
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16453
module Idl::CsrFieldName0; end

# source://idlc//lib/idlc/ast.rb#9276
class Idl::CsrFieldReadExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#9290
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      csr: ::Idl::CsrReadExpressionAst,
      field_name: ::String
    ).void
  end
  def initialize(input, interval, csr, field_name); end

  # source://idlc//lib/idlc/ast.rb#9371
  sig { params(symtab: ::Idl::SymbolTable).returns(T.nilable(::Idl::Type)) }
  def calc_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#9404
  sig { params(symtab: ::Idl::SymbolTable).void }
  def calc_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#9287
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9319
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Csr) }
  def csr_def(symtab); end

  # source://idlc//lib/idlc/ast.rb#9324
  sig { returns(::String) }
  def csr_name; end

  # source://idlc//lib/idlc/ast.rb#9299
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Csr) }
  def csr_obj(symtab); end

  # source://idlc//lib/idlc/ast.rb#9327
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::CsrField) }
  def field_def(symtab); end

  # source://idlc//lib/idlc/ast.rb#9332
  sig { params(symtab: ::Idl::SymbolTable).returns(::String) }
  def field_name(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#317
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#482
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#9343
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#9338
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#9365
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#9311
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#9391
  sig do
    override
      .params(
        symtab: ::Idl::SymbolTable
      ).returns(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)]))
  end
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9351
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrFieldReadExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#9279
class Idl::CsrFieldReadExpressionAst::MemoizedState < ::T::Struct
  prop :csr, T.nilable(::Idl::Csr)
  prop :type, T.nilable(::Idl::Type)
  prop :value_calculated, T::Boolean
  prop :value, T.nilable(::Integer)
end

# source://idlc//lib/idlc/ast.rb#9431
class Idl::CsrFieldReadExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#9432
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#9599
class Idl::CsrFunctionCallAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#9617
  def initialize(input, interval, function_name, csr, args); end

  # source://idlc//lib/idlc/ast.rb#9615
  def args; end

  # source://idlc//lib/idlc/ast.rb#9603
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9614
  def csr; end

  # source://idlc//lib/idlc/ast.rb#9655
  def csr_def(symtab); end

  # source://idlc//lib/idlc/ast.rb#9649
  def csr_known?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9653
  def csr_name; end

  # source://idlc//lib/idlc/ast.rb#9612
  def function_name; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#76
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#9684
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#9679
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#9632
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#9622
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#9660
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9693
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrFunctionCallAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#9584
class Idl::CsrFunctionCallSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#9585
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16398
module Idl::CsrName0; end

# source://idlc//lib/idlc/ast.rb#9437
class Idl::CsrReadExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#9445
  def initialize(input, interval, csr_name); end

  # source://idlc//lib/idlc/ast.rb#9441
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9471
  def csr_def(symtab); end

  # source://idlc//lib/idlc/ast.rb#9475
  def csr_known?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9443
  def csr_name; end

  # source://idlc//lib/idlc/ast.rb#9451
  def freeze_tree(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#325
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#494
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#9493
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#9490
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#9464
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#9467
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#9480
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9500
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrReadExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#9425
class Idl::CsrReadExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#9426
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#5955
module Idl::CsrRegisterAccessExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5956
  def csr_name; end
end

# source://idlc//lib/idlc/ast.rb#9517
class Idl::CsrSoftwareWriteAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#9526
  def initialize(input, interval, csr, expression); end

  # source://idlc//lib/idlc/ast.rb#9521
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9523
  def csr; end

  # source://idlc//lib/idlc/ast.rb#9540
  def csr_known?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9544
  def csr_name; end

  # source://idlc//lib/idlc/ast.rb#9552
  def execute(_symtab); end

  # source://idlc//lib/idlc/ast.rb#9555
  def execute_unknown(_symtab); end

  # source://idlc//lib/idlc/ast.rb#9524
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#82
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#9562
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#9559
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#9530
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#9547
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9570
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrSoftwareWriteAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#9511
class Idl::CsrSoftwareWriteSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#9512
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#744
class Idl::CsrType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#751
  sig { params(csr: ::Idl::Csr, qualifiers: T::Array[::Symbol]).void }
  def initialize(csr, qualifiers: T.unsafe(nil)); end

  # source://idlc//lib/idlc/type.rb#748
  sig { returns(::Idl::Csr) }
  def csr; end

  # source://idlc//lib/idlc/type.rb#756
  sig { returns(T::Array[::Idl::CsrField]) }
  def fields; end
end

# source://idlc//lib/idlc/ast.rb#9711
class Idl::CsrWriteAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#9719
  def initialize(input, interval, idx); end

  # source://idlc//lib/idlc/ast.rb#9715
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9735
  def csr_def(symtab); end

  # source://idlc//lib/idlc/ast.rb#9754
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#9759
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#9717
  def idx; end

  # source://idlc//lib/idlc/ast.rb#9749
  def name(symtab); end

  # source://idlc//lib/idlc/ast.rb#9766
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#9763
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#9745
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#9724
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9773
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrWriteAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#9707
class Idl::CsrWriteSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#9708
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#820
module Idl::Declaration
  interface!

  # source://idlc//lib/idlc/ast.rb#830
  sig { abstract.params(symtab: ::Idl::SymbolTable).void }
  def add_symbol(symtab); end
end

# source://idlc//lib/idlc/idl_parser.rb#12189
module Idl::Declaration0
  # source://idlc//lib/idlc/idl_parser.rb#12190
  def id; end
end

# source://idlc//lib/idlc/idl_parser.rb#12195
module Idl::Declaration1
  # source://idlc//lib/idlc/idl_parser.rb#12200
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#12204
  def rest; end

  # source://idlc//lib/idlc/idl_parser.rb#12196
  def type_name; end
end

# source://idlc//lib/idlc/ast.rb#6471
class Idl::DontCareLvalueAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#6477
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#6475
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6496
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6493
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6485
  def type(_symtab); end

  # source://idlc//lib/idlc/ast.rb#6480
  def type_check(_symtab); end

  # source://idlc//lib/idlc/ast.rb#6490
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6502
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::DontCareLvalueAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6467
class Idl::DontCareLvalueSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6468
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#6408
class Idl::DontCareReturnAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#6414
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#6412
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#61
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6442
  def set_expected_type(t); end

  # source://idlc//lib/idlc/ast.rb#6450
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6447
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6424
  def type(_symtab); end

  # source://idlc//lib/idlc/ast.rb#6419
  def type_check(_symtab); end

  # source://idlc//lib/idlc/ast.rb#6429
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6456
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::DontCareReturnAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6398
class Idl::DontCareReturnSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6399
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#35
Idl::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#8862
class Idl::ElseIfAst < ::Idl::AstNode
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#8877
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      body_interval: T.nilable(T::Range[::Integer]),
      cond: T.all(::Idl::AstNode, ::Idl::Rvalue),
      body_stmts: T::Array[::Idl::StatementAst]
    ).void
  end
  def initialize(input, interval, body_interval, cond, body_stmts); end

  # source://idlc//lib/idlc/ast.rb#8874
  sig { returns(::Idl::IfBodyAst) }
  def body; end

  # source://idlc//lib/idlc/ast.rb#8871
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def cond; end

  # source://idlc//lib/idlc/ast.rb#8866
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/prune.rb#343
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#8898
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#8903
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#8914
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#8931
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#8926
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#8882
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#8939
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ElseIfAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1714
class Idl::EnumArrayCastAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1723
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      enum_class_name: ::Idl::UserTypeNameAst
    ).void
  end
  def initialize(input, interval, enum_class_name); end

  # source://idlc//lib/idlc/ast.rb#1720
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1717
  def enum_class; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#132
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1748
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1745
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1731
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1727
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1740
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1755
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::EnumArrayCastAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1705
class Idl::EnumArrayCastSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1706
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1630
class Idl::EnumCastAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1651
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      user_type_name: ::Idl::UserTypeNameAst,
      expression: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, user_type_name, expression); end

  # source://idlc//lib/idlc/ast.rb#1634
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1637
  def enum_name; end

  # source://idlc//lib/idlc/ast.rb#1640
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#107
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1684
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1681
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1673
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1655
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1678
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1692
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1624
class Idl::EnumCastSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1625
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#433
module Idl::EnumDefinition0
  # source://idlc//lib/idlc/idl_parser.rb#434
  def user_type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#440
module Idl::EnumDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#441
  def int; end
end

# source://idlc//lib/idlc/idl_parser.rb#447
module Idl::EnumDefinition2
  # source://idlc//lib/idlc/idl_parser.rb#452
  def i; end

  # source://idlc//lib/idlc/idl_parser.rb#448
  def user_type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#457
module Idl::EnumDefinition3
  # source://idlc//lib/idlc/idl_parser.rb#462
  def e; end

  # source://idlc//lib/idlc/idl_parser.rb#458
  def user_type_name; end
end

# source://idlc//lib/idlc/type.rb#12
class Idl::EnumDefinitionAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#1815
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      user_type: ::Idl::UserTypeNameAst,
      element_names: T::Array[::Idl::UserTypeNameAst],
      element_values: T::Array[T.nilable(::Idl::IntLiteralAst)]
    ).void
  end
  def initialize(input, interval, user_type, element_names, element_values); end

  # source://idlc//lib/idlc/ast.rb#1864
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#1804
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1839
  sig { returns(T::Array[::String]) }
  def element_names; end

  # source://idlc//lib/idlc/ast.rb#1849
  sig { returns(T::Array[::Integer]) }
  def element_values; end

  # source://idlc//lib/idlc/ast.rb#1880
  def name; end

  # source://idlc//lib/idlc/ast.rb#1894
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1884
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1872
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1852
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1877
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1907
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1767
class Idl::EnumDefinitionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1768
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1576
class Idl::EnumElementSizeAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1585
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      enum_class_name: ::Idl::UserTypeNameAst
    ).void
  end
  def initialize(input, interval, enum_class_name); end

  # source://idlc//lib/idlc/ast.rb#1582
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1579
  def enum_class; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#127
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1605
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1602
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1593
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1589
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1597
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1612
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1567
class Idl::EnumElementSizeSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1568
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#770
module Idl::EnumRef0
  # source://idlc//lib/idlc/idl_parser.rb#771
  def enum_class; end

  # source://idlc//lib/idlc/idl_parser.rb#775
  def member; end
end

# source://idlc//lib/idlc/ast.rb#5843
class Idl::EnumRefAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5852
  def initialize(input, interval, class_name, member_name); end

  # source://idlc//lib/idlc/ast.rb#5849
  def class_name; end

  # source://idlc//lib/idlc/ast.rb#5847
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5861
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#117
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#148
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#5850
  def member_name; end

  # source://idlc//lib/idlc/ast.rb#5910
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5907
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5884
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5874
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5900
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5918
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::EnumRefAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5832
class Idl::EnumRefSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5833
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1516
class Idl::EnumSizeAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1524
  def initialize(input, interval, enum_class_name); end

  # source://idlc//lib/idlc/ast.rb#1522
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1519
  def enum_class; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#122
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1548
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1545
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1532
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1528
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1540
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1555
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1507
class Idl::EnumSizeSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1508
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#6692
module Idl::EnumToA0
  # source://idlc//lib/idlc/idl_parser.rb#6693
  def user_type_name; end
end

# source://idlc//lib/idlc/type.rb#641
class Idl::EnumerationType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#671
  sig do
    params(
      type_name: ::String,
      element_names: T::Array[::String],
      element_values: T::Array[::Integer],
      builtin: T::Boolean
    ).void
  end
  def initialize(type_name, element_names, element_values, builtin: T.unsafe(nil)); end

  # source://idlc//lib/idlc/type.rb#686
  sig { returns(T::Boolean) }
  def builtin?; end

  # source://idlc//lib/idlc/type.rb#689
  sig { returns(::Idl::EnumerationType) }
  def clone; end

  # source://idlc//lib/idlc/type.rb#702
  sig { params(element_value: ::Integer).returns(T.nilable(::String)) }
  def element_name(element_value); end

  # source://idlc//lib/idlc/type.rb#650
  sig { returns(T::Array[::String]) }
  def element_names; end

  # source://idlc//lib/idlc/type.rb#654
  sig { returns(T::Array[::Integer]) }
  def element_values; end

  # source://idlc//lib/idlc/type.rb#658
  sig { returns(::Idl::Type) }
  def ref_type; end

  # source://idlc//lib/idlc/type.rb#694
  sig { params(element_name: ::String).returns(T.nilable(::Integer)) }
  def value(element_name); end

  # source://idlc//lib/idlc/type.rb#646
  sig { returns(::Integer) }
  def width; end
end

# source://idlc//lib/idlc/ast.rb#591
module Idl::Executable
  interface!

  # source://idlc//lib/idlc/ast.rb#613
  sig { abstract.params(symtab: ::Idl::SymbolTable).void }
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#617
  sig { abstract.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end
end

# source://idlc//lib/idlc/ast.rb#620
Idl::ExecutableAst = T.type_alias { T.all(::Idl::AstNode, ::Idl::Executable) }

# source://idlc//lib/idlc/idl_parser.rb#13702
module Idl::ExecuteIfBlock0
  # source://idlc//lib/idlc/idl_parser.rb#13703
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13709
module Idl::ExecuteIfBlock1
  # source://idlc//lib/idlc/idl_parser.rb#13710
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13716
module Idl::ExecuteIfBlock2
  # source://idlc//lib/idlc/idl_parser.rb#13721
  def body; end

  # source://idlc//lib/idlc/idl_parser.rb#13717
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#13727
module Idl::ExecuteIfBlock3
  # source://idlc//lib/idlc/idl_parser.rb#13728
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13734
module Idl::ExecuteIfBlock4
  # source://idlc//lib/idlc/idl_parser.rb#13735
  def body; end
end

# source://idlc//lib/idlc/idl_parser.rb#13741
module Idl::ExecuteIfBlock5
  # source://idlc//lib/idlc/idl_parser.rb#13750
  def elseifs; end

  # source://idlc//lib/idlc/idl_parser.rb#13754
  def final_else; end

  # source://idlc//lib/idlc/idl_parser.rb#13746
  def if_body; end

  # source://idlc//lib/idlc/idl_parser.rb#13742
  def if_cond; end
end

# source://idlc//lib/idlc/ast.rb#916
class Idl::FalseExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#920
  sig { params(input: ::String, interval: T::Range[::Integer]).void }
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#925
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#153
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#93
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#940
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#937
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#931
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#928
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#934
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::FalseClass) }
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#946
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#912
class Idl::FalseExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#913
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#10826
module Idl::Fetch0
  # source://idlc//lib/idlc/idl_parser.rb#10827
  def function_body; end
end

# source://idlc//lib/idlc/ast.rb#7982
class Idl::FetchAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#7989
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      body: ::Idl::FunctionBodyAst
    ).void
  end
  def initialize(input, interval, body); end

  # source://idlc//lib/idlc/ast.rb#7986
  def body; end

  # source://idlc//lib/idlc/ast.rb#7984
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7997
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#8011
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#8002
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7993
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#8018
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FetchAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#7976
class Idl::FetchSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7977
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#6096
module Idl::FieldAccessExpression0
  # source://idlc//lib/idlc/idl_parser.rb#6097
  def field_access_eligible_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#6101
  def field_name; end
end

# source://idlc//lib/idlc/ast.rb#5744
class Idl::FieldAccessExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5754
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      bitfield: T.all(::Idl::AstNode, ::Idl::Rvalue),
      field_name: ::String
    ).void
  end
  def initialize(input, interval, bitfield, field_name); end

  # source://idlc//lib/idlc/ast.rb#5748
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#87
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5760
  def kind(symtab); end

  # source://idlc//lib/idlc/ast.rb#5751
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def obj; end

  # source://idlc//lib/idlc/ast.rb#5811
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5808
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5765
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5777
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5795
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5819
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FieldAccessExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5734
class Idl::FieldAccessExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5735
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#3102
class Idl::FieldAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#3130
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      id: ::Idl::IdAst,
      field_name: ::String,
      rhs: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, id, field_name, rhs); end

  # source://idlc//lib/idlc/ast.rb#3115
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3175
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#3198
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#3112
  sig { returns(::String) }
  def field_name; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#92
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3106
  sig { returns(::Idl::IdAst) }
  def id; end

  # source://idlc//lib/idlc/ast.rb#3109
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#3208
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#3205
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#3136
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#3150
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#3217
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FieldAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3090
class Idl::FieldAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3091
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#15831
module Idl::FieldName0; end

# source://idlc//lib/idlc/idl_parser.rb#14342
module Idl::ForLoop0
  # source://idlc//lib/idlc/idl_parser.rb#14343
  def s; end
end

# source://idlc//lib/idlc/idl_parser.rb#14349
module Idl::ForLoop1
  # source://idlc//lib/idlc/idl_parser.rb#14358
  def action; end

  # source://idlc//lib/idlc/idl_parser.rb#14354
  def condition; end

  # source://idlc//lib/idlc/idl_parser.rb#14350
  def for_loop_iteration_variable_declaration; end

  # source://idlc//lib/idlc/idl_parser.rb#14362
  def stmts; end
end

# source://idlc//lib/idlc/ast.rb#8511
class Idl::ForLoopAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#8536
  def initialize(input, interval, init, condition, update, stmts); end

  # source://idlc//lib/idlc/ast.rb#8527
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def condition; end

  # source://idlc//lib/idlc/ast.rb#8516
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#8654
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#8657
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#202
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#8524
  sig { returns(::Idl::VariableDeclarationWithInitializationAst) }
  def init; end

  # source://idlc//lib/idlc/passes/prune.rb#118
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#197
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#174
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#8603
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#8570
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#8609
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#8553
  sig { params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def satisfied?(symtab); end

  # source://idlc//lib/idlc/ast.rb#8534
  sig do
    returns(T::Array[T.any(::Idl::ForLoopAst, ::Idl::IfAst, ::Idl::ImplicationStatementAst, ::Idl::ReturnStatementAst, ::Idl::StatementAst)])
  end
  def stmts; end

  # source://idlc//lib/idlc/ast.rb#8689
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#8679
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#8541
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#8530
  sig { returns(T.all(::Idl::AstNode, ::Idl::Executable)) }
  def update; end

  class << self
    # source://idlc//lib/idlc/ast.rb#8699
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ForLoopAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#8532
Idl::ForLoopAst::StmtType = T.type_alias { T.any(::Idl::ForLoopAst, ::Idl::IfAst, ::Idl::ImplicationStatementAst, ::Idl::ReturnStatementAst, ::Idl::StatementAst) }

# source://idlc//lib/idlc/idl_parser.rb#12060
module Idl::ForLoopIterationVariableDeclaration0
  # source://idlc//lib/idlc/idl_parser.rb#12069
  def ary_size; end

  # source://idlc//lib/idlc/idl_parser.rb#12065
  def id; end

  # source://idlc//lib/idlc/idl_parser.rb#12073
  def rval; end

  # source://idlc//lib/idlc/idl_parser.rb#12061
  def type_name; end
end

# source://idlc//lib/idlc/ast.rb#3703
class Idl::ForLoopIterationVariableDeclarationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3704
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#8499
class Idl::ForLoopSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#8500
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#9416
module Idl::FunctionArgList0
  # source://idlc//lib/idlc/idl_parser.rb#9417
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#9422
module Idl::FunctionArgList1
  # source://idlc//lib/idlc/idl_parser.rb#9423
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#9427
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#16095
module Idl::FunctionBody0
  # source://idlc//lib/idlc/idl_parser.rb#16096
  def choice; end
end

# source://idlc//lib/idlc/idl_parser.rb#16102
module Idl::FunctionBody1
  # source://idlc//lib/idlc/idl_parser.rb#16103
  def func_stmt_list; end
end

# source://idlc//lib/idlc/ast.rb#7837
class Idl::FunctionBodyAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#7849
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      stmts: T::Array[T.all(::Idl::AstNode, ::Idl::Executable)]
    ).void
  end
  def initialize(input, interval, stmts); end

  # source://idlc//lib/idlc/ast.rb#7842
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7912
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#7915
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#311
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#22
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/find_return_values.rb#67
  def pass_find_return_values(symtab); end

  # source://idlc//lib/idlc/passes/prune.rb#161
  def prune(symtab, args_already_applied: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7881
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#7896
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#7922
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#7853
  def statements; end

  # source://idlc//lib/idlc/ast.rb#7855
  def stmts; end

  # source://idlc//lib/idlc/ast.rb#7957
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#7952
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7858
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#7964
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FunctionBodyAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#7830
class Idl::FunctionBodySyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7832
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#8869
module Idl::FunctionCall0
  # source://idlc//lib/idlc/idl_parser.rb#8870
  def csr; end

  # source://idlc//lib/idlc/idl_parser.rb#8874
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#8880
module Idl::FunctionCall1
  # source://idlc//lib/idlc/idl_parser.rb#8881
  def csr; end

  # source://idlc//lib/idlc/idl_parser.rb#8889
  def function_arg_list; end

  # source://idlc//lib/idlc/idl_parser.rb#8885
  def function_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#8895
module Idl::FunctionCall2
  # source://idlc//lib/idlc/idl_parser.rb#8896
  def targs; end
end

# source://idlc//lib/idlc/idl_parser.rb#8902
module Idl::FunctionCall3
  # source://idlc//lib/idlc/idl_parser.rb#8911
  def function_arg_list; end

  # source://idlc//lib/idlc/idl_parser.rb#8903
  def function_name; end

  # source://idlc//lib/idlc/idl_parser.rb#8907
  def t; end
end

# source://idlc//lib/idlc/ast.rb#7504
class Idl::FunctionCallExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#7519
  def initialize(input, interval, function_name, targs, args); end

  # source://idlc//lib/idlc/ast.rb#7561
  def arg_nodes; end

  # source://idlc//lib/idlc/ast.rb#7517
  def args; end

  # source://idlc//lib/idlc/ast.rb#7510
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7717
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#7725
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#7565
  def func_type(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#289
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#28
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#7719
  def name; end

  # source://idlc//lib/idlc/passes/prune.rb#82
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#25
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#21
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7516
  def targs; end

  # source://idlc//lib/idlc/ast.rb#7532
  def template?; end

  # source://idlc//lib/idlc/ast.rb#7537
  def template_arg_nodes; end

  # source://idlc//lib/idlc/ast.rb#7541
  def template_values(symtab, unknown_ok: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7738
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#7729
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7631
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#7580
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#7640
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#7749
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FunctionCallExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#7494
class Idl::FunctionCallExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7495
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#8768
module Idl::FunctionCallTemplateArguments0
  # source://idlc//lib/idlc/idl_parser.rb#8769
  def arg; end
end

# source://idlc//lib/idlc/idl_parser.rb#8774
module Idl::FunctionCallTemplateArguments1
  # source://idlc//lib/idlc/idl_parser.rb#8775
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#8779
  def rest; end
end

# source://idlc//lib/idlc/ast.rb#8050
class Idl::FunctionDefAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#8074
  def initialize(input, interval, name, targs, return_types, arguments, desc, type, body); end

  # source://idlc//lib/idlc/ast.rb#8055
  def <=>(other); end

  # source://idlc//lib/idlc/ast.rb#8342
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#8304
  def apply_template_and_arg_syms(symtab); end

  # source://idlc//lib/idlc/ast.rb#8095
  def argument_nodes; end

  # source://idlc//lib/idlc/ast.rb#8125
  def arguments(symtab); end

  # source://idlc//lib/idlc/ast.rb#8156
  def arguments_list_str; end

  # source://idlc//lib/idlc/ast.rb#8394
  def body; end

  # source://idlc//lib/idlc/ast.rb#8400
  def builtin?; end

  # source://idlc//lib/idlc/ast.rb#8236
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#8110
  def description; end

  # source://idlc//lib/idlc/ast.rb#8061
  def eql?(other); end

  # source://idlc//lib/idlc/ast.rb#8408
  def external?; end

  # source://idlc//lib/idlc/ast.rb#8098
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/ast.rb#8404
  def generated?; end

  # source://idlc//lib/idlc/ast.rb#8265
  def name; end

  # source://idlc//lib/idlc/ast.rb#8120
  def num_args; end

  # source://idlc//lib/idlc/passes/prune.rb#141
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#8412
  def qualifier_str; end

  # source://idlc//lib/idlc/ast.rb#8095
  def reachable_functions_cache; end

  # source://idlc//lib/idlc/ast.rb#8161
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#8224
  def return_type_list_str; end

  # source://idlc//lib/idlc/ast.rb#8053
  def return_type_nodes; end

  # source://idlc//lib/idlc/ast.rb#8356
  def template_names; end

  # source://idlc//lib/idlc/ast.rb#8362
  def template_types(symtab); end

  # source://idlc//lib/idlc/ast.rb#8115
  def templated?; end

  # source://idlc//lib/idlc/ast.rb#8468
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#8425
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#8315
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#8384
  def type_check_args(symtab); end

  # source://idlc//lib/idlc/ast.rb#8388
  def type_check_body(symtab); end

  # source://idlc//lib/idlc/ast.rb#8288
  def type_check_from_call(symtab); end

  # source://idlc//lib/idlc/ast.rb#8380
  def type_check_return(symtab); end

  # source://idlc//lib/idlc/ast.rb#8375
  def type_check_targs(symtab); end

  # source://idlc//lib/idlc/ast.rb#8270
  def type_check_template_instance(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#8481
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FunctionDefAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#8030
class Idl::FunctionDefSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#8031
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#13044
module Idl::FunctionIfBlock0
  # source://idlc//lib/idlc/idl_parser.rb#13045
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13051
module Idl::FunctionIfBlock1
  # source://idlc//lib/idlc/idl_parser.rb#13052
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13058
module Idl::FunctionIfBlock2
  # source://idlc//lib/idlc/idl_parser.rb#13063
  def body; end

  # source://idlc//lib/idlc/idl_parser.rb#13059
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#13069
module Idl::FunctionIfBlock3
  # source://idlc//lib/idlc/idl_parser.rb#13070
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13076
module Idl::FunctionIfBlock4
  # source://idlc//lib/idlc/idl_parser.rb#13077
  def body; end
end

# source://idlc//lib/idlc/idl_parser.rb#13083
module Idl::FunctionIfBlock5
  # source://idlc//lib/idlc/idl_parser.rb#13092
  def elseifs; end

  # source://idlc//lib/idlc/idl_parser.rb#13096
  def final_else; end

  # source://idlc//lib/idlc/idl_parser.rb#13088
  def if_body; end

  # source://idlc//lib/idlc/idl_parser.rb#13084
  def if_cond; end
end

# source://idlc//lib/idlc/idl_parser.rb#9334
module Idl::FunctionName0; end

# source://idlc//lib/idlc/type.rb#763
class Idl::FunctionType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#766
  def initialize(func_name, func_def_ast, symtab); end

  # source://idlc//lib/idlc/type.rb#845
  sig do
    params(
      symtab: ::Idl::SymbolTable,
      argument_nodes: T::Array[::Idl::Rvalue],
      call_site_symtab: ::Idl::SymbolTable,
      func_call_ast: ::Idl::FunctionCallExpressionAst
    ).returns(T::Array[T.any(::Integer, ::Symbol)])
  end
  def apply_arguments(symtab, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#816
  def apply_template_values(template_values, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#949
  def argument_name(index, template_values = T.unsafe(nil), func_call_ast); end

  # source://idlc//lib/idlc/type.rb#934
  def argument_type(index, template_values, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#866
  def argument_values(symtab, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#964
  def body; end

  # source://idlc//lib/idlc/type.rb#778
  def builtin?; end

  # source://idlc//lib/idlc/type.rb#774
  def clone; end

  # source://idlc//lib/idlc/type.rb#782
  def external?; end

  # source://idlc//lib/idlc/type.rb#764
  def func_def_ast; end

  # source://idlc//lib/idlc/type.rb#780
  def generated?; end

  # source://idlc//lib/idlc/type.rb#784
  def num_args; end

  # source://idlc//lib/idlc/type.rb#892
  sig do
    params(
      template_values: T::Array[::Integer],
      argument_nodes: T::Array[::Idl::Rvalue],
      func_call_ast: ::Idl::FunctionCallExpressionAst
    ).returns(::Idl::Type)
  end
  def return_type(template_values, argument_nodes, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#921
  def return_types(template_values, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#905
  def return_value(template_values, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#810
  def template_names; end

  # source://idlc//lib/idlc/type.rb#812
  def template_types(symtab); end

  # source://idlc//lib/idlc/type.rb#814
  def templated?; end

  # source://idlc//lib/idlc/type.rb#786
  def type_check_call(template_values, argument_nodes, call_site_symtab, func_call_ast); end
end

# source://idlc//lib/idlc/ast.rb#1182
class Idl::GlobalAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#1197
  def initialize(input, interval, declaration); end

  # source://idlc//lib/idlc/ast.rb#1210
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#1186
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1193
  def declaration; end

  # source://idlc//lib/idlc/ast.rb#1188
  def id; end

  # source://idlc//lib/idlc/ast.rb#1220
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1217
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1206
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1202
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1227
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/idl_parser.rb#269
module Idl::GlobalDefinition0; end

# source://idlc//lib/idlc/idl_parser.rb#272
module Idl::GlobalDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#273
  def const; end

  # source://idlc//lib/idlc/idl_parser.rb#277
  def single_declaration_with_initialization; end
end

# source://idlc//lib/idlc/idl_parser.rb#283
module Idl::GlobalDefinition2
  # source://idlc//lib/idlc/idl_parser.rb#284
  def declaration; end
end

# source://idlc//lib/idlc/ast.rb#1176
class Idl::GlobalSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1177
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1102
class Idl::GlobalWithInitializationAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#1117
  def initialize(input, interval, var_decl_with_init); end

  # source://idlc//lib/idlc/ast.rb#1144
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#1110
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1138
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#1141
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#1106
  def id; end

  # source://idlc//lib/idlc/ast.rb#1107
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#1158
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1153
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1128
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1123
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1133
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#1113
  def var_decl_with_init; end

  class << self
    # source://idlc//lib/idlc/ast.rb#1165
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1087
class Idl::GlobalWithInitializationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1088
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16283
module Idl::Id0; end

# source://idlc//lib/idlc/ast.rb#964
class Idl::IdAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#978
  sig { params(input: ::String, interval: T::Range[::Integer], name: ::String).void }
  def initialize(input, interval, name); end

  # source://idlc//lib/idlc/ast.rb#1009
  sig { returns(T::Boolean) }
  def const?; end

  # source://idlc//lib/idlc/ast.rb#968
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#158
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#97
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#1025
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(::Integer, ::Symbol)) }
  def max_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#1043
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(::Integer, ::Symbol)) }
  def min_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#972
  sig { returns(::String) }
  def name; end

  # source://idlc//lib/idlc/ast.rb#975
  sig { override.returns(::String) }
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#1065
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1062
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#991
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#985
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1012
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1072
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#957
class Idl::IdSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#958
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#8989
class Idl::IfAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#9013
  def initialize(input, interval, if_cond, if_body, elseifs, final_else_body); end

  # source://idlc//lib/idlc/ast.rb#8994
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9008
  sig { returns(T::Array[::Idl::ElseIfAst]) }
  def elseifs; end

  # source://idlc//lib/idlc/ast.rb#9182
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#9228
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#9011
  sig { returns(::Idl::IfBodyAst) }
  def final_else_body; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#331
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#34
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#9005
  sig { returns(::Idl::IfBodyAst) }
  def if_body; end

  # source://idlc//lib/idlc/ast.rb#9002
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def if_cond; end

  # source://idlc//lib/idlc/passes/find_return_values.rb#35
  def pass_find_return_values(values, current_conditions, symtab); end

  # source://idlc//lib/idlc/passes/prune.rb#355
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#101
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#84
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#9075
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#9084
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#9125
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#9062
  def taken_body(symtab); end

  # source://idlc//lib/idlc/ast.rb#9251
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#9235
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#9024
  def type_check(symtab); end

  private

  # source://idlc//lib/idlc/ast.rb#9143
  def execute_after_if(symtab); end

  # source://idlc//lib/idlc/ast.rb#9219
  def execute_unknown_after_if(symtab); end

  # source://idlc//lib/idlc/ast.rb#9093
  def return_values_after_if(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9261
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::IfAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#8714
class Idl::IfBodyAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#8727
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      body_stmts: T::Array[::Idl::StatementAst]
    ).void
  end
  def initialize(input, interval, body_stmts); end

  # source://idlc//lib/idlc/ast.rb#8719
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#8804
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#8830
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#35
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#71
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/prune.rb#331
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#8749
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#8755
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#8776
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#8724
  sig { returns(T::Array[::Idl::StatementAst]) }
  def stmts; end

  # source://idlc//lib/idlc/ast.rb#8843
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#8838
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#8736
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#8850
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::IfBodyAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#8954
class Idl::IfSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#8955
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#8010
module Idl::ImplicationExpression0
  # source://idlc//lib/idlc/idl_parser.rb#8011
  def antecedent; end

  # source://idlc//lib/idlc/idl_parser.rb#8015
  def consequent; end
end

# source://idlc//lib/idlc/idl_parser.rb#8021
module Idl::ImplicationExpression1
  # source://idlc//lib/idlc/idl_parser.rb#8022
  def antecedent; end

  # source://idlc//lib/idlc/idl_parser.rb#8026
  def consequent; end
end

# source://idlc//lib/idlc/ast.rb#3974
class Idl::ImplicationExpressionAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#3983
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      antecedent: T.all(::Idl::AstNode, ::Idl::Rvalue),
      consequent: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, antecedent, consequent); end

  # source://idlc//lib/idlc/ast.rb#3994
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def antecedent; end

  # source://idlc//lib/idlc/ast.rb#3997
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def consequent; end

  # source://idlc//lib/idlc/ast.rb#3989
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4006
  sig { params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def satisfied?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4015
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4012
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4000
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4023
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ImplicationExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3963
class Idl::ImplicationExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3965
  sig { override.returns(::Idl::ImplicationExpressionAst) }
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#8222
module Idl::ImplicationForLoop0
  # source://idlc//lib/idlc/idl_parser.rb#8223
  def s; end
end

# source://idlc//lib/idlc/idl_parser.rb#8229
module Idl::ImplicationForLoop1
  # source://idlc//lib/idlc/idl_parser.rb#8238
  def action; end

  # source://idlc//lib/idlc/idl_parser.rb#8234
  def condition; end

  # source://idlc//lib/idlc/idl_parser.rb#8230
  def for_loop_iteration_variable_declaration; end

  # source://idlc//lib/idlc/idl_parser.rb#8242
  def stmts; end
end

# source://idlc//lib/idlc/idl_parser.rb#8544
module Idl::ImplicationStatement0
  # source://idlc//lib/idlc/idl_parser.rb#8545
  def implication_expression; end
end

# source://idlc//lib/idlc/ast.rb#4043
class Idl::ImplicationStatementAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#4051
  sig do
    params(
      input: ::String,
      interval: T::Range[::Integer],
      implication_expression: ::Idl::ImplicationExpressionAst
    ).void
  end
  def initialize(input, interval, implication_expression); end

  # source://idlc//lib/idlc/ast.rb#4056
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4059
  sig { returns(::Idl::ImplicationExpressionAst) }
  def expression; end

  # source://idlc//lib/idlc/ast.rb#4067
  sig { params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def satisfied?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4075
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4072
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4062
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4082
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ImplicationExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4036
class Idl::ImplicationStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4038
  sig { override.returns(::Idl::ImplicationStatementAst) }
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#189
module Idl::IncludeStatement0
  # source://idlc//lib/idlc/idl_parser.rb#190
  def string; end
end

# source://idlc//lib/idlc/ast.rb#841
class Idl::IncludeStatementAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#850
  sig { params(input: ::String, interval: T::Range[T.untyped], filename: ::Idl::AstNode).void }
  def initialize(input, interval, filename); end

  # source://idlc//lib/idlc/ast.rb#843
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#847
  sig { returns(::String) }
  def filename; end

  # source://idlc//lib/idlc/ast.rb#860
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#855
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#858
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#833
class Idl::IncludeStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#835
  sig { override.returns(::Idl::IncludeStatementAst) }
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16179
module Idl::InstructionOperation0
  # source://idlc//lib/idlc/idl_parser.rb#16180
  def choice; end
end

# source://idlc//lib/idlc/idl_parser.rb#16186
module Idl::InstructionOperation1
  # source://idlc//lib/idlc/idl_parser.rb#16187
  def op_stmt_list; end
end

# source://idlc//lib/idlc/ast.rb#7824
class Idl::InstructionOperationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7825
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#1478
module Idl::Int0; end

# source://idlc//lib/idlc/idl_parser.rb#1481
module Idl::Int1; end

# source://idlc//lib/idlc/idl_parser.rb#1508
module Idl::Int10; end

# source://idlc//lib/idlc/idl_parser.rb#1511
module Idl::Int11; end

# source://idlc//lib/idlc/idl_parser.rb#1514
module Idl::Int12; end

# source://idlc//lib/idlc/idl_parser.rb#1517
module Idl::Int13; end

# source://idlc//lib/idlc/idl_parser.rb#1520
module Idl::Int14; end

# source://idlc//lib/idlc/idl_parser.rb#1523
module Idl::Int15; end

# source://idlc//lib/idlc/idl_parser.rb#1526
module Idl::Int16; end

# source://idlc//lib/idlc/idl_parser.rb#1484
module Idl::Int2; end

# source://idlc//lib/idlc/idl_parser.rb#1487
module Idl::Int3; end

# source://idlc//lib/idlc/idl_parser.rb#1490
module Idl::Int4; end

# source://idlc//lib/idlc/idl_parser.rb#1493
module Idl::Int5; end

# source://idlc//lib/idlc/idl_parser.rb#1496
module Idl::Int6; end

# source://idlc//lib/idlc/idl_parser.rb#1499
module Idl::Int7; end

# source://idlc//lib/idlc/idl_parser.rb#1502
module Idl::Int8; end

# source://idlc//lib/idlc/idl_parser.rb#1505
module Idl::Int9; end

# source://idlc//lib/idlc/ast.rb#7150
class Idl::IntLiteralAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#7157
  sig { params(input: T.nilable(::String), interval: T.nilable(T::Range[::Integer]), text: ::String).void }
  def initialize(input, interval, text); end

  # source://idlc//lib/idlc/ast.rb#7154
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7164
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#142
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#103
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#7421
  sig { returns(::Integer) }
  def radix; end

  # source://idlc//lib/idlc/ast.rb#7404
  sig { returns(T::Boolean) }
  def signed?; end

  # source://idlc//lib/idlc/ast.rb#7162
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#7459
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#7392
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7395
  sig { override.returns(::String) }
  def to_idl_verbose; end

  # source://idlc//lib/idlc/ast.rb#7190
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#7174
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#7311
  def unsigned_value; end

  # source://idlc//lib/idlc/ast.rb#7264
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#7225
  def width(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#7482
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::IntLiteralAst)
    end
    def from_h(yaml, source_mapper); end

    # source://idlc//lib/idlc/ast.rb#7470
    def radix_to_verilog(r); end
  end
end

# source://idlc//lib/idlc/ast.rb#7060
module Idl::IntLiteralSyntaxNode
  # source://idlc//lib/idlc/ast.rb#7061
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16
module Idl::Isa0
  # source://idlc//lib/idlc/idl_parser.rb#21
  def definitions; end

  # source://idlc//lib/idlc/idl_parser.rb#17
  def version_string; end
end

# source://idlc//lib/idlc/ast.rb#1253
class Idl::IsaAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#1280
  def add_global_symbols(symtab); end

  # source://idlc//lib/idlc/ast.rb#1266
  def bitfields; end

  # source://idlc//lib/idlc/ast.rb#1257
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1254
  def definitions; end

  # source://idlc//lib/idlc/ast.rb#1263
  def enums; end

  # source://idlc//lib/idlc/ast.rb#1275
  def fetch; end

  # source://idlc//lib/idlc/ast.rb#1272
  def functions; end

  # source://idlc//lib/idlc/ast.rb#1260
  def globals; end

  # source://idlc//lib/idlc/ast.rb#1295
  def replace_include!(include_ast, isa_ast); end

  # source://idlc//lib/idlc/ast.rb#1269
  def structs; end

  # source://idlc//lib/idlc/ast.rb#1328
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1314
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1305
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1335
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1240
class Idl::IsaSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1241
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#15040
module Idl::Keyword0; end

# source://idlc//lib/idlc/idl_parser.rb#15043
module Idl::Keyword1; end

# source://idlc//lib/idlc/idl_parser.rb#15070
module Idl::Keyword10; end

# source://idlc//lib/idlc/idl_parser.rb#15073
module Idl::Keyword11; end

# source://idlc//lib/idlc/idl_parser.rb#15076
module Idl::Keyword12; end

# source://idlc//lib/idlc/idl_parser.rb#15079
module Idl::Keyword13; end

# source://idlc//lib/idlc/idl_parser.rb#15082
module Idl::Keyword14; end

# source://idlc//lib/idlc/idl_parser.rb#15085
module Idl::Keyword15; end

# source://idlc//lib/idlc/idl_parser.rb#15046
module Idl::Keyword2; end

# source://idlc//lib/idlc/idl_parser.rb#15049
module Idl::Keyword3; end

# source://idlc//lib/idlc/idl_parser.rb#15052
module Idl::Keyword4; end

# source://idlc//lib/idlc/idl_parser.rb#15055
module Idl::Keyword5; end

# source://idlc//lib/idlc/idl_parser.rb#15058
module Idl::Keyword6; end

# source://idlc//lib/idlc/idl_parser.rb#15061
module Idl::Keyword7; end

# source://idlc//lib/idlc/idl_parser.rb#15064
module Idl::Keyword8; end

# source://idlc//lib/idlc/idl_parser.rb#15067
module Idl::Keyword9; end

# source://idlc//lib/idlc/ast.rb#3310
class Idl::MultiVariableAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#3332
  def initialize(input, interval, variables, function_call); end

  # source://idlc//lib/idlc/ast.rb#3314
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3377
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#3401
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#3330
  def function_call; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#71
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3341
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#3412
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#3409
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#3346
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#3329
  def variables; end

  # source://idlc//lib/idlc/ast.rb#3337
  def vars; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3420
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::MultiVariableAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3300
class Idl::MultiVariableAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3301
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#3444
class Idl::MultiVariableDeclarationAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#3460
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      type_name: T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst),
      var_names: T::Array[::Idl::IdAst]
    ).void
  end
  def initialize(input, interval, type_name, var_names); end

  # source://idlc//lib/idlc/ast.rb#3493
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#3448
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#180
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3467
  def make_global; end

  # source://idlc//lib/idlc/ast.rb#3504
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#3501
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#3484
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#3477
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#3454
  def type_name; end

  # source://idlc//lib/idlc/ast.rb#3457
  def var_name_nodes; end

  # source://idlc//lib/idlc/ast.rb#3472
  def var_names; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3512
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::MultiVariableDeclarationAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3433
class Idl::MultiVariableDeclarationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3434
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#6217
class Idl::NoopAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#6221
  def initialize; end

  # source://idlc//lib/idlc/ast.rb#6219
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6229
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#6232
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#17
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6239
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6236
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6226
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6245
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::NoopAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/idl_parser.rb#3497
module Idl::P0BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#3498
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#3502
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3507
module Idl::P0BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#3508
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#3512
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3615
module Idl::P1BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#3616
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#3620
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3625
module Idl::P1BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#3626
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#3630
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3733
module Idl::P2BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#3734
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#3738
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3743
module Idl::P2BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#3744
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#3748
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3851
module Idl::P3BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#3852
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#3856
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3861
module Idl::P3BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#3862
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#3866
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4087
module Idl::P4BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4088
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4092
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4097
module Idl::P4BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4098
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4102
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4323
module Idl::P5BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4324
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4328
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4333
module Idl::P5BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4334
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4338
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3257
module Idl::P5BinaryOperator0; end

# source://idlc//lib/idlc/idl_parser.rb#4559
module Idl::P6BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4560
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4564
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4569
module Idl::P6BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4570
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4574
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4795
module Idl::P7BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4796
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4800
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4805
module Idl::P7BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4806
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4810
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3337
module Idl::P7BinaryOperator0; end

# source://idlc//lib/idlc/idl_parser.rb#5031
module Idl::P8BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5032
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#5036
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5041
module Idl::P8BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#5042
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#5046
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5267
module Idl::P9BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5268
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#5272
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5277
module Idl::P9BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#5278
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#5282
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5503
module Idl::ParenExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5504
  def e; end
end

# source://idlc//lib/idlc/ast.rb#5208
class Idl::ParenExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5214
  def initialize(input, interval, exp); end

  # source://idlc//lib/idlc/ast.rb#5212
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5216
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#137
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5218
  def invert(symtab); end

  # source://idlc//lib/idlc/ast.rb#5234
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5231
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5224
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5221
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5227
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5241
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ParenExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5198
class Idl::ParenExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5199
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#2616
class Idl::PcAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#2627
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      rval: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, rval); end

  # source://idlc//lib/idlc/ast.rb#2620
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2633
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#2637
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#247
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2624
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#2650
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2647
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2641
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2657
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::PcAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2610
class Idl::PcAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2611
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#6455
module Idl::PostDec0
  # source://idlc//lib/idlc/idl_parser.rb#6456
  def rval; end
end

# source://idlc//lib/idlc/ast.rb#5506
class Idl::PostDecrementExpressionAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#5515
  def initialize(input, interval, rval); end

  # source://idlc//lib/idlc/ast.rb#5510
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5532
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#5548
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#50
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5513
  sig { returns(T.any(::Idl::BuiltinVariableAst, ::Idl::IdAst, ::Idl::IntLiteralAst, ::Idl::StringLiteralAst)) }
  def rval; end

  # source://idlc//lib/idlc/ast.rb#5556
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5553
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5527
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5519
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5563
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::PostDecrementExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5496
class Idl::PostDecrementExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5497
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#6512
module Idl::PostInc0
  # source://idlc//lib/idlc/idl_parser.rb#6513
  def rval; end
end

# source://idlc//lib/idlc/ast.rb#5661
class Idl::PostIncrementExpressionAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#5669
  def initialize(input, interval, rval); end

  # source://idlc//lib/idlc/ast.rb#5665
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5689
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#5706
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#45
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5667
  def rval; end

  # source://idlc//lib/idlc/ast.rb#5715
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5712
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5684
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5674
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5722
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::PostIncrementExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5651
class Idl::PostIncrementExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5652
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#5583
module Idl::ReplicationExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5584
  def n; end

  # source://idlc//lib/idlc/idl_parser.rb#5588
  def v; end
end

# source://idlc//lib/idlc/ast.rb#5424
class Idl::ReplicationExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5434
  def initialize(input, interval, n, v); end

  # source://idlc//lib/idlc/ast.rb#5428
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#277
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5431
  def n; end

  # source://idlc//lib/idlc/ast.rb#5475
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5472
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5460
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5439
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5432
  def v; end

  # source://idlc//lib/idlc/ast.rb#5451
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5483
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ReplicationExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5414
class Idl::ReplicationExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5415
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#12698
module Idl::ReturnExpression0
  # source://idlc//lib/idlc/idl_parser.rb#12699
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#12704
module Idl::ReturnExpression1
  # source://idlc//lib/idlc/idl_parser.rb#12705
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#12710
module Idl::ReturnExpression2
  # source://idlc//lib/idlc/idl_parser.rb#12711
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#12715
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#12720
module Idl::ReturnExpression3
  # source://idlc//lib/idlc/idl_parser.rb#12721
  def vals; end
end

# source://idlc//lib/idlc/ast.rb#6613
class Idl::ReturnExpressionAst < ::Idl::AstNode
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#6621
  def initialize(input, interval, return_nodes); end

  # source://idlc//lib/idlc/ast.rb#6617
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6665
  def enclosing_function; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#30
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#115
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#6638
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#6627
  def return_types(symtab); end

  # source://idlc//lib/idlc/ast.rb#6670
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#6619
  def return_value_nodes; end

  # source://idlc//lib/idlc/ast.rb#6681
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#6695
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6692
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6650
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6702
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ReturnExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6600
class Idl::ReturnExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6601
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#12890
module Idl::ReturnStatement0
  # source://idlc//lib/idlc/idl_parser.rb#12895
  def expression; end

  # source://idlc//lib/idlc/idl_parser.rb#12891
  def return_expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#12901
module Idl::ReturnStatement1
  # source://idlc//lib/idlc/idl_parser.rb#12902
  def return_expression; end
end

# source://idlc//lib/idlc/ast.rb#6524
class Idl::ReturnStatementAst < ::Idl::AstNode
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#6534
  def initialize(input, interval, return_expression); end

  # source://idlc//lib/idlc/ast.rb#6528
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6563
  def enclosing_function; end

  # source://idlc//lib/idlc/ast.rb#6549
  def expected_return_type(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#271
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#77
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/find_return_values.rb#19
  def pass_find_return_values(values, current_conditions, symtab); end

  # source://idlc//lib/idlc/ast.rb#6530
  def return_expression; end

  # source://idlc//lib/idlc/ast.rb#6544
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#6539
  def return_types(symtab); end

  # source://idlc//lib/idlc/ast.rb#6568
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#6559
  def return_value_nodes; end

  # source://idlc//lib/idlc/ast.rb#6573
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#6581
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6578
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6554
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6588
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ReturnStatementAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6513
class Idl::ReturnStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6514
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#623
module Idl::Returns
  abstract!

  # source://idlc//lib/idlc/ast.rb#664
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def expected_return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#641
  sig { abstract.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#646
  sig do
    abstract
      .params(
        symtab: ::Idl::SymbolTable
      ).returns(T.nilable(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)])))
  end
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#660
  sig do
    abstract
      .params(
        symtab: ::Idl::SymbolTable
      ).returns(T::Array[T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)])])
  end
  def return_values(symtab); end
end

# source://idlc//lib/idlc/interfaces.rb#13
module Idl::RuntimeParam
  interface!

  # source://idlc//lib/idlc/interfaces.rb#27
  sig { abstract.returns(::String) }
  def description; end

  # source://idlc//lib/idlc/interfaces.rb#48
  sig { abstract.returns(::Idl::Type) }
  def idl_type; end

  # source://idlc//lib/idlc/interfaces.rb#24
  sig { abstract.returns(::String) }
  def name; end

  # source://idlc//lib/idlc/interfaces.rb#33
  sig { abstract.returns(::Idl::Schema) }
  def schema; end

  # source://idlc//lib/idlc/interfaces.rb#45
  sig do
    abstract
      .returns(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean))
  end
  def value; end

  # source://idlc//lib/idlc/interfaces.rb#42
  sig { abstract.returns(T::Boolean) }
  def value_known?; end
end

# source://idlc//lib/idlc/interfaces.rb#20
Idl::RuntimeParam::ValueType = T.type_alias { T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean) }

# source://idlc//lib/idlc/ast.rb#715
module Idl::Rvalue
  abstract!

  # source://idlc//lib/idlc/ast.rb#765
  sig { params(symtab: ::Idl::SymbolTable).returns(T.any(::Integer, ::Symbol)) }
  def max_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#775
  sig { params(symtab: ::Idl::SymbolTable).returns(T.any(::Integer, ::Symbol)) }
  def min_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#800
  sig { params(value: ::Integer, width: ::Integer, signed: T::Boolean).returns(::Integer) }
  def truncate(value, width, signed); end

  # source://idlc//lib/idlc/ast.rb#738
  sig { abstract.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#762
  sig do
    abstract
      .params(
        symtab: ::Idl::SymbolTable
      ).returns(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)]))
  end
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#797
  sig do
    params(
      symtab: ::Idl::SymbolTable
    ).returns(T::Array[T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)])])
  end
  def values(symtab); end
end

# source://idlc//lib/idlc/ast.rb#817
Idl::RvalueAst = T.type_alias { T.all(::Idl::AstNode, ::Idl::Rvalue) }

# source://idlc//lib/idlc/interfaces.rb#52
module Idl::Schema
  interface!

  # source://idlc//lib/idlc/interfaces.rb#61
  sig { abstract.returns(::Integer) }
  def max_val; end

  # source://idlc//lib/idlc/interfaces.rb#58
  sig { abstract.returns(T::Boolean) }
  def max_val_known?; end

  # source://idlc//lib/idlc/interfaces.rb#67
  sig { abstract.returns(::Integer) }
  def min_val; end

  # source://idlc//lib/idlc/interfaces.rb#64
  sig { abstract.returns(T::Boolean) }
  def min_val_known?; end

  # source://idlc//lib/idlc/interfaces.rb#70
  sig { abstract.returns(::Idl::Type) }
  def to_idl_type; end
end

# source://idlc//lib/idlc/ast.rb#4236
class Idl::SignCastAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4244
  def initialize(input, interval, exp); end

  # source://idlc//lib/idlc/ast.rb#4240
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4242
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#163
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#4273
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4270
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4252
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4247
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#4255
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4280
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::SignCastAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4230
class Idl::SignCastSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4231
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#12362
module Idl::SingleDeclaration0
  # source://idlc//lib/idlc/idl_parser.rb#12363
  def ary_size_decl; end
end

# source://idlc//lib/idlc/idl_parser.rb#12368
module Idl::SingleDeclaration1
  # source://idlc//lib/idlc/idl_parser.rb#12377
  def ary_size; end

  # source://idlc//lib/idlc/idl_parser.rb#12373
  def id; end

  # source://idlc//lib/idlc/idl_parser.rb#12369
  def type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#11931
module Idl::SingleDeclarationWithInitialization0
  # source://idlc//lib/idlc/idl_parser.rb#11940
  def ary_size; end

  # source://idlc//lib/idlc/idl_parser.rb#11936
  def id; end

  # source://idlc//lib/idlc/idl_parser.rb#11944
  def rval; end

  # source://idlc//lib/idlc/idl_parser.rb#11932
  def type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#16722
module Idl::Space0
  # source://idlc//lib/idlc/idl_parser.rb#16723
  def space?; end
end

# source://idlc//lib/idlc/idl_parser.rb#12462
module Idl::Statement0
  # source://idlc//lib/idlc/idl_parser.rb#12463
  def a; end

  # source://idlc//lib/idlc/idl_parser.rb#12467
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#12473
module Idl::Statement1
  # source://idlc//lib/idlc/idl_parser.rb#12474
  def a; end
end

# source://idlc//lib/idlc/ast.rb#6258
class Idl::StatementAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#6266
  def initialize(input, interval, action); end

  # source://idlc//lib/idlc/ast.rb#6264
  def action; end

  # source://idlc//lib/idlc/ast.rb#6262
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6276
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#6286
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#259
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#83
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/prune.rb#222
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#82
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#69
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6300
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6297
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6271
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6307
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::StatementAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6211
class Idl::StatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6212
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16625
module Idl::String0; end

# source://idlc//lib/idlc/idl_parser.rb#16628
module Idl::String1; end

# source://idlc//lib/idlc/ast.rb#7010
class Idl::StringLiteralAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#7017
  sig { params(input: T.nilable(::String), interval: T.nilable(T::Range[::Integer]), text: ::String).void }
  def initialize(input, interval, text); end

  # source://idlc//lib/idlc/ast.rb#7014
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#55
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7024
  sig { override.returns(::String) }
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#7042
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#7039
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7029
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#7027
  def type_check(_symtab); end

  # source://idlc//lib/idlc/ast.rb#7034
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#7049
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::StringLiteralAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6998
module Idl::StringLiteralSyntaxNode
  # source://idlc//lib/idlc/ast.rb#6999
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#1004
Idl::StringType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/idl_parser.rb#1191
module Idl::StructDefinition0
  # source://idlc//lib/idlc/idl_parser.rb#1196
  def id; end

  # source://idlc//lib/idlc/idl_parser.rb#1192
  def type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#1202
module Idl::StructDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#1207
  def member; end

  # source://idlc//lib/idlc/idl_parser.rb#1203
  def user_type_name; end
end

# source://idlc//lib/idlc/ast.rb#2255
class Idl::StructDefinitionAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#2270
  def initialize(input, interval, name, member_types, member_names); end

  # source://idlc//lib/idlc/ast.rb#2298
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#2268
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2265
  def member_names; end

  # source://idlc//lib/idlc/ast.rb#2309
  def member_type(name, symtab); end

  # source://idlc//lib/idlc/ast.rb#2262
  def member_types; end

  # source://idlc//lib/idlc/ast.rb#2259
  def name; end

  # source://idlc//lib/idlc/ast.rb#2316
  def num_members; end

  # source://idlc//lib/idlc/ast.rb#2328
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2319
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2287
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#2279
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2341
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2234
class Idl::StructDefinitionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2235
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#599
class Idl::StructType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#604
  sig { params(type_name: ::String, member_types: T::Array[::Idl::Type], member_names: T::Array[::String]).void }
  def initialize(type_name, member_types, member_names); end

  # source://idlc//lib/idlc/type.rb#614
  def clone; end

  # source://idlc//lib/idlc/type.rb#618
  def default; end

  # source://idlc//lib/idlc/type.rb#626
  def member?(name); end

  # source://idlc//lib/idlc/type.rb#628
  def member_type(member_name); end

  # source://idlc//lib/idlc/type.rb#612
  sig { returns(::String) }
  def name; end

  # source://idlc//lib/idlc/type.rb#636
  def runtime?; end

  # source://idlc//lib/idlc/type.rb#601
  sig { returns(::String) }
  def type_name; end
end

# source://idlc//lib/idlc/symbol_table.rb#122
class Idl::SymbolTable
  # source://idlc//lib/idlc/symbol_table.rb#237
  sig do
    params(
      mxlen: T.nilable(::Integer),
      possible_xlens_cb: T.nilable(T.proc.returns(T::Array[::Integer])),
      builtin_global_vars: T::Array[::Idl::Var],
      builtin_enums: T::Array[::Idl::SymbolTable::EnumDef],
      builtin_funcs: T.nilable(::Idl::SymbolTable::BuiltinFunctionCallbacks),
      csrs: T::Array[::Idl::Csr],
      params: T::Array[::Idl::RuntimeParam],
      name: ::String
    ).void
  end
  def initialize(mxlen: T.unsafe(nil), possible_xlens_cb: T.unsafe(nil), builtin_global_vars: T.unsafe(nil), builtin_enums: T.unsafe(nil), builtin_funcs: T.unsafe(nil), csrs: T.unsafe(nil), params: T.unsafe(nil), name: T.unsafe(nil)); end

  # source://idlc//lib/idlc/symbol_table.rb#409
  def add(name, var); end

  # source://idlc//lib/idlc/symbol_table.rb#418
  def add!(name, var); end

  # source://idlc//lib/idlc/symbol_table.rb#435
  def add_above!(name, var); end

  # source://idlc//lib/idlc/symbol_table.rb#444
  def add_at!(level, name, var); end

  # source://idlc//lib/idlc/symbol_table.rb#468
  def at_global_scope?; end

  # source://idlc//lib/idlc/symbol_table.rb#206
  def builtin_funcs; end

  # source://idlc//lib/idlc/symbol_table.rb#343
  def callstack; end

  # source://idlc//lib/idlc/symbol_table.rb#215
  sig { params(csr_name: ::String).returns(T.nilable(::Idl::Csr)) }
  def csr(csr_name); end

  # source://idlc//lib/idlc/symbol_table.rb#209
  sig { params(csr_name: ::String).returns(T::Boolean) }
  def csr?(csr_name); end

  # source://idlc//lib/idlc/symbol_table.rb#212
  sig { returns(T::Hash[::String, ::Idl::Csr]) }
  def csr_hash; end

  # source://idlc//lib/idlc/symbol_table.rb#518
  def deep_clone(clone_values: T.unsafe(nil), freeze_global: T.unsafe(nil)); end

  # source://idlc//lib/idlc/symbol_table.rb#287
  def deep_freeze; end

  # source://idlc//lib/idlc/symbol_table.rb#428
  def del(name); end

  # source://idlc//lib/idlc/symbol_table.rb#389
  def find_all(single_scope: T.unsafe(nil), &block); end

  # source://idlc//lib/idlc/symbol_table.rb#359
  def get(name); end

  # source://idlc//lib/idlc/symbol_table.rb#367
  def get_from(name, level); end

  # source://idlc//lib/idlc/symbol_table.rb#379
  def get_global(name); end

  # source://idlc//lib/idlc/symbol_table.rb#473
  def global_clone; end

  # source://idlc//lib/idlc/symbol_table.rb#136
  def hash; end

  # source://idlc//lib/idlc/symbol_table.rb#515
  def in_use?; end

  # source://idlc//lib/idlc/symbol_table.rb#282
  sig { returns(::String) }
  def inspect; end

  # source://idlc//lib/idlc/symbol_table.rb#348
  def key?(name); end

  # source://idlc//lib/idlc/symbol_table.rb#352
  def keys_pretty; end

  # source://idlc//lib/idlc/symbol_table.rb#453
  def levels; end

  # source://idlc//lib/idlc/symbol_table.rb#159
  sig { returns(T::Boolean) }
  def multi_xlen?; end

  # source://idlc//lib/idlc/symbol_table.rb#128
  sig { returns(T.nilable(::Integer)) }
  def mxlen; end

  # source://idlc//lib/idlc/symbol_table.rb#131
  sig { returns(::String) }
  def name; end

  # source://idlc//lib/idlc/symbol_table.rb#218
  sig { params(param_name: ::String).returns(T.nilable(::Idl::RuntimeParam)) }
  def param(param_name); end

  # source://idlc//lib/idlc/symbol_table.rb#221
  sig { returns(T::Hash[::String, ::Idl::RuntimeParam]) }
  def params_hash; end

  # source://idlc//lib/idlc/symbol_table.rb#333
  def pop; end

  # source://idlc//lib/idlc/symbol_table.rb#167
  sig { returns(T::Array[::Integer]) }
  def possible_xlens; end

  # source://idlc//lib/idlc/symbol_table.rb#459
  sig { void }
  def print; end

  # source://idlc//lib/idlc/symbol_table.rb#321
  def push(ast); end

  # source://idlc//lib/idlc/symbol_table.rb#504
  def release; end

  class << self
    # source://idlc//lib/idlc/symbol_table.rb#184
    sig do
      params(
        blk: T.proc.params(arg0: ::String).returns(T.nilable(T::Boolean))
      ).returns(T.proc.params(arg0: ::String).returns(T.nilable(T::Boolean)))
    end
    def make_implemented_callback(&blk); end

    # source://idlc//lib/idlc/symbol_table.rb#198
    sig do
      params(
        blk: T.proc.params(arg0: ::Integer).returns(T.nilable(T::Boolean))
      ).returns(T.proc.params(arg0: ::Integer).returns(T.nilable(T::Boolean)))
    end
    def make_implemented_csr_callback(&blk); end

    # source://idlc//lib/idlc/symbol_table.rb#191
    sig do
      params(
        blk: T.proc.params(arg0: ::String, arg1: ::String).returns(T.nilable(T::Boolean))
      ).returns(T.proc.params(arg0: ::String, arg1: ::String).returns(T.nilable(T::Boolean)))
    end
    def make_implemented_version_callback(&blk); end
  end
end

# source://idlc//lib/idlc/symbol_table.rb#200
class Idl::SymbolTable::BuiltinFunctionCallbacks < ::T::Struct
  prop :implemented, T.proc.params(arg0: ::String).returns(T.nilable(T::Boolean))
  prop :implemented_version, T.proc.params(arg0: ::String, arg1: ::String).returns(T.nilable(T::Boolean))
  prop :implemented_csr, T.proc.params(arg0: ::Integer).returns(T.nilable(T::Boolean))
end

# source://idlc//lib/idlc/symbol_table.rb#133
class Idl::SymbolTable::DuplicateSymError < ::StandardError; end

# source://idlc//lib/idlc/symbol_table.rb#142
class Idl::SymbolTable::EnumDef < ::T::Struct
  prop :name, ::String
  prop :element_values, T::Array[::Integer]
  prop :element_names, T::Array[::String]

  # source://idlc//lib/idlc/symbol_table.rb#150
  sig { params(name: ::String, element_values: T::Array[::Integer], element_names: T::Array[::String]).void }
  def initialize(name:, element_values:, element_names:); end
end

# source://idlc//lib/idlc/symbol_table.rb#179
Idl::SymbolTable::ImplementedCallbackType = T.type_alias { T.proc.params(arg0: ::String).returns(T.nilable(T::Boolean)) }

# source://idlc//lib/idlc/symbol_table.rb#193
Idl::SymbolTable::ImplementedCsrCallbackType = T.type_alias { T.proc.params(arg0: ::Integer).returns(T.nilable(T::Boolean)) }

# source://idlc//lib/idlc/symbol_table.rb#186
Idl::SymbolTable::ImplementedVersionCallbackType = T.type_alias { T.proc.params(arg0: ::String, arg1: ::String).returns(T.nilable(T::Boolean)) }

# source://idlc//lib/idlc/symbol_table.rb#161
class Idl::SymbolTable::MemoizedState < ::T::Struct
  prop :possible_xlens, T.nilable(T::Array[::Integer])
  prop :params_hash, T.nilable(T::Hash[::String, ::Idl::RuntimeParam])
end

# source://idlc//lib/idlc/symbol_table.rb#156
Idl::SymbolTable::PossibleXlensCallbackType = T.type_alias { T.proc.returns(T::Array[::Integer]) }

# source://idlc//lib/idlc/syntax_node.rb#49
class Idl::SyntaxNode < ::Treetop::Runtime::SyntaxNode
  # source://idlc//lib/idlc/syntax_node.rb#54
  sig { overridable.returns(::Idl::AstNode) }
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#3969
module Idl::TemplateSafeP3BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#3970
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#3974
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3979
module Idl::TemplateSafeP3BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#3980
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#3984
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4205
module Idl::TemplateSafeP4BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4206
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4210
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4215
module Idl::TemplateSafeP4BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4216
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4220
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4441
module Idl::TemplateSafeP5BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4442
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4446
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4451
module Idl::TemplateSafeP5BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4452
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4456
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4677
module Idl::TemplateSafeP6BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4678
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4682
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4687
module Idl::TemplateSafeP6BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4688
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4692
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4913
module Idl::TemplateSafeP7BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4914
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4918
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4923
module Idl::TemplateSafeP7BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4924
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4928
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5149
module Idl::TemplateSafeP8BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5150
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#5154
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5159
module Idl::TemplateSafeP8BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#5160
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#5164
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5385
module Idl::TemplateSafeP9BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5386
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#5390
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5395
module Idl::TemplateSafeP9BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#5396
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#5400
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#7889
module Idl::TemplateSafeTernaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#7890
  def e; end

  # source://idlc//lib/idlc/idl_parser.rb#7898
  def f; end

  # source://idlc//lib/idlc/idl_parser.rb#7894
  def t; end
end

# source://idlc//lib/idlc/idl_parser.rb#7768
module Idl::TernaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#7769
  def e; end

  # source://idlc//lib/idlc/idl_parser.rb#7777
  def f; end

  # source://idlc//lib/idlc/idl_parser.rb#7773
  def t; end
end

# source://idlc//lib/idlc/ast.rb#6086
class Idl::TernaryOperatorExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#6096
  def initialize(input, interval, condition, true_expression, false_expression); end

  # source://idlc//lib/idlc/ast.rb#6092
  def condition; end

  # source://idlc//lib/idlc/ast.rb#6090
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6094
  def false_expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#186
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#123
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/prune.rb#456
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#6188
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6185
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6093
  def true_expression; end

  # source://idlc//lib/idlc/ast.rb#6128
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#6101
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#6169
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#6174
  def values(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6197
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::TernaryOperatorExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6075
class Idl::TernaryOperatorExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6076
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#869
class Idl::TrueExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#873
  sig { params(input: ::String, interval: T::Range[::Integer]).void }
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#878
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#148
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#89
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#893
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#890
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#884
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#881
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#887
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::TrueClass) }
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#899
    sig do
      override
        .params(
          yaml: T::Hash[::String, T.untyped],
          source_mapper: T::Hash[::String, ::String]
        ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#865
class Idl::TrueExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#866
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#15
class Idl::Type
  # source://idlc//lib/idlc/type.rb#132
  def initialize(kind, qualifiers: T.unsafe(nil), width: T.unsafe(nil), width_ast: T.unsafe(nil), max_width: T.unsafe(nil), sub_type: T.unsafe(nil), name: T.unsafe(nil), tuple_types: T.unsafe(nil), return_type: T.unsafe(nil), arguments: T.unsafe(nil), enum_class: T.unsafe(nil), csr: T.unsafe(nil)); end

  # source://idlc//lib/idlc/type.rb#48
  def ==(other); end

  # source://idlc//lib/idlc/type.rb#397
  def ary?; end

  # source://idlc//lib/idlc/type.rb#248
  def ary_type(ary); end

  # source://idlc//lib/idlc/type.rb#173
  def clone; end

  # source://idlc//lib/idlc/type.rb#188
  def comparable_to?(type); end

  # source://idlc//lib/idlc/type.rb#401
  def const?; end

  # source://idlc//lib/idlc/type.rb#258
  def convertable_to?(type); end

  # source://idlc//lib/idlc/type.rb#69
  def default; end

  # source://idlc//lib/idlc/type.rb#111
  sig { returns(::Idl::EnumerationType) }
  def enum_class; end

  # source://idlc//lib/idlc/type.rb#220
  def equal_to?(type); end

  # source://idlc//lib/idlc/type.rb#377
  def fully_qualified_name; end

  # source://idlc//lib/idlc/type.rb#413
  def global?; end

  # source://idlc//lib/idlc/type.rb#44
  sig { returns(T::Boolean) }
  def integral?; end

  # source://idlc//lib/idlc/type.rb#93
  sig { returns(::Symbol) }
  def kind; end

  # source://idlc//lib/idlc/type.rb#421
  def known?; end

  # source://idlc//lib/idlc/type.rb#439
  sig { returns(::Idl::Type) }
  def make_const; end

  # source://idlc//lib/idlc/type.rb#432
  sig { returns(::Idl::Type) }
  def make_const!; end

  # source://idlc//lib/idlc/type.rb#444
  def make_global; end

  # source://idlc//lib/idlc/type.rb#449
  def make_known; end

  # source://idlc//lib/idlc/type.rb#425
  def make_signed; end

  # source://idlc//lib/idlc/type.rb#405
  def mutable?; end

  # source://idlc//lib/idlc/type.rb#379
  def name; end

  # source://idlc//lib/idlc/type.rb#96
  sig { returns(T::Array[::Symbol]) }
  def qualifiers; end

  # source://idlc//lib/idlc/type.rb#113
  def qualify(qualifier); end

  # source://idlc//lib/idlc/type.rb#61
  def runtime?; end

  # source://idlc//lib/idlc/type.rb#409
  def signed?; end

  # source://idlc//lib/idlc/type.rb#105
  sig { returns(::Idl::Type) }
  def sub_type; end

  # source://idlc//lib/idlc/type.rb#417
  def template_var?; end

  # source://idlc//lib/idlc/type.rb#327
  sig { returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/type.rb#347
  def to_s; end

  # source://idlc//lib/idlc/type.rb#108
  sig { returns(T::Array[::Idl::Type]) }
  def tuple_types; end

  # source://idlc//lib/idlc/type.rb#99
  sig { returns(T.any(::Integer, ::Symbol)) }
  def width; end

  # source://idlc//lib/idlc/type.rb#102
  sig { returns(T.nilable(::Idl::AstNode)) }
  def width_ast; end

  class << self
    # source://idlc//lib/idlc/type.rb#582
    sig { params(schema: T::Hash[::String, T.untyped]).returns(T.nilable(::Idl::Type)) }
    def from_json_schema(schema); end

    # source://idlc//lib/idlc/type.rb#119
    def from_typename(type_name, cfg_arch); end

    private

    # source://idlc//lib/idlc/type.rb#544
    sig { params(schema: T::Hash[::String, T.untyped]).returns(::Idl::Type) }
    def from_json_schema_array_type(schema); end

    # source://idlc//lib/idlc/type.rb#457
    sig { params(schema: T::Hash[::String, T.untyped]).returns(T.nilable(::Idl::Type)) }
    def from_json_schema_scalar_type(schema); end
  end
end

# source://idlc//lib/idlc/type.rb#18
Idl::Type::KINDS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/type.rb#34
Idl::Type::QUALIFIERS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/type.rb#171
Idl::Type::TYPE_FROM_KIND = T.let(T.unsafe(nil), Hash)

# source://idlc//lib/idlc/ast.rb#7822
Idl::TypeNameAst = T.type_alias { T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst) }

# source://idlc//lib/idlc/idl_parser.rb#6782
module Idl::UnaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#6783
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#6788
module Idl::UnaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#6789
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#6793
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#6799
module Idl::UnaryExpression2
  # source://idlc//lib/idlc/idl_parser.rb#6800
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#6806
module Idl::UnaryExpression3
  # source://idlc//lib/idlc/idl_parser.rb#6807
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#6813
module Idl::UnaryExpression4
  # source://idlc//lib/idlc/idl_parser.rb#6814
  def user_type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#6820
module Idl::UnaryExpression5
  # source://idlc//lib/idlc/idl_parser.rb#6821
  def user_type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#6827
module Idl::UnaryExpression6
  # source://idlc//lib/idlc/idl_parser.rb#6832
  def expression; end

  # source://idlc//lib/idlc/idl_parser.rb#6828
  def user_type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#6838
module Idl::UnaryExpression7
  # source://idlc//lib/idlc/idl_parser.rb#6839
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#6845
module Idl::UnaryExpression8
  # source://idlc//lib/idlc/idl_parser.rb#6846
  def ary; end

  # source://idlc//lib/idlc/idl_parser.rb#6850
  def value; end
end

# source://idlc//lib/idlc/idl_parser.rb#6856
module Idl::UnaryExpression9
  # source://idlc//lib/idlc/idl_parser.rb#6861
  def e; end

  # source://idlc//lib/idlc/idl_parser.rb#6857
  def o; end
end

# source://idlc//lib/idlc/ast.rb#5943
class Idl::UnaryOperatorExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5951
  def initialize(input, interval, op, expression); end

  # source://idlc//lib/idlc/ast.rb#5947
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6040
  def exp; end

  # source://idlc//lib/idlc/ast.rb#5949
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#265
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5957
  def invert(symtab); end

  # source://idlc//lib/idlc/ast.rb#6045
  def op; end

  # source://idlc//lib/idlc/ast.rb#6054
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6051
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5968
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5984
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#6012
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6062
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::UnaryOperatorExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5931
class Idl::UnaryOperatorExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5932
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#7067
class Idl::UnknownLiteral
  # source://idlc//lib/idlc/ast.rb#7069
  def initialize(known_value, unknown_mask); end

  # source://idlc//lib/idlc/ast.rb#7077
  def &(other); end

  # source://idlc//lib/idlc/ast.rb#7098
  def ==(other); end

  # source://idlc//lib/idlc/ast.rb#7073
  def bit_length; end

  # source://idlc//lib/idlc/ast.rb#7068
  def known_value; end

  # source://idlc//lib/idlc/ast.rb#7128
  def to_s; end

  # source://idlc//lib/idlc/ast.rb#7068
  def unknown_mask; end

  # source://idlc//lib/idlc/ast.rb#7076
  def zero?; end

  # source://idlc//lib/idlc/ast.rb#7107
  def |(other); end
end

# source://idlc//lib/idlc/idl_parser.rb#15764
module Idl::UserTypeName0; end

# source://idlc//lib/idlc/ast.rb#7770
class Idl::UserTypeNameAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#7774
  def initialize(input, interval, name); end

  # source://idlc//lib/idlc/ast.rb#7772
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#66
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7780
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#7803
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#7800
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7791
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#7783
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#7810
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::UserTypeNameAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#7764
class Idl::UserTypeNameSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7765
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#28
Idl::ValueRbType = T.type_alias { T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)]) }

# source://idlc//lib/idlc/symbol_table.rb#17
class Idl::Var
  # source://idlc//lib/idlc/symbol_table.rb#22
  def initialize(name, type, value = T.unsafe(nil), decode_var: T.unsafe(nil), template_index: T.unsafe(nil), function_name: T.unsafe(nil), param: T.unsafe(nil), for_loop_iter: T.unsafe(nil)); end

  # source://idlc//lib/idlc/symbol_table.rb#68
  def clone; end

  # source://idlc//lib/idlc/symbol_table.rb#80
  def const?; end

  # source://idlc//lib/idlc/symbol_table.rb#47
  sig { returns(T::Boolean) }
  def const_eval?; end

  # source://idlc//lib/idlc/symbol_table.rb#42
  sig { void }
  def const_incompatible!; end

  # source://idlc//lib/idlc/symbol_table.rb#84
  def decode_var?; end

  # source://idlc//lib/idlc/symbol_table.rb#56
  sig { returns(T::Boolean) }
  def for_loop_iter?; end

  # source://idlc//lib/idlc/symbol_table.rb#60
  def hash; end

  # source://idlc//lib/idlc/symbol_table.rb#20
  def name; end

  # source://idlc//lib/idlc/symbol_table.rb#88
  def param?; end

  # source://idlc//lib/idlc/symbol_table.rb#102
  def template_index; end

  # source://idlc//lib/idlc/symbol_table.rb#108
  def template_val?; end

  # source://idlc//lib/idlc/symbol_table.rb#98
  def template_value?; end

  # source://idlc//lib/idlc/symbol_table.rb#94
  def template_value_for?(function_name); end

  # source://idlc//lib/idlc/symbol_table.rb#112
  def to_cxx; end

  # source://idlc//lib/idlc/symbol_table.rb#64
  def to_s; end

  # source://idlc//lib/idlc/symbol_table.rb#20
  def type; end

  # source://idlc//lib/idlc/symbol_table.rb#20
  def value; end

  # source://idlc//lib/idlc/symbol_table.rb#116
  def value=(new_value); end
end

# source://idlc//lib/idlc/idl_parser.rb#16508
module Idl::VarWrite0
  # source://idlc//lib/idlc/idl_parser.rb#16509
  def csr_name; end
end

# source://idlc//lib/idlc/ast.rb#2680
class Idl::VariableAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#2704
  def initialize(input, interval, lhs_ast, rhs_ast); end

  # source://idlc//lib/idlc/ast.rb#2684
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2735
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#2756
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#241
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2699
  sig { returns(::Idl::IdAst) }
  def lhs; end

  # source://idlc//lib/idlc/passes/prune.rb#74
  def nullify_assignments(symtab); end

  # source://idlc//lib/idlc/passes/prune.rb#69
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#2702
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#2773
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2770
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2710
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2725
  def var(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2781
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::VariableAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2669
class Idl::VariableAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2670
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#3536
class Idl::VariableDeclarationAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#3566
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      type_name: T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst),
      id: ::Idl::IdAst,
      ary_size: T.nilable(T.all(::Idl::AstNode, ::Idl::Rvalue))
    ).void
  end
  def initialize(input, interval, type_name, id, ary_size); end

  # source://idlc//lib/idlc/ast.rb#3636
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#3552
  sig { returns(T.nilable(T.all(::Idl::AstNode, ::Idl::Rvalue))) }
  def ary_size; end

  # source://idlc//lib/idlc/ast.rb#3540
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3582
  sig { params(symtab: ::Idl::SymbolTable).returns(T.nilable(::Idl::Type)) }
  def decl_type(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#174
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3549
  sig { returns(::Idl::IdAst) }
  def id; end

  # source://idlc//lib/idlc/ast.rb#3577
  sig { void }
  def make_global; end

  # source://idlc//lib/idlc/ast.rb#3555
  sig { returns(::String) }
  def name; end

  # source://idlc//lib/idlc/ast.rb#3657
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#3648
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#3607
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#3610
  def type_check(symtab, add_sym = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3546
  sig { returns(T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst)) }
  def type_name; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3669
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::VariableDeclarationAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3525
class Idl::VariableDeclarationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3526
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#3719
class Idl::VariableDeclarationWithInitializationAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#3761
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      type_name_ast: T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst),
      var_write_ast: ::Idl::IdAst,
      ary_size: T.nilable(T.all(::Idl::AstNode, ::Idl::Rvalue)),
      rval_ast: T.all(::Idl::AstNode, ::Idl::Rvalue),
      is_for_loop_iteration_var: T::Boolean
    ).void
  end
  def initialize(input, interval, type_name_ast, var_write_ast, ary_size, rval_ast, is_for_loop_iteration_var); end

  # source://idlc//lib/idlc/ast.rb#3835
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#3742
  sig { returns(T.nilable(T.all(::Idl::AstNode, ::Idl::Rvalue))) }
  def ary_size; end

  # source://idlc//lib/idlc/ast.rb#3724
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3865
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#3881
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#219
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3748
  sig { returns(::String) }
  def id; end

  # source://idlc//lib/idlc/ast.rb#3739
  sig { returns(::Idl::IdAst) }
  def lhs; end

  # source://idlc//lib/idlc/ast.rb#3775
  def lhs_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#3771
  def make_global; end

  # source://idlc//lib/idlc/passes/prune.rb#93
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#3745
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#3896
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#3887
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#3802
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#3736
  sig { returns(T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst)) }
  def type_name; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3910
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::VariableDeclarationWithInitializationAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3692
class Idl::VariableDeclarationWithInitializationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3693
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#1394
module Idl::VersionString0; end

# source://idlc//lib/idlc/type.rb#1003
Idl::VoidType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#4169
class Idl::WidthRevealAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4179
  sig { params(input: T.nilable(::String), interval: T.nilable(T::Range[::Integer]), e: ::Idl::AstNode).void }
  def initialize(input, interval, e); end

  # source://idlc//lib/idlc/ast.rb#4173
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4176
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def expression; end

  # source://idlc//lib/idlc/ast.rb#4211
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4208
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4192
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4184
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#4201
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Integer) }
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4218
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::WidthRevealAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4163
class Idl::WidthRevealSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4164
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#981
class Idl::XregType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#982
  def initialize(xlen); end

  # source://idlc//lib/idlc/type.rb#990
  def to_cxx; end

  # source://idlc//lib/idlc/type.rb#986
  def to_s; end
end

# source://idlc//lib/idlc.rb#13
class IdlParser < ::Treetop::Runtime::CompiledParser
  include ::Idl

  # source://idlc//lib/idlc.rb#14
  def input_file; end

  # source://idlc//lib/idlc.rb#35
  def instantiate_node(node_type, *args); end

  # source://idlc//lib/idlc.rb#16
  def set_input_file(filename, starting_line = T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#21
  def set_pb(pb); end

  # source://idlc//lib/idlc.rb#27
  def unset_pb; end

  protected

  # source://idlc//lib/idlc.rb#32
  def idlc_instantiate_node(node_type, *args); end
end

class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin
  include ::Udb::Helpers::WavedromUtil

  private

  # source://idlc//lib/idlc/passes/prune.rb#19
  def create_bool_literal(value); end

  # source://idlc//lib/idlc/passes/prune.rb#14
  def create_int_literal(value); end

  # source://idlc//lib/idlc/passes/prune.rb#27
  def create_literal(symtab, value, type); end
end

# source://idlc//lib/idlc/syntax_node.rb#11
module Treetop; end

# source://idlc//lib/idlc/syntax_node.rb#12
module Treetop::Runtime; end

# source://idlc//lib/idlc/syntax_node.rb#13
class Treetop::Runtime::SyntaxNode
  # source://idlc//lib/idlc/syntax_node.rb#20
  sig { params(filename: T.nilable(::String), starting_line: ::Integer).void }
  def set_input_file(filename, starting_line = T.unsafe(nil)); end

  # source://idlc//lib/idlc/syntax_node.rb#39
  sig { params(filename: T.nilable(::String), starting_line: ::Integer).void }
  def set_input_file_unless_already_set(filename, starting_line = T.unsafe(nil)); end

  # source://idlc//lib/idlc/syntax_node.rb#30
  sig { returns(T::Boolean) }
  def space?; end
end
