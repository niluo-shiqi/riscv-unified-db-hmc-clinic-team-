/*
 * generated by Xtext 2.39.0
 */
package org.xtext.example.udb.validation;

import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.xtext.example.udb.udb.UdbPackage;

import org.xtext.example.udb.udb.Url;
import org.xtext.example.udb.udb.Email;

import org.xtext.example.udb.udb.CsrModel;
import org.xtext.example.udb.udb.CsrFieldDef;
import org.xtext.example.udb.udb.CsrIntType;
import org.xtext.example.udb.udb.CsrLengthType;
import org.xtext.example.udb.udb.CsrName;
import org.xtext.example.udb.udb.CsrFieldAliasName;
import org.xtext.example.udb.udb.CsrAffectedByType;
import org.xtext.example.udb.udb.CsrFieldAffectedBy;

import org.xtext.example.udb.udb.ExtModel;
import org.xtext.example.udb.udb.ExtVersionArrayElement;
import org.xtext.example.udb.udb.ExtVersionRepoArrayElement;
import org.xtext.example.udb.udb.ExtVersionContributorsArrayElement;

import org.xtext.example.udb.udb.InstModel;



/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class UdbValidator extends AbstractUdbValidator {
	
	// Regex's found in schema_defs.json
	String rviVersionRegex = "^[0-9]+(\\.[0-9]+(\\.[0-9]+(-pre)?)?)?$";
	String csrFieldRegex = "^[a-z][a-z0-9_.]+\\.[A-Z0-9]+$";
    String csrFieldBitsRegex = "^[a-z][a-z0-9_.]+\\.[A-Z0-9]+\\[[0-9]+(:[0-9]+)?\\]$";
    String csrNameRegex = "^[a-z][a-z0-9_.]+$";
    String csrAffectedByRegex = "^(RV64)|([A-WY]|(Z[a-z]+)|(S[a-z]+))$";
    String extensionNameRegex = "^(([A-WY])|([SXZ][a-z0-9]+))$";
    
    // Extra regex's for validation
    String urlRegex = "^https?:\\/\\/[^\\s/$.?#].[^\\s]*$"; // NOTE: not perfect
    String emailRegex = "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$";

	
    
    /*
     * CSR Validation -- rules found in csr_schema.json
     */
	@Check
	public void checkAddress(CsrModel csr) {
		// Address must be between 0 and 12 bits
		int address = csr.getAddress() != null ? csr.getAddress().getAddress().getValue() : null;

		if(address < 0 || address > 4096) {
			error("Address must be between 0 and 12 bits.", UdbPackage.Literals.CSR_MODEL__ADDRESS);
		}
	}

	@Check
	public void checkVirtualAddressValue(CsrModel csr) {
		/* Ensure virtual address is in required range 0-4095 */
		int vaddress = csr.getVirtualAddress() != null ?
					   csr.getVirtualAddress().getVirtualAddress().getValue() : null;

		if (vaddress < 0 || vaddress > 4095) {
			error("Virtual address must be between 0 and 12 bits.", UdbPackage.Literals.CSR_MODEL__VIRTUAL_ADDRESS);
		}
	}

	@Check
	public void checkIndirectAddressValue(CsrModel csr) {
		/* Ensure indirect address is in required range */
		int iaddress = csr.getIndirectAddress() != null ?
					   csr.getIndirectAddress().getIndirectAddress().getValue() : null;

		if(iaddress < 0 || iaddress > (2^64)) {
			error("Indirect address must be between 0 and 64 bits.", UdbPackage.Literals.CSR_MODEL__INDIRECT_ADDRESS);
		}
	}

	@Check
	public void checkLengthValue(CsrModel csr) {
		// Containment reference is always instantiated
		CsrLengthType length_t = csr.getLength().getLength();
		if (length_t == null) {
			error("length should not be null",
					UdbPackage.Literals.CSR_MODEL__LENGTH);
		}
		// If length is an integer, value is either 32 or 64
		if (length_t instanceof CsrIntType) {
			Integer length = ((CsrIntType) csr.getLength().getLength()).getIntVal();
			if (length != 32 && length != 64) {
				error("length if specified as integer, should be 32 or 64",
						UdbPackage.Literals.CSR_MODEL__LENGTH);
			}
		}
//		if (length != null && length != "MXLEN" && length != "SXLEN" && length != "VSXLEN" && length != "XLEN") {
//			if (Integer.valueOf(length) != 32 && Integer.valueOf(length) != 64) {
//			error("Integer length value must be 32 or 64.", UdbPackage.Literals.MODEL__LENGTH);
//			}
//		}

	}

	@Check
	public void checkIndirectSlotValue(CsrModel csr) {
		/* Ensure indirect_slot is between 1 and 6 */
		int slot = csr.getIndirectSlot() != null ? csr.getIndirectSlot().getIndirectSlot() : null;

		if (slot < 1 || slot > 6) {
			error("Indirect slot value must be between 1 and 6.", UdbPackage.Literals.CSR_MODEL__INDIRECT_SLOT);
		}
	}
	
	@Check
	public void checkCsrPrivMode(CsrModel csr) {
		String mode = csr.getPrivmode() != null ? csr.getPrivmode().getPrivMode() : null;
		java.util.Set<String> ALLOWED_TYPES = java.util.Set.of("M","S","U","VS","D");
		
		if (mode != null && !ALLOWED_TYPES.contains(mode)) {
		    error(
		        "Invalid privilege mode: " + mode,
		        UdbPackage.Literals.CSR_MODEL__PRIVMODE
		    );
		}
	}

	@Check
	public void checkVirtualAddress(CsrModel csr) {
		String mode = csr.getPrivmode() != null ? csr.getPrivmode().getPrivMode() : null;

		if (mode.equals("VS")) {
			if (csr.getVirtualAddress() == null) {
				error("VS mode requires a virtual address.", UdbPackage.Literals.CSR_MODEL__PRIVMODE);
			}
		}

	}
	
	@Check
	public void checkCsrName(CsrName name) {
	    String value = name.getName();
	    if (!value.matches(csrNameRegex)) {
	        error("Invalid csr name", 
	              UdbPackage.Literals.CSR_NAME__NAME);
	    }
	}
	
	@Check
	public void checkCsrFieldName(CsrFieldDef field) {
		String value = field.getName();
		if (!value.matches("^[a-zA-Z].*$")) {
			error("Invalid field name",
					UdbPackage.Literals.CSR_FIELD_DEF__NAME);
		}
	}
	
	@Check
	public void checkCsrFieldAlias(CsrFieldAliasName alias) {
		String value = String.join("", alias.getName().getWords());

	    if (!value.matches(csrFieldRegex) &&
	        !value.matches(csrFieldBitsRegex)) {

	        error(
	            "Alias must match CSR_FIELD or CSR_FIELD_BITS naming format",
	            UdbPackage.Literals.CSR_FIELD_ALIAS_NAME__NAME
	        );
	    }
	}
	
	@Check
	public void checkCsrFieldAffectedBy(CsrFieldAffectedBy affectedBy) {
		CsrAffectedByType type = affectedBy.getAffectedBy(); 
		String name = type.getAffectedByName();
		
		if (name != null) {
			if (!name.matches(csrAffectedByRegex)) {
				error("Invalid extension name", // TODO: is this an okay error message?
						UdbPackage.Literals.CSR_FIELD_AFFECTED_BY__AFFECTED_BY);
			}
		} else {
			EList<String> exts = type.getAffectedByArray().getNames();
			for (int i = 0; i < exts.size(); i++) {
				String ext = exts.get(i);
				if (!ext.matches(csrAffectedByRegex)) {
					error("Invalid extension name",
							UdbPackage.Literals.CSR_FIELD_AFFECTED_BY__AFFECTED_BY);
				}
			}
		}
	}
	
	
	
	/*
	 * Instruction Validation -- rules found in inst_schema.json
	 */
	@Check
	public void checkInstructionModel(InstModel inst) {
		// TODO: implement
	}
	
	
	
	/*
	 * Extension Validation -- rules found in ext_schema.json
	 */
	@Check
	public void checkExtensionModel(ExtModel ext) {
		String schema = ext.getSchema().getSchema();
		if (!schema.equals("ext_schema.json#")) {
			error("Schema incompatible with kind", ext.getSchema(), UdbPackage.Literals.SCHEMA__SCHEMA);
		}
		
		// check that the extension name is valid
	    String name = ext.getExtName().getName();
	    if (!name.matches(extensionNameRegex)) {
	        error("Invalid extension name", ext.getExtName(),
	              UdbPackage.Literals.EXT_NAME__NAME);
	    }
	    
	    EList<ExtVersionArrayElement> versions = ext.getExtVersions().getElements();
	    
	    for (int i=0; i < versions.size(); i++) {
	    	ExtVersionArrayElement elem = versions.get(i);
	    	checkExtVersionArrayElement(elem);
	    }
	    
	    // Check that url's follow uri format
	    Url companyUrl = ext.getCompany() != null ? ext.getCompany().getUrl() : null;
	    checkUrlFormat(companyUrl);
	    Url docLicenseUrl = ext.getDocLicense() != null ? ext.getDocLicense().getUrl() : null;
	    checkUrlFormat(docLicenseUrl);
	    Url docLicenseTextUrl = ext.getDocLicense() != null ? ext.getDocLicense().getTextUrl() : null;
	    checkUrlFormat(docLicenseTextUrl);
	}
	
	public void checkExtVersionArrayElement(ExtVersionArrayElement elem) {
		// Validate elements in the versions array
		
		// check that the string representation of the version is valid
    	String versionString = elem.getVersion();
    	if (!versionString.matches(rviVersionRegex)) {
			error("Invalid version", elem, UdbPackage.Literals.EXT_VERSION_ARRAY_ELEMENT__VERSION);
		}
    	
    	// if state is ratified, a ratification date must be given
    	String versionState = elem.getVersionState().getState();
		if (versionState.equals("ratified")) {
			if (elem.getRatificationDate() == null) {
				error("Ratified states require a ratification date.", elem,
						UdbPackage.Literals.EXT_VERSION_ARRAY_ELEMENT__VERSION_STATE);
			}
		}
		
		// check that url follows uri format
		Url versionUrl = elem.getUrl();
		checkUrlFormat(versionUrl);
		
		// check that url's in repositories follow uri format
		EList<ExtVersionRepoArrayElement> repos = 
				elem.getRepositories() != null ? elem.getRepositories().getRepositories() : null;
		if (!(repos == null)) {
			for (int j = 0; j < repos.size(); j++) {
				ExtVersionRepoArrayElement r = repos.get(j);
				
				Url repoUrl = r.getUrl();
				checkUrlFormat(repoUrl);
			}
		}
		
		// check that contributor emails follow email format
		EList<ExtVersionContributorsArrayElement> contributors = 
				elem.getVersionContributors() != null ? elem.getVersionContributors().getContributors() : null;
		if (!(contributors == null)) {
			for (int j = 0; j < contributors.size(); j++) {
				ExtVersionContributorsArrayElement c = contributors.get(j);
				
				Email contributorEmail = c.getEmail();
				checkEmailFormat(contributorEmail);
			}
		}	
	}
	
	
	
	/*
	 *  Helper functions to validate more general fields (e.g. url, email, etc.)
	 */
	public void checkUrlFormat(Url url) {
		// Check that URLs follow the URI format
		if (!(url == null)) {
			String urlString = String.join("", url.getUrl().getWords());
			if (!urlString.matches(urlRegex)) {
				error("URL not in URI format", url, UdbPackage.Literals.URL__URL);
			}
		}

	}
	
	public void checkEmailFormat(Email email) {
		// Check that emails follow email format
		if (!(email == null)) {
			String emailString = String.join("", email.getEmail().getWords());
			if (!emailString.matches(emailRegex)) {
				error("Email not in formatted correctly", email, UdbPackage.Literals.EMAIL__EMAIL);
			}
		}
	}

}
