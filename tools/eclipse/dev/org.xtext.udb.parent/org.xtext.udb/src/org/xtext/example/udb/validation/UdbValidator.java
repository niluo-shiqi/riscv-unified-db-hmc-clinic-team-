/*
 * generated by Xtext 2.39.0
 */
package org.xtext.example.udb.validation;

import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.xtext.example.udb.udb.UdbPackage;

import org.xtext.example.udb.udb.Url;
import org.xtext.example.udb.udb.Email;

import org.xtext.example.udb.udb.CsrModel;
import org.xtext.example.udb.udb.CsrFieldDef;
import org.xtext.example.udb.udb.CsrLengthType;
import org.xtext.example.udb.udb.CsrName;
import org.xtext.example.udb.udb.CsrFieldAliasName;
import org.xtext.example.udb.udb.CsrAffectedByType;
import org.xtext.example.udb.udb.CsrFieldAffectedBy;

import org.xtext.example.udb.udb.ExtModel;
import org.xtext.example.udb.udb.ExtVersionArrayElement;
import org.xtext.example.udb.udb.ExtVersionRepoArrayElement;
import org.xtext.example.udb.udb.ExtVersionContributorsArrayElement;

import org.xtext.example.udb.udb.InstModel;
import  org.xtext.example.udb.udb.InstOldEncoding;
import org.xtext.example.udb.udb.InstEncoding;
import org.xtext.example.udb.udb.InstHintElement;
import org.xtext.example.udb.udb.InstOpcodeEntry;
import org.xtext.example.udb.udb.InstOpcodeInherits;
import org.xtext.example.udb.udb.InstRvPairEncoding;
import org.xtext.example.udb.udb.InstEncodingTwoKeyVar;
import org.xtext.example.udb.udb.InstEncodingSevenKeyVar;
import org.xtext.example.udb.udb.InstEncodingVariables;
import org.eclipse.emf.ecore.EObject;
/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class UdbValidator extends AbstractUdbValidator {
	
	// Regex's found in schema_defs.json
	String rviVersionRegex = "^[0-9]+(\\.[0-9]+(\\.[0-9]+(-pre)?)?)?$";
	String csrFieldRegex = "^[a-z][a-z0-9_.]+\\.[A-Z0-9]+$";
    String csrFieldBitsRegex = "^[a-z][a-z0-9_.]+\\.[A-Z0-9]+\\[[0-9]+(:[0-9]+)?\\]$";
    String csrNameRegex = "^[a-z][a-z0-9_.]+$";
    String csrAffectedByRegex = "^(RV64)|([A-WY]|(Z[a-z]+)|(S[a-z]+))$";
    String extensionNameRegex = "^(([A-WY])|([SXZ][a-z0-9]+))$";
    String instructionNameRegex= "[a-z0-9.]+";
    String instructionHintsRegex = "^\\$ref:\\s*inst/.+\\.yaml#.*$";
    String instructionInheritTypeRegex="^.+\\.yaml#(/.*)?$";
    String instructionOpcodeInheritTypeRegex="inst_opcode/[^/]+\\.yaml#/data";
    String instructionChildOfRegex="common/inst_variable_types\\.yaml#/[a-zA-Z0-9_]+";
    String ENC_48 = "^[01-]{43}11111$";
    String ENC_32 = "^[01-]{30}11$";
    String ENC_16 = "^[01-]{14}((00)|(01)|(10))$";
    
    // Extra regex's for validation
    String urlRegex = "^https?:\\/\\/[^\\s/$.?#].[^\\s]*$";
    String emailRegex = "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$";
    
	
    
    /*
     * CSR Validation -- rules found in csr_schema.json
     */
	@Check
	public void checkAddress(CsrModel csr) {
		// Address must be between 0 and 12 bits
		int address = csr.getAddress() != null ? csr.getAddress().getAddress().getValue() : null;

		if(address < 0 || address > 4096) {
			error("Address must be between 0 and 12 bits.", UdbPackage.Literals.CSR_MODEL__ADDRESS);
		}
	}

	@Check
	public void checkVirtualAddressValue(CsrModel csr) {
		/* Ensure virtual address is in required range 0-4095 */
		int vaddress = csr.getVirtualAddress() != null ?
					   csr.getVirtualAddress().getVirtualAddress().getValue() : null;

		if (vaddress < 0 || vaddress > 4095) {
			error("Virtual address must be between 0 and 12 bits.", UdbPackage.Literals.CSR_MODEL__VIRTUAL_ADDRESS);
		}
	}

	@Check
	public void checkIndirectAddressValue(CsrModel csr) {
		/* Ensure indirect address is in required range */
		int iaddress = csr.getIndirectAddress() != null ?
					   csr.getIndirectAddress().getIndirectAddress().getValue() : null;

		if(iaddress < 0 || iaddress > (2^64)) {
			error("Indirect address must be between 0 and 64 bits.", UdbPackage.Literals.CSR_MODEL__INDIRECT_ADDRESS);
		}
	}

	@Check
	public void checkLengthValue(CsrModel csr) {
		CsrLengthType length_t = csr.getLength() != null ? csr.getLength().getLength() : null;
		if (length_t == null) {
			error("length should not be null", UdbPackage.Literals.CSR_MODEL__LENGTH);
			return;
		}
		
		// If length is an integer, value is either 32 or 64
		if (length_t.getParmType() == null) {
			int length = length_t.getIntType();
			if (length != 32 && length != 64) {
				error("length if specified as integer, should be 32 or 64", UdbPackage.Literals.CSR_MODEL__LENGTH);
			}
		 }

	}

	@Check
	public void checkIndirectSlotValue(CsrModel csr) {
		/* Ensure indirect_slot is between 1 and 6 */
		int slot = csr.getIndirectSlot() != null ? csr.getIndirectSlot().getIndirectSlot() : null;

		if (slot < 1 || slot > 6) {
			error("Indirect slot value must be between 1 and 6.", UdbPackage.Literals.CSR_MODEL__INDIRECT_SLOT);
		}
	}
	
	@Check
	public void checkCsrPrivMode(CsrModel csr) {
		String mode = csr.getPrivmode() != null ? csr.getPrivmode().getPrivMode() : null;
		java.util.Set<String> ALLOWED_TYPES = java.util.Set.of("M","S","U","VS","D");
		
		if (mode != null && !ALLOWED_TYPES.contains(mode)) {
		    error(
		        "Invalid privilege mode: " + mode,
		        UdbPackage.Literals.CSR_MODEL__PRIVMODE
		    );
		}
	}

	@Check
	public void checkVirtualAddress(CsrModel csr) {
		String mode = csr.getPrivmode() != null ? csr.getPrivmode().getPrivMode() : null;

		if (mode.equals("VS")) {
			if (csr.getVirtualAddress() == null) {
				error("VS mode requires a virtual address.", UdbPackage.Literals.CSR_MODEL__PRIVMODE);
			}
		}

	}
	
	@Check
	public void checkCsrName(CsrName name) {
	    String value = name.getName();
	    if (!value.matches(csrNameRegex)) {
	        error("Invalid csr name", 
	              UdbPackage.Literals.CSR_NAME__NAME);
	    }
	}
	
	@Check
	public void checkCsrFieldName(CsrFieldDef field) {
		String value = field.getName();
		if (!value.matches("^[a-zA-Z].*$")) {
			error("Invalid field name",
					UdbPackage.Literals.CSR_FIELD_DEF__NAME);
		}
	}
	
	@Check
	public void checkCsrFieldAlias(CsrFieldAliasName alias) {
		String value = alias.getName();

	    if (!value.matches(csrFieldRegex) &&
	        !value.matches(csrFieldBitsRegex)) {

	        error(
	            "Alias must match CSR_FIELD or CSR_FIELD_BITS format",
	            UdbPackage.Literals.CSR_FIELD_ALIAS_NAME__NAME
	        );
	    }
	}
	
	@Check
	public void checkCsrFieldAffectedBy(CsrFieldAffectedBy affectedBy) {
		CsrAffectedByType type = affectedBy.getAffectedBy(); 
		String name = type.getAffectedByName();
		
		if (name != null) {
			if (!name.matches(csrAffectedByRegex)) {
				error("Invalid extension name", // TODO: is this an okay error message?
						UdbPackage.Literals.CSR_FIELD_AFFECTED_BY__AFFECTED_BY);
			}
		} else {
			EList<String> exts = type.getAffectedByArray().getNames();
			for (int i = 0; i < exts.size(); i++) {
				String ext = exts.get(i);
				if (!ext.matches(csrAffectedByRegex)) {
					error("Invalid extension name",
							UdbPackage.Literals.CSR_FIELD_AFFECTED_BY__AFFECTED_BY);
				}
			}
		}
	}
	
	
	
	/*
	 * Instruction Validation -- rules found in inst_schema.json
	 */
	@Check
	public void checkBaseValue(InstModel inst) {
		/* Ensure base value is either 32 or 64 */
		int base = inst.getBase() != null ?inst.getBase().getBase() : null;

		if (base != 32 && base != 64) {
			error("Base must have value of 32 or 64.", UdbPackage.Literals.INST_MODEL__BASE);
		}
	}


	@Check
	public void checkInstructionModel(InstModel inst) {
		String schema = inst.getSchema().getSchema();
		if (!schema.equals("inst_schema.json#")) {
			error("Schema incompatible with kind", inst.getSchema(), UdbPackage.Literals.SCHEMA__SCHEMA);
		}
		
		// check that the extension name is valid
	    String name = inst.getInstName().getName();
	    if (!name.matches(instructionNameRegex)) {
	        error("Invalid instruction name", inst.getInstName(),
	              UdbPackage.Literals.INST_NAME__NAME);
	    }
	}
	
	/*
	 *  Check access detail field is present when at least one mode 
	 *  within access field is sometimes
	 */
	@Check
	public void checkInstAccessDetail(InstModel inst) {
		String accessdetail = inst.getAccessDetail() != null ? inst.getAccessDetail().getAccessDetail(): null;

		String m = inst.getAccess().getM() != null ? inst.getAccess().getM().getAccessLevel(): null;
		String s = inst.getAccess().getS() != null ? inst.getAccess().getS().getAccessLevel(): null;
		String u = inst.getAccess().getU() != null ? inst.getAccess().getU().getAccessLevel(): null;
		String vs = inst.getAccess().getVs() != null ? inst.getAccess().getVs().getAccessLevel(): null;
		String vu = inst.getAccess().getVu() != null ? inst.getAccess().getVu().getAccessLevel(): null;

		boolean sometimes =
			    "sometimes".equals(m) ||
			    "sometimes".equals(s) ||
			    "sometimes".equals(u) ||
			    "sometimes".equals(vs) ||
			    "sometimes".equals(vu);
		if (sometimes == true && (accessdetail == null || accessdetail == "")) {
			error("Must provide access_detail field when at least one access type is sometimes", UdbPackage.Literals.INST_MODEL__ACCESS_DETAIL);
		}
	}
	
	@Check
	// Check that hints (strings within array) are of format ^inst/.+\\.yaml#.*$
	public void checkInstHints(InstModel inst) {
		EList<InstHintElement> hints = inst.getHints() != null ? inst.getHints().getHints(): null;
		
	
		for (InstHintElement hint : hints) {
			String hintString = hint.getHint();
			
			if (!(hintString.matches(instructionHintsRegex))) {
				error("hints must be of format $ref: inst/<path>.yaml# or $ref: inst/<path>.yaml#/...", UdbPackage.Literals.INST_MODEL__HINTS);
			}
		}
	}
	
	@Check
	// Check that hints (strings within array) are of format ^inst/.+\\.yaml#.*$
	public void checkInstInherits(InstModel inst) {
		
		// validate top level inherits attribute within format
		EList<String> inheritsList = inst.getFormat().getInherits() != null ? inst.getFormat().getInherits().getReference() : null;
		
		for (String address : inheritsList) {
			if (!(address.matches(instructionInheritTypeRegex))) {
				error("$inherits field must follow expected format: <path>.yaml# or <path>.yaml#/<fragment>.", UdbPackage.Literals.INST_MODEL__FORMAT);
			}
		}
		
		
		// validate inherit attribute within opcodes within format
		if (inst.getFormat() == null || inst.getFormat().getOpcodes() == null) {
	        return;
	    }
		for (InstOpcodeEntry entry: inst.getFormat().getOpcodes().getOpcode()) {
			if(entry instanceof InstOpcodeInherits) {
				InstOpcodeInherits opcodeInherits = (InstOpcodeInherits) entry;
				String address = opcodeInherits.getInheritsAddress();
				
				if (!(address.matches(instructionOpcodeInheritTypeRegex))) {
					error("$inherits field within opcodes must follow string address format inst_opcode/<file>.yaml#/data", UdbPackage.Literals.INST_MODEL__FORMAT);
				}
				
			}
		}
		
	}
	
	// Check match regex within encoding
	@Check
	public void checkEncodingMatches(InstModel inst) {
		InstEncoding encoding = inst.getEncoding();
		
		if (encoding instanceof InstOldEncoding) {
			InstOldEncoding oldEncoding = (InstOldEncoding) encoding;
			
			String match = oldEncoding.getMatch().getPattern();
			//error(match + " this is match", UdbPackage.Literals.INST_MODEL__ENCODING);
			
			// if match doesn't match any of these
			if (!(match.matches(ENC_48)) && !(match.matches(ENC_16)) && !(match.matches(ENC_32))) {
				error("Expected match to follow one of these patterns: 48-bit ([01-]{43}11111), 32-bit ([01-]{30}11), or  16-bit ([01-]{14}(00|01|10)).", UdbPackage.Literals.INST_MODEL__ENCODING);
			}
		}
		
		else if (encoding instanceof InstRvPairEncoding) {
			InstRvPairEncoding rvEncoding = (InstRvPairEncoding) encoding;
			
			String Rv32match = rvEncoding.getRv32().getMatch().getPattern();
			String Rv64match = rvEncoding.getRv64().getMatch().getPattern();
			//error(Rv32match + " this is rv32 match", UdbPackage.Literals.INST_MODEL__ENCODING);
			//error(Rv64match + " this is rv64 match", UdbPackage.Literals.INST_MODEL__ENCODING);
			
			// if match doesn't match any of these
			if (!(Rv32match.matches(ENC_48)) && !(Rv32match.matches(ENC_16)) && !(Rv32match.matches(ENC_32))) {
				error("Expected match to follow one of these patterns: 48-bit ([01-]{43}11111), 32-bit ([01-]{30}11), or  16-bit ([01-]{14}(00|01|10)).", UdbPackage.Literals.INST_MODEL__ENCODING);
			}
			
			if (!(Rv64match.matches(ENC_48)) && !(Rv64match.matches(ENC_16)) && !(Rv64match.matches(ENC_32))) {
				error("Expected match to follow one of these patterns: 48-bit ([01-]{43}11111), 32-bit ([01-]{30}11), or  16-bit ([01-]{14}(00|01|10)).", UdbPackage.Literals.INST_MODEL__ENCODING);
			}
		}
		
	}
	
	// Check $inherits and $childof regex within variables within encoding(they share the same regex)
	@Check
	public void checkInheritsAndChildOf(InstModel inst) {
		InstEncoding encoding = inst.getEncoding();
		if (!(encoding instanceof InstOldEncoding)) {
			return;
		}
		
		InstOldEncoding old = (InstOldEncoding) encoding;
		InstEncodingVariables varsList = old.getVariables();
		
		if (varsList == null) {
			return;
		}
		
		for (EObject var: varsList.getVars()) {
			if (var instanceof InstEncodingTwoKeyVar) {
				InstEncodingTwoKeyVar twoKey = (InstEncodingTwoKeyVar) var;
				String inherits = twoKey.getInherits();
				
				if (inherits != null && !(inherits.matches(instructionChildOfRegex))) {
					error("Expected $inherits to follow common/inst_variable_types\\.yaml#/SOMETHING format", twoKey, UdbPackage.Literals.INST_ENCODING_TWO_KEY_VAR__INHERITS);
				}
			} else if (var instanceof InstEncodingSevenKeyVar) {
				InstEncodingSevenKeyVar sevenKey = (InstEncodingSevenKeyVar) var;
				String childOf = sevenKey.getChildOf();
				
				if (childOf != null && !(childOf.matches(instructionChildOfRegex))) {
					error("Expected $child_of to follow common/inst_variable_types\\.yaml#/SOMETHING format", sevenKey, UdbPackage.Literals.INST_ENCODING_SEVEN_KEY_VAR__CHILD_OF);
				}
			}
		}
	}
	
	
	/*
	 * Extension Validation -- rules found in ext_schema.json
	 */
	@Check
	public void checkExtensionModel(ExtModel ext) {
		String schema = ext.getSchema().getSchema();
		if (!schema.equals("ext_schema.json#")) {
			error("Schema incompatible with kind", ext.getSchema(), UdbPackage.Literals.SCHEMA__SCHEMA);
		}
		
		// check that the extension name is valid
	    String name = ext.getExtName().getName();
	    if (!name.matches(extensionNameRegex)) {
	        error("Invalid extension name", ext.getExtName(),
	              UdbPackage.Literals.EXT_NAME__NAME);
	    }
	    
	    EList<ExtVersionArrayElement> versions = ext.getExtVersions().getElements();
	    
	    for (int i=0; i < versions.size(); i++) {
	    	ExtVersionArrayElement elem = versions.get(i);
	    	checkExtVersionArrayElement(elem);
	    }
	    
	    // Check that url's follow uri format
	    Url companyUrl = ext.getCompany() != null ? ext.getCompany().getUrl() : null;
	    checkUrlFormat(companyUrl);
	    Url docLicenseUrl = ext.getDocLicense() != null ? ext.getDocLicense().getUrl() : null;
	    checkUrlFormat(docLicenseUrl);
	    Url docLicenseTextUrl = ext.getDocLicense() != null ? ext.getDocLicense().getTextUrl() : null;
	    checkUrlFormat(docLicenseTextUrl);
	}
	
	public void checkExtVersionArrayElement(ExtVersionArrayElement elem) {
		// Validate elements in the versions array
		
		// check that the string representation of the version is valid
    	String versionString = elem.getVersion();
    	if (!versionString.matches(rviVersionRegex)) {
			error("Invalid version", elem, UdbPackage.Literals.EXT_VERSION_ARRAY_ELEMENT__VERSION);
		}
    	
    	// if state is ratified, a ratification date must be given
    	String versionState = elem.getVersionState().getState();
		if (versionState.equals("ratified")) {
			if (elem.getRatificationDate() == null) {
				error("Ratified states require a ratification date.", elem,
						UdbPackage.Literals.EXT_VERSION_ARRAY_ELEMENT__VERSION_STATE);
			}
		}
		
		// check that url follows uri format
		Url versionUrl = elem.getUrl();
		checkUrlFormat(versionUrl);
		
		// check that url's in repositories follow uri format
		EList<ExtVersionRepoArrayElement> repos = 
				elem.getRepositories() != null ? elem.getRepositories().getRepositories() : null;
		if (!(repos == null)) {
			for (int j = 0; j < repos.size(); j++) {
				ExtVersionRepoArrayElement r = repos.get(j);
				
				Url repoUrl = r.getUrl();
				checkUrlFormat(repoUrl);
			}
		}
		
		// check that contributor emails follow email format
		EList<ExtVersionContributorsArrayElement> contributors = 
				elem.getVersionContributors() != null ? elem.getVersionContributors().getContributors() : null;
		if (!(contributors == null)) {
			for (int j = 0; j < contributors.size(); j++) {
				ExtVersionContributorsArrayElement c = contributors.get(j);
				
				Email contributorEmail = c.getEmail();
				checkEmailFormat(contributorEmail);
			}
		}	
	}
	
	
	
	/*
	 *  Helper functions to validate more general fields (e.g. url, email, etc.)
	 */
	public void checkUrlFormat(Url url) {
		// Check that URLs follow the URI format
		if (!(url == null)) {
			String urlString = url.getUrl();
			if (!urlString.matches(urlRegex)) {
				error("URL not in URI format", url, UdbPackage.Literals.URL__URL);
			}
		}

	}
	
	public void checkEmailFormat(Email email) {
		// Check that emails follow email format
		if (!(email == null)) {
			String emailString = email.getEmail();
			if (!emailString.matches(emailRegex)) {
				error("Email not in formatted correctly", email, UdbPackage.Literals.EMAIL__EMAIL);
			}
		}
	}

}
