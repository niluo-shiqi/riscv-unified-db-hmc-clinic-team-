grammar org.xtext.example.udb.Udb with org.eclipse.xtext.common.Terminals
hidden(SL_COMMENT, WS)
generate udb "http://www.xtext.org/example/udb/Udb"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	  csr  = CsrModel
	| inst = InstModel
	| ext  = ExtModel
;


CsrModel:
	schema = Schema // must be "csr_schema.json#"
	csrKind = CsrKind
	csrName = CsrName &
	longName = LongName &
	description = Description &
	definedBy = CsrDefinedBy &
	address = CsrAddress &
	indirectAddress = CsrIndirectAddress? &
	indirectSlot = CsrIndirectSlot? &
	writable = CsrWritable &
	privmode = CsrPrivMode &
	virtualAddress = CsrVirtualAddress? &
	length = CsrLength &
	requires = CsrRequires? &
	csrFields = CsrFields? &
	swRead = CsrSwRead? &
	source = Source? &
	certNormativeRules = CertNormativeRules?
;


InstModel: placeholder=STRING;


ExtModel: 
	schema = Schema // must be "ext_schema.json#"
	extKind = ExtKind
	extName = ExtName &
	longName = LongName &
	description = Description &
	rviJiraIssue = ExtRviJiraIssue? &
	company = ExtCompany? &
	docLicense = DocLicense? &
	type = ExtType &
	requirements = Requirements? &
	extVersions = ExtVersions &
	source = Source? &
	certNormativeRules = CertNormativeRules?
;



/* 
 * Common stuff
 */
Schema: "$schema" ":" schema=STRING;
LongName: 'long_name' ":" longName=STRING;
Description: 'description' ':' description=STRING; 
Requirements: "requirements" ":" requirements=Condition;
Source:'$source' ':' source=STRING;

UdbId: 'id' ':' id=STRING;
Url: 'url' ':' url=STRING;
Email: 'email' ':' email=STRING;

// see "cert_normative_rules" in schema_defs.json
// TODO: not tested
CertNormativeRules: 
	'cert_normative_rules' ':' 
	INDENT	
		rules += CNRuleArrayElement+
	DEDENT
;
CNRuleArrayElement:
	'-' id = UdbId // TODO: makes id the first element (do we want this?)
	INDENT (
		('name' ':' name = STRING) &
		docLinks = DocLinks &
		description = Description
	) DEDENT
;
DocLinks:	
	"doc_links" ":"
	INDENT
		links += DocLinksArrayElement+
	DEDENT
;
DocLinksArrayElement:
	'-' link = STRING	// TODO: this must follow the URI format
;

// see "license" in schema_defs.json 
DocLicense:
	'doc_license' ':'
	INDENT (
		('name' ':' name=STRING) & 
		id=UdbId? &
		url=Url? &
		textUrl=Url?
	) DEDENT
;



/*
 * CSR stuff (see csr_schema.json)
 */
CsrKind: 'kind' ':' kind="csr";
CsrName: 'name' ':' name=ID;
CsrAddress: 'address' ':' address=Hex;
CsrWritable: 'writable' ':' writable=Boolean;
CsrDefinedBy: 'definedBy' ':' extensionName=STRING;
CsrIndirectAddress:'indirect_address' ':' indirectAddress=Hex;
CsrIndirectSlot:'indirect_slot' ':' indirectSlot=INT ; 
CsrVirtualAddress:'virtual_address' ':' virtualAddress=Hex;
CsrSwRead:'sw_read()' ':' swRead=IDL;
CsrPrivMode:'priv_mode' ':' privMode=ID;
CsrLength: 'length' ':' length=CsrLengthType;
CsrLengthType: intType = CsrIntType | parmType = CsrParmType;
CsrIntType: intVal=INT; 
CsrParmType: parmName=('MXLEN'|'SXLEN'|'VSXLEN'|'XLEN');

// extension that must be implemented for this CSR to exist
CsrRequires:'requires' ':' requires=STRING; 

// grammar for csr_field
CsrFields:
	{CsrFields} 'fields' ':'
	INDENT
    	fields += CsrFieldDef+
    DEDENT
;

CsrFieldDef:
	name=ID ':'
	INDENT (
		displayName = CsrFieldDisplayName? &
		longName = LongName? &
		location = CsrFieldLocationType &
		resetValue = CsrFieldResetValueType &
		swWriteFunc = CsrFieldSWWriteFunc? &
		legalFunc = CsrFieldLegalFunc? &
		description = Description &
		type = CsrFieldTypeType &
		alias = CsrFieldAlias? &
		definedBy = CsrDefinedBy? &
		affectedBy = CsrFieldAffectedBy? &
		certNormativeRules = CertNormativeRules?
	) DEDENT
;

CsrFieldDisplayName: 'name' ':' fieldName=STRING ;

CsrFieldLocationType: staticLoc = CsrStaticLocation | funcLoc = CsrVarLocation;
CsrStaticLocation: 'location' ':' locValue=CsrFieldLocation;
CsrVarLocation:
	locationRV32=LocationRV32 &
	locationRV64=LocationRV64
;
LocationRV32: "location_rv32" ":" locationRV32=CsrFieldLocation;
LocationRV64: "location_rv64" ":" locationRV64=CsrFieldLocation;
CsrFieldLocation: value=INT | range=CsrFieldLocationRange;
CsrFieldLocationRange: upper=INT '-' lower=INT;

CsrFieldResetValueType: value=CsrFieldResetValue | function=CsrFieldResetValueFunc;
CsrFieldResetValue: "reset_value" ":" resetValue=CsrFieldResetValueValue;
CsrFieldResetValueValue: value=INT | undefinedLegal=UndefinedLegal;
CsrFieldResetValueFunc: "reset_value()" ":" resetValueFunc=IDL;

CsrFieldSWWriteFunc: "sw_write(csr_value)" ":" swWriteFunc=IDL;
CsrFieldLegalFunc: "legal?(csr_value)" ":" legalFunc=IDL;

CsrFieldTypeType: typeVal=CsrFieldType | typeFunc=CsrFieldTypeFunc;
CsrFieldType: "type" ":" perms=("RO"|"RO-H"|"RW"|"RW-R"|"RW-H"|"RW-RH");
CsrFieldTypeFunc: "type()" ":" idl=IDL;

CsrFieldAlias: "alias" ":" (aliasName=CsrFieldAliasName | aliasArray=CsrFieldAliasArray);
CsrFieldAliasName: name=ID;
CsrFieldAliasArray:
	"items" ":"
	INDENT
		aliases += CsrAliasArrayElement+
	DEDENT
;
CsrAliasArrayElement:
	"-" alias = CsrFieldAliasName 
;

// TODO: cross-referencing
CsrFieldAffectedBy: "affectedBy" ":" affectedBy=CsrAffectedByType; 
CsrAffectedByType: affectedByName=ID | affectedByArray=Array;




/*
 * Instruction stuff (see inst_schema.json)
 * NOTE: implementation started in PRIDE1099-INST branch
 */



/* 
 * Extension stuff (see ext_schema.json) 
 */
ExtKind: 'kind' ':' kind="extension";
ExtName: 'name' ':' name=ID;
ExtType: 'type' ':' perms=('unprivileged' | 'privileged');
ExtRviJiraIssue: 'rvi_jira_issue' ':' issue=STRING;
ExtCompany: 
	'company' ':' 
	INDENT (
		('name' ':' name=STRING) &
		 url=Url?
	) DEDENT 
;

// versions grammar (see ext_schema.json)
ExtVersions:
	"versions" ":" 
	INDENT
		elements += ExtVersionArrayElement+
	DEDENT
;

ExtVersionArrayElement:
	'-' "version" ":" version=STRING // TODO: this has to be first, is that okay?
	INDENT (
		versionState = ExtVersionState &
		repositories = ExtVersionRepositories? &
		ratificationDate = ExtVersionRatificationDate? &
		versionChanges = ExtVersionVersionChanges? &
		url = Url? &
		versionContributors = ExtVersionContributors? &
		requirements = Requirements?
	) DEDENT
;

ExtVersionState: 
	"state" ":" 
	state=("development" | "frozen" | "public-review" | 
		   "ratification-ready" | "ratified" | "nonstandard-released")
;

ExtVersionRepositories:
	"repositories" ":"
	INDENT
		repositories += ExtVersionRepoArrayElement+
	DEDENT
;
ExtVersionRepoArrayElement: // TODO: this is ordered, that okay?
	'-' url=Url
	(INDENT
		"branch" ":" branch=STRING
	DEDENT)?
;

ExtVersionRatificationDate:
	"ratification_date" ":"
	date = (
	  YEAR_MONTH			// when ratification date is known
	| "unknown"				// when ratification date is unknown
	| "null")				// when version isn't ratified			
;

ExtVersionVersionChanges:
	"changes" ":"
	INDENT
		changes += ExtVersionChangesArrayElement+
	DEDENT
;
ExtVersionChangesArrayElement:
	'-' change=STRING
;

ExtVersionContributors:
	"contributors" ":"
	INDENT
		contributors += ExtVersionContributorsArrayElement+ 
	DEDENT
;
ExtVersionContributorsArrayElement:
	'-' name=ExtVersionContributorName // TODO: is it okay that name must be the first element?
	(INDENT (
		("company" ":" company=STRING)? & // company contributor worked for or 'Individual'
		email=Email?
	) DEDENT)?
;
ExtVersionContributorName:
	"name" ":" firstName = ID lastName = ID?
;



/* Conditions */
Condition: cond=STRING; // placeholder
//Condition: yamlCond=YAMLCondition | idlCond=IDLCondition;

//YAMLCondition:
//	yaml = YAMLCondition (TODO: implement)
//	  extensionCond = ExtensionCondition
//	| paramCond = ParamCondition
//	| xlenCond = XLenCondition
//;

//IDLCondition:
//	"idl()" ":" idl=IDL
//	reason?=Reason
//;
//
//ExtensionCondition:
//	STRING /* TODO */
//;
//
//ParamCondition:
//	STRING /* TODO */
//;

//XLenCondition: xlen=INT; /* can be 32 or 64 (TODO: implement in validator) */

//Reason: "reason" ":" reasonStr=STRING;



/* IDL Grammar */
IDL: idl=STRING;





/*
 * Keywords
 */
UndefinedLegal: "UNDEFINED_LEGAL";
Boolean returns ecore::EBoolean: "true" | "false";



/*
 * Helpers
 */
Array: '[' names+=ID (',' names+=ID)+ ']';



/*
 * Hex
 */
Hex: value=HEX_VALUE;
terminal HEX_VALUE returns ecore::EInt:
	('0x' | '0X')
	('0'..'9' | 'A'..'F' | 'a'..'f')
	(('0'..'9' | 'A'..'F' | 'a'..'f' | '_')*('0'..'9' | 'A'..'F' | 'a'..'f'))?
;



/*
 * Terminals
 */
terminal YEAR_MONTH:
	(('20')('0'..'9')('0'..'9')'-'    
	  ('0'('1'..'9') | '1'('0'..'2')))
;

// Use this instead of STRING to avoid having to use quotes
@Override
terminal ID: 
	'^'?('a'..'z'|'A'..'Z'|'_') 
	('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'.')*;

// For whitespace awareness
terminal INDENT: 'synthetic:INDENT';
terminal DEDENT: 'synthetic:DEDENT';

@Override
terminal SL_COMMENT: '#' !('\n'|'\r')*;

@Override
terminal WS: ('\r'|'\n'|'\t'|' ')+;
