grammar org.xtext.example.udb.Udb with org.eclipse.xtext.common.Terminals
hidden(SL_COMMENT, WS)
generate udb "http://www.xtext.org/example/udb/Udb"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	  csr  = CsrModel
	| inst = InstModel
	| ext  = ExtModel
;


CsrModel:
	schema = Schema // must be "csr_schema.json#"
	csrKind = CsrKind
	csrName = CsrName &
	longName = LongName &
	description = Description &
	definedBy = CsrDefinedBy &
	address = CsrAddress &
	indirectAddress = CsrIndirectAddress? &
	indirectSlot = CsrIndirectSlot? &
	writable = CsrWritable &
	privmode = CsrPrivMode &
	virtualAddress = CsrVirtualAddress? &
	length = CsrLength &
	requires = CsrRequires? &
	csrFields = CsrFields? &
	swRead = CsrSwRead? &
	source = Source? &
	certNormativeRules = CertNormativeRules?
;


InstModel: 
	schema = Schema // must be "inst_schema.json#"
	kind = InstKind
	instName = InstName &
	longName = LongName &
	description = Description &
	definedBy = InstDefinedBy &
	hints = InstHints? &
	base = InstBase? &
	access = InstAccess &
	accessDetail = InstAccessDetail? &
	operation = InstOperation? &
	operationAst = InstOperationAst? &
	sail = InstSail? &
	certNormativeRules = CertNormativeRules? &
	assembly = InstAssembly &
	dataIndependentTiming = InstDataIndependentTiming? &
	pseudoInstructions = InstPseudoInstructions? &
	source = Source? &
	format = InstFormat? &
	encoding = InstEncoding?
;



ExtModel: 
	schema = Schema // must be "ext_schema.json#"
	extKind = ExtKind
	extName = ExtName &
	longName = LongName &
	description = Description &
	rviJiraIssue = ExtRviJiraIssue? &
	company = ExtCompany? &
	docLicense = DocLicense? &
	type = ExtType &
	requirements = Requirements? &
	extVersions = ExtVersions &
	source = Source? &
	certNormativeRules = CertNormativeRules?
;



/* 
 * Common stuff
 */
Schema: "$schema" ":" schema=STRING;
LongName: 'long_name' ":" longName=STRING;
Description: 'description' ':' description=STRING; 
Requirements: "requirements" ":" requirements=Condition;
Source:'$source' ':' source=STRING;

Number: intVal=INT | bin=Bin | hex=Hex;
Range: upper=INT '-' lower=INT;
UdbId: 'id' ':' id=STRING;
Url: 'url' ':' url=STRING;
Email: 'email' ':' email=STRING;

// see "cert_normative_rules" in schema_defs.json
// TODO: not tested
CertNormativeRules: 
	'cert_normative_rules' ':' 
	INDENT	
		rules += CNRuleArrayElement+
	DEDENT
;
CNRuleArrayElement:
	'-' id = UdbId // TODO: makes id the first element (do we want this?)
	INDENT (
		('name' ':' name = STRING) &
		docLinks = DocLinks &
		description = Description
	) DEDENT
;
DocLinks:	
	"doc_links" ":"
	INDENT
		links += DocLinksArrayElement+
	DEDENT
;
DocLinksArrayElement:
	'-' link = STRING	// TODO: this must follow the URI format
;

// see "license" in schema_defs.json 
DocLicense:
	'doc_license' ':'
	INDENT (
		('name' ':' name=STRING) & 
		id=UdbId? &
		url=Url? &
		textUrl=Url?
	) DEDENT
;



/*
 * CSR stuff (see csr_schema.json)
 */
CsrKind: 'kind' ':' kind="csr";
CsrName: 'name' ':' name=ID;
CsrAddress: 'address' ':' address=Hex;
CsrWritable: 'writable' ':' writable=Boolean;
CsrDefinedBy: 'definedBy' ':' extensionName=STRING;
CsrIndirectAddress:'indirect_address' ':' indirectAddress=Hex;
CsrIndirectSlot:'indirect_slot' ':' indirectSlot=INT ; 
CsrVirtualAddress:'virtual_address' ':' virtualAddress=Hex;
CsrSwRead:'sw_read()' ':' swRead=IDL;
CsrPrivMode:'priv_mode' ':' privMode=ID;
CsrLength: 'length' ':' length=CsrLengthType;
CsrLengthType: intType = INT | parmType = CsrParmType;
CsrParmType: parmName=('MXLEN'|'SXLEN'|'VSXLEN'|'XLEN');

// extension that must be implemented for this CSR to exist
CsrRequires:'requires' ':' requires=STRING; 

// grammar for csr_field
CsrFields:
	{CsrFields} 'fields' ':'
	INDENT
    	fields += CsrFieldDef+
    DEDENT
;

CsrFieldDef:
	name=ID ':'
	INDENT (
		displayName = CsrFieldDisplayName? &
		longName = LongName? &
		location = CsrFieldLocationType &
		resetValue = CsrFieldResetValueType &
		swWriteFunc = CsrFieldSWWriteFunc? &
		legalFunc = CsrFieldLegalFunc? &
		description = Description &
		type = CsrFieldTypeType &
		alias = CsrFieldAlias? &
		definedBy = CsrDefinedBy? &
		affectedBy = CsrFieldAffectedBy? &
		certNormativeRules = CertNormativeRules?
	) DEDENT
;

CsrFieldDisplayName: 'name' ':' fieldName=STRING ;

CsrFieldLocationType: staticLoc = CsrStaticLocation | funcLoc = CsrVarLocation;
CsrStaticLocation: 'location' ':' locValue=CsrFieldLocation;
CsrVarLocation:
	locationRV32=LocationRV32 &
	locationRV64=LocationRV64
;
LocationRV32: "location_rv32" ":" locationRV32=CsrFieldLocation;
LocationRV64: "location_rv64" ":" locationRV64=CsrFieldLocation;
CsrFieldLocation: value=INT | range=Range;

CsrFieldResetValueType: value=CsrFieldResetValue | function=CsrFieldResetValueFunc;
CsrFieldResetValue: "reset_value" ":" resetValue=CsrFieldResetValueValue;
CsrFieldResetValueValue: value=INT | undefinedLegal=UndefinedLegal;
CsrFieldResetValueFunc: "reset_value()" ":" resetValueFunc=IDL;

CsrFieldSWWriteFunc: "sw_write(csr_value)" ":" swWriteFunc=IDL;
CsrFieldLegalFunc: "legal?(csr_value)" ":" legalFunc=IDL;

CsrFieldTypeType: typeVal=CsrFieldType | typeFunc=CsrFieldTypeFunc;
CsrFieldType: "type" ":" perms=("RO"|"RO-H"|"RW"|"RW-R"|"RW-H"|"RW-RH");
CsrFieldTypeFunc: "type()" ":" idl=IDL;

CsrFieldAlias: "alias" ":" (aliasName=CsrFieldAliasName | aliasArray=CsrFieldAliasArray);
CsrFieldAliasName: name=STRING;
CsrFieldAliasArray:
	"items" ":"
	INDENT
		aliases += CsrAliasArrayElement+
	DEDENT
;
CsrAliasArrayElement:
	"-" alias = CsrFieldAliasName 
;

// TODO: cross-referencing
CsrFieldAffectedBy: "affectedBy" ":" affectedBy=CsrAffectedByType; 
CsrAffectedByType: affectedByName=ID | affectedByArray=Array;




/*
 * Instruction stuff (see inst_schema.json)
 */
InstKind: 'kind' ':' kind="instruction";
InstName: 'name' ':' name=ID;
InstDefinedBy: 'definedBy' ':' dbname=STRING;
InstBase: 'base' ':' base=INT; // 32 or 64
InstAccess:
	'access' ':'
	INDENT (
	('m' ':' m=InstAccessType)? &
	's' ':' s=InstAccessType &
	'u' ':' u=InstAccessType &
	'vs' ':' vs=InstAccessType &
	'vu' ':' vu=InstAccessType
	) DEDENT
;
InstAccessType: accessLevel=('always'|'sometimes'|'never');
InstAssembly: 'assembly' ':' assembly=STRING;
InstOperationAst: 'operation_ast' ':' operationAst=STRING;

InstHints:
	'hints' ':'
	INDENT
		hints += InstHintElement+
	DEDENT
;
InstHintElement: '-' '{' hint = STRING '}'; 

InstAccessDetail: 'access_detail' ':' accessDetail=STRING;
InstOperation: 'operation()' ':' operation=IDL; // string for now, IDL later TODO
InstSail: 'sail()' ':' sail=IDL; // string for now, IDL later TODO
InstDataIndependentTiming: 'data_independent_timing' ':' dataIndependentTiming=Boolean;
InstPseudoInstructions: 'pseudoinstructions' ':' pseudoInstructions=Array;

InstFormat: 'format' ':' 
	INDENT (
		'$inherits' ':' inherits=InstInheritType &
		'opcodes' ':' opcodes=InstOpcodeType 
	) DEDENT
;
InstInheritType:
	INDENT
		('-' reference += STRING)+ // regex must fit yaml path
	DEDENT
;

InstOpcodeType:
	INDENT
		opcode += InstOpcodeEntry+
	DEDENT
;
InstOpcodeEntry:
	InstOpcodeField
	| InstOpcodeInherits
;

InstOpcodeField: // ex. funct7 
	name=ID ':' 
	INDENT
		(opcodeProperties += InstOpcodeProps)+
	DEDENT
	
;

InstOpcodeProps: 
	'display_name' ':' displayName=ID 
	| 'value' ':' value=Number
;
InstOpcodeInherits: 
	'opcode' ':' '{' '$inherits' ':' inheritsAddress=STRING '}'// must fit regex 'inst_opcode/' INST_OPCODE_FILE '.yaml#/data'
;


InstEncoding: 
	'encoding' ':'
	(
		InstRvPairEncoding
		| InstOldEncoding
	)
;

InstOldEncoding:
	{InstOldEncoding} 
	INDENT (
	    match=InstEncodingMatch &
	    variables=InstEncodingVariables?
  	) DEDENT
;
InstEncodingMatch:
	'match' ':' pattern=STRING
;

InstEncodingVariables:
	'variables' ':'
	  INDENT
	    vars += InstEncodingVar+
	  DEDENT
;

InstEncodingVar: // TODO Check if its ok name must always be first
    '-' 'name' ':' name=ID
    (INDENT 
    	'location' ':' location=Range
    DEDENT)
;

InstRvPairEncoding:
	{RvPairEncoding}
	INDENT (
		'RV32' ':' rv32=InstOldEncoding &
		'RV64' ':' rv64=InstOldEncoding
	) DEDENT
; 


/* 
 * Extension stuff (see ext_schema.json) 
 */
ExtKind: 'kind' ':' kind="extension";
ExtName: 'name' ':' name=ID;
ExtType: 'type' ':' perms=('unprivileged' | 'privileged');
ExtRviJiraIssue: 'rvi_jira_issue' ':' issue=STRING;
ExtCompany: 
	'company' ':' 
	INDENT (
		('name' ':' name=STRING) &
		 url=Url?
	) DEDENT 
;

// versions grammar (see ext_schema.json)
ExtVersions:
	"versions" ":" 
	INDENT
		elements += ExtVersionArrayElement+
	DEDENT
;

ExtVersionArrayElement:
	'-' "version" ":" version=STRING // TODO: this has to be first, is that okay?
	INDENT (
		versionState = ExtVersionState &
		repositories = ExtVersionRepositories? &
		ratificationDate = ExtVersionRatificationDate? &
		versionChanges = ExtVersionVersionChanges? &
		url = Url? &
		versionContributors = ExtVersionContributors? &
		requirements = Requirements?
	) DEDENT
;

ExtVersionState: 
	"state" ":" 
	state=("development" | "frozen" | "public-review" | 
		   "ratification-ready" | "ratified" | "nonstandard-released")
;

ExtVersionRepositories:
	"repositories" ":"
	INDENT
		repositories += ExtVersionRepoArrayElement+
	DEDENT
;
ExtVersionRepoArrayElement: // TODO: this is ordered, that okay?
	'-' url=Url
	(INDENT
		"branch" ":" branch=STRING
	DEDENT)?
;

ExtVersionRatificationDate:
	"ratification_date" ":"
	date = (
	  YEAR_MONTH			// when ratification date is known
	| "unknown"				// when ratification date is unknown
	| "null")				// when version isn't ratified			
;

ExtVersionVersionChanges:
	"changes" ":"
	INDENT
		changes += ExtVersionChangesArrayElement+
	DEDENT
;
ExtVersionChangesArrayElement:
	'-' change=STRING
;

ExtVersionContributors:
	"contributors" ":"
	INDENT
		contributors += ExtVersionContributorsArrayElement+ 
	DEDENT
;
ExtVersionContributorsArrayElement:
	'-' name=ExtVersionContributorName // TODO: is it okay that name must be the first element?
	(INDENT (
		("company" ":" company=STRING)? & // company contributor worked for or 'Individual'
		email=Email?
	) DEDENT)?
;
ExtVersionContributorName:
	"name" ":" firstName = ID lastName = ID?
;



/* Conditions */
Condition: cond=STRING; // placeholder
//Condition: yamlCond=YAMLCondition | idlCond=IDLCondition;

//YAMLCondition:
//	yaml = YAMLCondition (TODO: implement)
//	  extensionCond = ExtensionCondition
//	| paramCond = ParamCondition
//	| xlenCond = XLenCondition
//;

//IDLCondition:
//	"idl()" ":" idl=IDL
//	reason?=Reason
//;
//
//ExtensionCondition:
//	STRING /* TODO */
//;
//
//ParamCondition:
//	STRING /* TODO */
//;

//XLenCondition: xlen=INT; /* can be 32 or 64 (TODO: implement in validator) */

//Reason: "reason" ":" reasonStr=STRING;



/* IDL Grammar */
IDL: idl=STRING;





/*
 * Keywords
 */
UndefinedLegal: "UNDEFINED_LEGAL";
Boolean returns ecore::EBoolean: "true" | "false";



/*
 * Helpers
 */
Array: '[' names+=ID (',' names+=ID)+ ']';



/*
 * Hex & Binary
 */
Hex: value=HEX_VALUE;
terminal HEX_VALUE returns ecore::EInt:
	('0x' | '0X')
	('0'..'9' | 'A'..'F' | 'a'..'f')
	(('0'..'9' | 'A'..'F' | 'a'..'f' | '_')*('0'..'9' | 'A'..'F' | 'a'..'f'))?
;

Bin: value=BIN_VALUE;
terminal BIN_VALUE returns ecore::EInt: 
	('0b' | '0B') 
	('0'|'1')
	(('0' | '1' | '_')*('0' | '1'))?
;




/*
 * Terminals
 */
terminal YEAR_MONTH:
	(('20')('0'..'9')('0'..'9')'-'    
	  ('0'('1'..'9') | '1'('0'..'2')))
;

// For whitespace awareness
terminal INDENT: 'synthetic:INDENT';
terminal DEDENT: 'synthetic:DEDENT';

@Override
terminal SL_COMMENT: '#' !('\n'|'\r')*;

@Override
terminal WS: ('\r'|'\n'|'\t'|' ')+;

@Override
terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'.')*;


