grammar org.xtext.example.udb.Udb with org.eclipse.xtext.common.Terminals
hidden(SL_COMMENT, WS)
generate udb "http://www.xtext.org/example/udb/Udb"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	  csr  = CsrModel
	| inst = InstModel
	| ext  = ExtModel
;


InstModel: placeholder=STRING;


ExtModel: 
	schema = Schema // must be "ext_schema.json#"
	kind = Kind &   // must be "extension"
	extName = ExtName  &
	longName = LongName &
	description = Description &
	rviJiraIssue = RviJiraIssue? &
	company = Company? &
	docLicense = DocLicense? &
	type = ExtType &
	requirements = Requirements? &
	extVersions = ExtVersions &
	source = Source? &
	certNormativeRules = CertNormativeRules?
;


CsrModel:
	schema = Schema // must be "csr_schema.json#"
	kind = Kind &   // must be csr
	csrName = CsrName &
	base = Base? &
	longName = LongName &
	description = Description &
	definedBy = DefinedBy &
	address = Address &
	indirectAddress = IndirectAddress? &
	indirectSlot = IndirectSlot? &
	writable = Writable &
	privmode = PrivMode &
	virtualAddress = VirtualAddress? &
	length = Length &
	requires = Requires? &
	csrFields = CsrFields? &
	swRead = SwRead? &
	source = Source? &
	certNormativeRules = CertNormativeRules?
;


/* Fields found in the schemas */
Schema: "$schema" ":" schema=STRING;
Kind: 'kind' ':' kind=KindType ;
CsrName: 'name' ':' name=ID ;
ExtName: 'name' ':' name=ID;
LongName: 'long_name' ':' longName=STRING ;
Address: 'address' ':' address=Hex ;
Writable: 'writable' ':' writable=Boolean ;
PrivMode:'priv_mode' ':' privMode=PrivType ;
Length: 'length' ':' length=LengthType ;
Description: 'description' ':' description=STRING ; /* TODO: change this to follow spec_text? (in schema defs) */
DefinedBy:'definedBy' ':'extensionName=STRING ;
Base: 'base' ':' base=INT ;
IndirectAddress:'indirect_address' ':' indirectAddress=Hex;
IndirectSlot:'indirect_slot' ':' indirectSlot=INT ; 
VirtualAddress:'virtual_address' ':' virtualAddress=Hex ;
RviJiraIssue: 'rvi_jira_issue' ':' issue=STRING;
ExtType: 'type' ':' perms=('unprivileged' | 'privileged');
Requirements: "requirements" ":" requirements=STRING; /* TODO: this needs to be Condition */
SwRead:'sw_read()' ':' swRead=IDL ;

// implement in validator?
Requires:'requires' ':' requires=STRING ;
Source:'$source' ':' source=STRING ;


/* Field types for the fields found in schemas */
KindType: type=('csr'|'extension');
PrivType: type=('M'|'S'|'U'|'VS'|'D');
LengthType: intType = IntType | parmType = ParmType;
IntType: intVal=INT; // must be either 32 or 64
ParmType: parmName=('MXLEN'|'SXLEN'|'VSXLEN'|'XLEN');


UdbId: 'id' ':' id=STRING;
Url: 'url' ':' url=STRING; 
Company: 
	'company' ':' 
	INDENT
		('name' ':' name=STRING) &
		 url=Url?
	DEDENT 
;

DocLicense:
	'doc_license' ':'
	INDENT
		('name' ':' name=STRING) & 
		id=UdbId? &
		url=Url? &
		text_url=Url?
	DEDENT
;

/* cert_normative_rules grammar */
CertNormativeRules: 
	'cert_normative_rules' ':' 
	INDENT	
		rules += CNRuleArrayElement+
	DEDENT
;

CNRuleArrayElement:
	'-' id = UdbId // TODO: makes id the first element (do we want this?)
	INDENT
		('name' ':' name = STRING) &
		docLinks = DocLinks &
		description = Description
	DEDENT
;

DocLinks:	
	"doc_links" ":"
	INDENT
		links += DocLinksArrayElement+
	DEDENT
;

DocLinksArrayElement:
	'-' link = STRING	/* TODO: these must follow the URI format */
;


/* Extension versions grammar */
ExtVersions:
	"versions" ":" 
	INDENT
		elements += ExtVersionArrayElement+
	DEDENT
;

ExtVersionArrayElement:
	'-' "version" ":" version=STRING // TODO: makes version the first element (this okay?) 
	INDENT 
		versionState = VersionState &
		repositories = Repositories? &
		ratificationDate = RatificationDate? &
		versionChanges = VersionChanges? &
		url = Url? &
		versionContributors = VersionContributors? &
		requirements = Requirements? 
	DEDENT
;

VersionState: 
	"state" ":" 
	state=( "development" | "frozen" | "public-review" | 
		    "ratification-ready" | "ratified" | "nonstandard-released")
;

Repositories:
	"repositories" ":"
	INDENT
		repositories += RepoArrayElement+
	DEDENT
;

RepoArrayElement: // TODO: this is ordered, that okay?
	'-' url=Url
	INDENT
		("branch" ":" branch=STRING)?
	DEDENT	
;

RatificationDate:
	"ratification_date" ":"
	date = (
	  YEAR_MONTH			// when ratification date is known
	| "unknown"				// when ratification date is unknown
	| "null")				// when version isn't ratified			
;

VersionChanges:
	"changes" ":"
	INDENT
		changes += ChangesArrayElement+
	DEDENT
;

ChangesArrayElement:
	'-' change=STRING
;

VersionContributors:
	"contributors" ":"
	INDENT
		contributors += ContributorsArrayElement+ 
	DEDENT
;

// TODO: is it okay that name must be the first element?
ContributorsArrayElement:
	'-' name=ContributorName
	INDENT
		("company" ":" company=STRING)? &	// company contributor worked for or 'Individual'
		("email" ":" email=STRING)?
	DEDENT
;

ContributorName:
	firstName = ID
	lastName = ID
;

/* Grammar for CSR fields */
CsrFields:
	{CsrFields} 'fields' ':'
	INDENT
    	fields += CsrFieldDef+
    DEDENT
;

CsrFieldDef:
	name=ID ':'
	INDENT
		displayName = FieldDisplayName? &
		longName = LongName? &
		location = LocationType &
		resetValue = ResetValueType &
		swWriteFunc = SWWriteFunc? &
		legalFunc = LegalFunc? &
		base = Base? &
		description = Description &
		type = CsrTypeType &
		alias = CsrFieldAlias? &
		definedBy = DefinedBy? &
		affectedBy = AffectedBy? &
		certNormativeRules = CertNormativeRules? &
	DEDENT
;


/* fields for Fields */
StaticLocation: 'location' ':' locValue=FieldLocation ;
LocationRV32: "location_rv32" ":" locationRV32=FieldLocation ;
LocationRV64: "location_rv64" ":" locationRV64=FieldLocation ;

FieldDisplayName: 'name' ':' fieldName=STRING ;
ResetValue: "reset_value" ":" resetValue=ResetValueValue ;
ResetValueFunc: "reset_value()" ":" resetValueFunc=IDL ;
SWWriteFunc: "sw_write(csr_value)" ":" swWriteFunc=IDL ;
LegalFunc: "legal?(csr_value)" ":" legalFunc=IDL ;
CsrType: "type" ":" perms=("RO"|"RO-H"|"RW"|"RW-R"|"RW-H"|"RW-RH") ;
CsrTypeFunc: "type()" ":" idl=IDL ;
CsrFieldAlias: "alias" ":" (aliasName=CsrAliasName | aliasArray=CsrAliasArray);
AffectedBy: "affectedBy" ":" affectedBy=AffectedByType ;

/* Types for Fields */

LocationType: staticLoc = StaticLocation | funcLoc = VarLocation;
VarLocation:
	locationRV32=LocationRV32
	locationRV64=LocationRV64
;
FieldLocation: value=INT | range=Range;
Range: upper=INT '-' lower=INT;
ResetValueType: value=ResetValue | function=ResetValueFunc;
ResetValueValue: value=INT | undefinedLegal=UndefinedLegal;
CsrTypeType: typeVal=CsrType | typeFunc=CsrTypeFunc;

CsrAliasName: name=ID; //+=(CSR_FIELD | CSR_FIELD_BITS)+;
CsrAliasArray:
	"items" ":"
	INDENT
		aliases += CsrAliasArrayElement+
	DEDENT
;

CsrAliasArrayElement:
	"-" alias = CsrAliasName 
;

// TODO: we probably will want a cross ref thing for this
AffectedByType: affectedByName=STRING | affectedByArray=StringArray;



/* Conditions */
Condition: cond=STRING; // placeholder
//Condition: yamlCond=YAMLCondition | idlCond=IDLCondition;

//YAMLCondition:
//	yaml = YAMLCondition (TODO: implement)
//	  extensionCond = ExtensionCondition
//	| paramCond = ParamCondition
//	| xlenCond = XLenCondition
//;

IDLCondition:
	"idl()" ":" idl=IDL
	reason?=Reason
;

ExtensionCondition:
	STRING /* TODO */
;

ParamCondition:
	STRING /* TODO */
;

XLenCondition: xlen=INT; /* can be 32 or 64 (TODO: implement in validator) */

Reason: "reason" ":" reasonStr=STRING;



/* IDL Grammar */
IDL: idl=STRING;





/* Keywords */
UndefinedLegal: "UNDEFINED_LEGAL";
Boolean returns ecore::EBoolean: "true" | "false";

/* Helpers */
StringArray: '[' names+=STRING (',' names+=STRING)+ ']';


/* Terminals */
terminal YEAR_MONTH:
	(('20')('0'..'9')('0'..'9')'-'    
	  ('0'('1'..'9') | '1'('0'..'2')))
;

//terminal URL_STRING:
//    ('http://' | 'https://') ('a'..'z' | 'A'..'Z' | '0'..'9' | '.' | '-' | '_' | '/' | '?' | '#' | '&' | '=')+;
    
//terminal EMAIL: ID '@' ID '.' ID;

Hex: value=HEX_VALUE;
terminal HEX_VALUE returns ecore::EInt:
	('0x' | '0X')
	('0'..'9' | 'A'..'F' | 'a'..'f')
	(('0'..'9' | 'A'..'F' | 'a'..'f' | '_')*('0'..'9' | 'A'..'F' | 'a'..'f'))?
;

terminal INDENT: 'synthetic:INDENT';
terminal DEDENT: 'synthetic:DEDENT';

@Override
terminal SL_COMMENT: '#' !('\n'|'\r')*;

@Override
terminal WS: ('\r'|'\n'|'\t'|' ')+;
