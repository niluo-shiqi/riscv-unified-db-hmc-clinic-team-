grammar org.xtext.example.udb.Udb with org.eclipse.xtext.common.Terminals
hidden(SL_COMMENT, WS)
generate udb "http://www.xtext.org/example/udb/Udb"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	  csr  = CsrModel
	| inst = InstModel
	| ext  = ExtModel
;


InstModel: placeholder=STRING;


ExtModel: 
	schema = Schema // must be "ext_schema.json#"
	kind = Kind &   // must be "extension"
	extName = Name &
	longName = LongName &
	description = Description &
	rviJiraIssue = RviJiraIssue? &
	company = Company? &
	docLicense = DocLicense? &
	type = ExtType &
	requirements = Requirements? &
	versions = ExtVersions &
	source = Source? &
	certNormativeRules = CertNormativeRules? &
	certTestProcedures = CertTestProcedures?
;


CsrModel:
	schema = Schema // must be "csr_schema.json#"
	kind = Kind &   // must be csr
	csrName = Name &
	base = Base? &
	longName = LongName &
	description = Description &
	definedBy = DefinedBy &
	address = Address &
	indirectAddress = IndirectAddress? &
	indirectSlot = IndirectSlot? &
	writable = Writable &
	privmode = PrivMode &
	virtualAddress = VirtualAddress? &
	length = Length &
	requires = Requires? &
	fields = CsrFields? &
	swRead = SwRead? &
	source = Source? &
	certNormativeRules = CertNormativeRules? &
	certTestProcedures = CertTestProcedures?
;


/* Fields found in the schemas */
Schema: "$schema" ":" schema=STRING;
Kind: 'kind' ':' kind=KindType ;
Name: 'name' ':' name=NameType ;
LongName: 'long_name' ':' longName=STRING ;
Address: 'address' ':' address=Hex ;
Writable: 'writable' ':' writable=Boolean ;
PrivMode:'priv_mode' ':' privMode=PrivType ;
Length: 'length' ':' length=LengthType ;
Description: 'description' ':' description=STRING ; /* TODO: change this to follow spec_text? (in schema defs) */
DefinedBy:'definedBy' ':'extensionName=STRING ;
Base: 'base' ':' base=INT ;
IndirectAddress:'indirect_address' ':' indirectAddress=Hex;
IndirectSlot:'indirect_slot' ':' indirectSlot=INT ; 
VirtualAddress:'virtual_address' ':' virtualAddress=Hex ;
RviJiraIssue: 'rvi_jira_issue' ':' issue=STRING;
ExtType: 'type' ':' perms=('unprivileged' | 'privileged');
Requirements: "requirements" ":" requirements=STRING; /* TODO: this needs to be Condition */

// implement in validator?
Requires:'requires' ':' requires=STRING ;
SwRead:'sw_read()' ':' swRead=STRING ;
Source:'$source' ':' source=STRING ;


/* Field types for the fields found in schemas */
KindType: type=('csr'|'extension');
NameType: type=(CSR_NAME | EXT_NAME);
PrivType: type=('M'|'S'|'U'|'VS'|'D');
LengthType: intType = IntType | parmType = ParmType;
IntType: intVal=INT; // must be either 32 or 64
ParmType: parmName=('MXLEN'|'SXLEN'|'VSXLEN'|'XLEN');


UdbId: 'id' ':' id=STRING;
Url: 'url' ':' url=STRING;
Company: 
	'company' ':' 
	INDENT
		'name' ':' name=STRING /* TODO: should this be required? it doesn't say so in the schema*/
		 url=Url?
	DEDENT 
;

DocLicense:
	'doc_license' ':'
	INDENT
		'name' ':' name=STRING 
		id=UdbId? &
		url=Url? &
		text_url=Url?
	DEDENT
;

/* cert_normative_rules grammar */
CertNormativeRules: 
	'cert_normative_rules' ':' 
	INDENT	
		('-' rules += CNRule)+  /* TODO: look into ararys for xtext */
	DEDENT
;

CNRule:
	id = UdbId &
	('name' ':' name = STRING) &
	docLinks = DocLinks &
	description = Description
;

DocLinks:	
	"doc_links" ":"
	INDENT
		('-' links += STRING)+ /* TODO: these must follow the URI format */
	DEDENT
;

/* cert_test_proceduers grammar */
CertTestProcedures: 
	'cert_test_procedures' ':' 
	INDENT
		('-' procedures += CTProcedure)+
	DEDENT	
;

CTProcedure:
	id = UdbId &
	"test_file_name" ":" name=STRING &
	description = Description &
	normRules = NormativeRules &
	("steps" ":" steps=STRING)?
;

NormativeRules:
	"normative_rules" ":"
	INDENT
		('-' rules += STRING)+ /* TODO: must be a rule ID */
	DEDENT
;

/* Extension versions grammar */
ExtVersions:
	"versions" ":" 
	INDENT
		('-' versions += ExtensionVersion)+
	DEDENT
;

ExtensionVersion: // incomplete
	"version" ":" version=STRING
;

/* Grammar for CSR fields */
CsrFields:
	{Fields} 'fields' ':'
	INDENT
    	fields += CsrFieldDef+
    DEDENT
;

CsrFieldDef:
	name=FIELD_NAME ':'
	INDENT
		('name' ':' fieldName = STRING ';')? &
		longName = LongName? &
		location = LocationType &
		resetValue = ResetValueType &
		swWriteFunc = SWWriteFunc? &
		legalFunc = LegalFunc? &
		base = Base? &
		description = Description &
		type = CsrTypeType &
		alias = Alias? &
		definedBy = DefinedBy? &
		affectedBy = AffectedBy? &
		certNormativeRules = CertNormativeRules? &
		certTestProcedures = CertTestProcedures?
	DEDENT
;

FieldDisplayName: 'name' ':' fieldName=STRING ;



/* fields for Fields */
StaticLocation: 'location' ':' locValue=FieldLocation ;
LocationRV32: "location_rv32" ":" locationRV32=FieldLocation ;
LocationRV64: "location_rv64" ":" locationRV64=FieldLocation ;


ResetValue: "reset_value" ":" resetValue=ResetValueValue ;
ResetValueFunc: "reset_value()" ":" resetValueFunc=IDL ;
SWWriteFunc: "sw_write(csr_value)" ":" swWriteFunc=IDL ;
LegalFunc: "legal?(csr_value)" ":" legalFunc=IDL ;
CsrType: "type" ":" perms=("RO"|"RO-H"|"RW"|"RW-R"|"RW-H"|"RW-RH") ;
CsrTypeFunc: "type()" ":" idl=IDL ;
Alias: "alias" ":" alias=AliasType ;
AffectedBy: "affectedBy" ":" affectedBy=AffectedByType ;

/* Types for Fields */

LocationType: staticLoc = StaticLocation | funcLoc = VarLocation;
VarLocation:
	locationRV32=LocationRV32
	locationRV64=LocationRV64
;
FieldLocation: value=INT | range=Range;
Range: upper=INT '-' lower=INT;
ResetValueType: value=ResetValue | function=ResetValueFunc;
ResetValueValue: value=INT | undefinedLegal=UndefinedLegal;
CsrTypeType: typeVal=CsrType | typeFunc=CsrTypeFunc;
AliasType: alias+=(CSR_FIELD | CSR_FIELD_BITS)+;

// TODO: we probably will want a cross ref thing for this
AffectedByType: affectedByName=STRING | affectedByArray=StringArray;



/* Conditions */
//Condition: yamlCond=YAMLCondition | idlCond=IDLCondition;

//YAMLCondition:
//	yaml = YAMLCondition (TODO: implement)
//	  extensionCond = ExtensionCondition
//	| paramCond = ParamCondition
//	| xlenCond = XLenCondition
//;

IDLCondition:
	"idl()" ":" idl=IDL
	reason?=Reason
;

ExtensionCondition:
	STRING /* TODO */
;

ParamCondition:
	STRING /* TODO */
;

XLenCondition: xlen=INT; /* can be 32 or 64 (TODO: implement in validator) */

Reason: "reason" ":" reasonStr=STRING;



/* IDL Grammar */
IDL: idl=STRING;





/* Keywords */
UndefinedLegal: "UNDEFINED_LEGAL";
Boolean returns ecore::EBoolean: "true" | "false";

/* Helpers*/
StringArray: '[' names+=STRING (',' names+=STRING)+ ']';

/* Names */
terminal CSR_NAME:
	('a'..'z')('a'..'z' | '0'..'9' | '_' | '.')+
;
terminal FIELD_NAME:
	('a'..'z' | 'A'..'Z')+
;
terminal CSR_FIELD:
	('a'..'z')('a'..'z' | '0'..'9' | '_' | '.')+
	('.')('A'..'Z' | '0'..'9')+
;
terminal CSR_FIELD_BITS:
	('a'..'z')('a'..'z' | '0'..'9' | '_' | '.')+
	'.'('A'..'Z' | '0'..'9')+
	'[' ('0'..'9')+(':'('0'..'9')+)? ']'
;

terminal EXT_NAME:
	('A'..'W' | 'Y') | 
	(('S' | 'X' | 'Z')('a'..'z' | '0'..'9')+)
;


Hex: value=HEX_VALUE;
terminal HEX_VALUE returns ecore::EInt:
	('0x' | '0X')
	('0'..'9' | 'A'..'F' | 'a'..'f')
	(('0'..'9' | 'A'..'F' | 'a'..'f' | '_')*('0'..'9' | 'A'..'F' | 'a'..'f'))?
;

terminal INDENT: 'synthetic:INDENT';
terminal DEDENT: 'synthetic:DEDENT';

@Override
terminal SL_COMMENT: '#' !('\n'|'\r')*;

@Override
terminal WS: ('\r'|'\n'|'\t'|' ')+;
