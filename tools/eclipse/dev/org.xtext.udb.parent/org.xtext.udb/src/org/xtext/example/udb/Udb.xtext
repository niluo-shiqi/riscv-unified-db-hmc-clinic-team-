grammar org.xtext.example.udb.Udb with org.eclipse.xtext.common.Terminals

generate udb "http://www.xtext.org/example/udb/Udb"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	kind = Kind
	csrName = Name
	longName = LongName
	address = Address
	writable = Writable
	privmode = PrivMode
	length = Length
	description = Description
	definedBy += DefinedBy
	base = Base?
	indirectAddress = IndirectAddress?
	indirectSlot = IndirectSlot?
	virtualAddress = VirtualAddress?
	requires = Requires?
	fields = Fields?
	swRead = SwRead?
	source = Source?
	certNormativeRules = CertNormativeRules?
	certTestProcedures = CertTestProcedures?
;

/* Required fields for the CSR schema */
Kind: 'kind' ':' kind=KindType ';';
Name: 'name' ':' name=NameType';';
LongName: 'long_name' ':' longName=STRING';';
Address: 'address' ':' address=Hex';'; /* need to make this only accept 3 digit hex */
Writable: 'writable' ':' writable=Boolean';';
PrivMode:'priv_mode' ':' privMode=PrivType';';
Length: 'length' ':' length=LengthType ';';
Description: 'description' ':' description=STRING ';'; /* TODO: Not fully implemented yet */
DefinedBy:'definedBy' ':'extensionName=STRING ';'; /* TODO: Not implemented yet */

/* Optional fields for the CSR schema */
Base: 'base' ':' base=INT ';';
IndirectAddress:'indirect_address' ':' indirectAddress=INT';';
IndirectSlot:'indirect_slot' ':' indirectSlot=INT';'; /* min:1 max:6 */

/* TODO:
 * Should be true if included, but 
 * should be hex if priv_mode is set to VS
 */
VirtualAddress:'virtual_address' ':' virtualAddress=Hex';'; 
Requires:'requires' ':' requires=STRING;
SwRead:'sw_read()' ':' swRead=STRING';';
Source:'$source' ':' source=STRING ';';
CertNormativeRules: 'cert_normative_rules' ':' certNormativeRules=CNRType ';';
CertTestProcedures: 'cert_test_procedures' ':' certTestProcedures=CTPType ';';

/* CSR Schema Types */
KindType: type=('csr'|'extension');
NameType: type=(CSR_NAME);
PrivType: type=('M'|'S'|'U'|'VS'|'D');
LengthType: type=LengthTypeValue;
LengthTypeValue: (INT|'MXLEN'|'SXLEN'|'VSXLEN'|'XLEN');
CNRType: '[' id=STRING ',' name=STRING ',' docLinks=StringArray ',' 
			 description=STRING ']';
CTPType: '[' id=STRING ',' name=STRING ',' description=STRING ',' 
			 normativeRules=StringArray ',' list=STRING?']';





/* Grammar for fields */
Fields:
	{Fields} 'fields' '{'
    fields += FieldDef+
  '}'
;

FieldDef:
	name=FIELD_NAME '{'
		('name' ':' fieldName = STRING ';')?
		longName += LongName?
		location += LocationType
		resetValue += ResetValueType
		swWriteFunc += SWWriteFunc?
		legalFunc += LegalFunc?
		base += Base?
		description += Description
		type += TypeType
		alias += Alias?
		definedBy += DefinedBy?
		affectedBy += AffectedBy?
		certNormativeRules += CertNormativeRules?
		certTestProcedures += CertTestProcedures?
	'}'
	
;

/* fields for Fields */
StaticLocation: 'location' ':' location=FieldLocation ';';
LocationRV32: "location_rv32" ":" locationRV32=FieldLocation ";";
LocationRV64: "location_rv64" ":" locationRV64=FieldLocation ";";
ResetValue: "reset_value" ":" resetValue=ResetValueValue ';'; 
ResetValueFunc: "reset_value()" ":" resetValueFunc=IDL ';';
SWWriteFunc: "sw_write(csr_value)" ":" swWriteFunc=IDL ';';
LegalFunc: "legal?(csr_value)" ":" legalFunc=IDL ';';
Type: "type" ":" type=("RO"|"RO-H"|"RW"|"RW-R"|"RW-H"|"RW-RH") ';';
TypeFunc: "type()" ":" typeFunc=IDL ";";
Alias: "alias" ":" alias=AliasType';'; 
AffectedBy: "affectedBy" ":" affectedBy=AffectedByType ";";

/* Types for Fields */
LocationType: location = (StaticLocation | FuncLocation);
FuncLocation: 
	locationRV32=LocationRV32 
	locationRV64=LocationRV64
;
FieldLocation: {FieldLocation} (value=INT | range=Range);
Range: start=INT '-' end=INT;
ResetValueType: resetValue=(ResetValue | ResetValueFunc);
ResetValueValue: {ResetValueValue} (value=INT | undefinedLegal=UndefinedLegal);
TypeType: type=(Type | TypeFunc);
AliasType: alias+=(CSR_FIELD | CSR_FIELD_BITS)+;
AffectedByType: affectedBy += AFFECTED_BY_NAME | AffectedByArray;
AffectedByArray:
    '[' names+=AFFECTED_BY_NAME (',' names+=AFFECTED_BY_NAME)* ']'
;




/* IDL Grammar */
IDL: idl=STRING;





/* Keywords */
UndefinedLegal: "UNDEFINED_LEGAL";
Boolean returns ecore::EBoolean: "true" | "false";

/* Array Types */
StringArray: '[' items+=STRING ']';

/* Terminals */
terminal CSR_NAME:  
	('a'..'z')('a'..'z' | '0'..'9' | '_' | '.')+ /* .? */
;
terminal FIELD_NAME: 
	('a'..'z' | 'A'..'Z')+
;
terminal CSR_FIELD:
	('a'..'z')('a'..'z' | '0'..'9' | '_' | '.')+  /* .? */
	('.')('A'..'Z' | '0'..'9')+
;
terminal CSR_FIELD_BITS:
	('a'..'z')('a'..'z' | '0'..'9' | '_' | '.')+ /* .? */
	'.'('A'..'Z' | '0'..'9')+
	'[' ('0'..'9')+(':'('0'..'9')+)? ']'
;
terminal AFFECTED_BY_NAME:
	 "RV64" 
	| ('A'..'W' | 'Y') 
	| ('Z' | 'S') ('a'..'z')+
;
		
Hex: value=HEX_VALUE;
terminal HEX_VALUE returns ecore::EInt:
	('0x' | '0X')
	('0'..'9' | 'A'..'F' | 'a'..'f')
	(('0'..'9' | 'A'..'F' | 'a'..'f' | '_')*('0'..'9' | 'A'..'F' | 'a'..'f'))?
;
