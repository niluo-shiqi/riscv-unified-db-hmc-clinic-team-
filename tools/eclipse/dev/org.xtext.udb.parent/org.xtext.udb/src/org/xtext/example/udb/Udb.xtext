grammar org.xtext.example.udb.Udb with org.eclipse.xtext.common.Terminals
hidden(SL_COMMENT, WS)
generate udb "http://www.xtext.org/example/udb/Udb"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	  csr  = CsrModel
	| inst = InstModel
	| ext  = ExtModel
;


CsrModel:
	schema = Schema // must be "csr_schema.json#"
	csrKind = CsrKind
	csrName = CsrName &
	longName = LongName &
	description = Description &
	definedBy = CsrDefinedBy &
	address = CsrAddress &
	indirectAddress = CsrIndirectAddress? &
	indirectSlot = CsrIndirectSlot? &
	writable = CsrWritable &
	privmode = CsrPrivMode &
	virtualAddress = CsrVirtualAddress? &
	length = CsrLength &
	requires = CsrRequires? &
	csrFields = CsrFields? &
	swRead = CsrSwRead? &
	source = Source? &
	certNormativeRules = CertNormativeRules?
;


InstModel: 
	schema = Schema // must be "inst_schema.json#"
	kind = InstKind
	instName = InstName &
	longName = LongName &
	description = Description &
	definedBy = InstDefinedBy &
	hints = Hints? &
	base = Base? &
	access = Access &
	accessDetail = AccessDetail? &
	operation = Operation? &
	operationAst = OperationAst? &
	sail = Sail? &
	certNormativeRules = CertNormativeRules? &
	assembly = Assembly &
	dataIndependentTiming = DataIndependentTiming? &
	pseudoInstructions = PseudoInstructions? &
	source = Source? &
	format = Format? &
	encoding = Encoding?
;



ExtModel: 
	schema = Schema // must be "ext_schema.json#"
	extKind = ExtKind
	extName = ExtName &
	longName = LongName &
	description = Description &
	rviJiraIssue = ExtRviJiraIssue? &
	company = ExtCompany? &
	docLicense = DocLicense? &
	type = ExtType &
	requirements = Requirements? &
	extVersions = ExtVersions &
	source = Source? &
	certNormativeRules = CertNormativeRules?
;



/* 
 * Common stuff
 */
Schema: "$schema" ":" schema=STRING;
LongName: 'long_name' ":" longName=STRING;
Description: 'description' ':' description=STRING; 
Requirements: "requirements" ":" requirements=Condition;
Source:'$source' ':' source=STRING;

UdbId: 'id' ':' id=STRING;
Url: 'url' ':' url=STRING;
Email: 'email' ':' email=STRING;

// see "cert_normative_rules" in schema_defs.json
// TODO: not tested
CertNormativeRules: 
	'cert_normative_rules' ':' 
	INDENT	
		rules += CNRuleArrayElement+
	DEDENT
;
CNRuleArrayElement:
	'-' id = UdbId // TODO: makes id the first element (do we want this?)
	INDENT (
		('name' ':' name = STRING) &
		docLinks = DocLinks &
		description = Description
	) DEDENT
;
DocLinks:	
	"doc_links" ":"
	INDENT
		links += DocLinksArrayElement+
	DEDENT
;
DocLinksArrayElement:
	'-' link = STRING	// TODO: this must follow the URI format
;

// see "license" in schema_defs.json 
DocLicense:
	'doc_license' ':'
	INDENT (
		('name' ':' name=STRING) & 
		id=UdbId? &
		url=Url? &
		textUrl=Url?
	) DEDENT
;



/*
 * CSR stuff (see csr_schema.json)
 */
CsrKind: 'kind' ':' kind="csr";
CsrName: 'name' ':' name=ID;
CsrAddress: 'address' ':' address=Hex;
CsrWritable: 'writable' ':' writable=Boolean;
CsrDefinedBy: 'definedBy' ':' extensionName=STRING;
CsrIndirectAddress:'indirect_address' ':' indirectAddress=Hex;
CsrIndirectSlot:'indirect_slot' ':' indirectSlot=INT ; 
CsrVirtualAddress:'virtual_address' ':' virtualAddress=Hex;
CsrSwRead:'sw_read()' ':' swRead=IDL;
CsrPrivMode:'priv_mode' ':' privMode=ID;
CsrLength: 'length' ':' length=CsrLengthType;
CsrLengthType: intType = CsrIntType | parmType = CsrParmType;
CsrIntType: intVal=INT; 
CsrParmType: parmName=('MXLEN'|'SXLEN'|'VSXLEN'|'XLEN');

// extension that must be implemented for this CSR to exist
CsrRequires:'requires' ':' requires=STRING; 

// grammar for csr_field
CsrFields:
	{CsrFields} 'fields' ':'
	INDENT
    	fields += CsrFieldDef+
    DEDENT
;

CsrFieldDef:
	name=ID ':'
	INDENT (
		displayName = CsrFieldDisplayName? &
		longName = LongName? &
		location = CsrFieldLocationType &
		resetValue = CsrFieldResetValueType &
		swWriteFunc = CsrFieldSWWriteFunc? &
		legalFunc = CsrFieldLegalFunc? &
		description = Description &
		type = CsrFieldTypeType &
		alias = CsrFieldAlias? &
		definedBy = CsrDefinedBy? &
		affectedBy = CsrFieldAffectedBy? &
		certNormativeRules = CertNormativeRules?
	) DEDENT
;

CsrFieldDisplayName: 'name' ':' fieldName=STRING ;

CsrFieldLocationType: staticLoc = CsrStaticLocation | funcLoc = CsrVarLocation;
CsrStaticLocation: 'location' ':' locValue=CsrFieldLocation;
CsrVarLocation:
	locationRV32=LocationRV32 &
	locationRV64=LocationRV64
;
LocationRV32: "location_rv32" ":" locationRV32=CsrFieldLocation;
LocationRV64: "location_rv64" ":" locationRV64=CsrFieldLocation;
CsrFieldLocation: value=INT | range=CsrFieldLocationRange;
CsrFieldLocationRange: upper=INT '-' lower=INT;

CsrFieldResetValueType: value=CsrFieldResetValue | function=CsrFieldResetValueFunc;
CsrFieldResetValue: "reset_value" ":" resetValue=CsrFieldResetValueValue;
CsrFieldResetValueValue: value=INT | undefinedLegal=UndefinedLegal;
CsrFieldResetValueFunc: "reset_value()" ":" resetValueFunc=IDL;

CsrFieldSWWriteFunc: "sw_write(csr_value)" ":" swWriteFunc=IDL;
CsrFieldLegalFunc: "legal?(csr_value)" ":" legalFunc=IDL;

CsrFieldTypeType: typeVal=CsrFieldType | typeFunc=CsrFieldTypeFunc;
CsrFieldType: "type" ":" perms=("RO"|"RO-H"|"RW"|"RW-R"|"RW-H"|"RW-RH");
CsrFieldTypeFunc: "type()" ":" idl=IDL;

CsrFieldAlias: "alias" ":" (aliasName=CsrFieldAliasName | aliasArray=CsrFieldAliasArray);
CsrFieldAliasName: name=STRING;
CsrFieldAliasArray:
	"items" ":"
	INDENT
		aliases += CsrAliasArrayElement+
	DEDENT
;
CsrAliasArrayElement:
	"-" alias = CsrFieldAliasName 
;

// TODO: cross-referencing
CsrFieldAffectedBy: "affectedBy" ":" affectedBy=CsrAffectedByType; 
CsrAffectedByType: affectedByName=ID | affectedByArray=Array;




/*
 * Instruction stuff (see inst_schema.json)
 * NOTE: implementation started in PRIDE1099-INST branch
 */
InstKind: 'kind' ':' kind="instruction";
InstName: 'name' ':' name=ID;
InstDefinedBy: 'definedBy' ':' dbname=STRING;
Base: 'base' ':' base=INT; // 32 or 64
Access:
	'access' ':'
	INDENT
	('m' ':' m=AccessType)? &
	's' ':' s=AccessType &
	'u' ':' u=AccessType &
	'vs' ':' vs=AccessType &
	'vu' ':' vu=AccessType
	DEDENT
	;
AccessType:
	accessLevel=('always'|'sometimes'|'never')
;
Assembly: 'assembly' ':' assembly=STRING;
/* Optional fields for the INST schema */
OperationAst: 'operation_ast' ':' operationAst=STRING;
Hints:
	'hints' ':'
	INDENT
		hints += HintElement+
	DEDENT
;
HintElement: '-' '{' hint = STRING '}'; // must match "^inst/.+\\.yaml#.*$"

AccessDetail: 'access_detail' ':' accessDetail=STRING;
Operation: 'operation()' ':' operation=STRING; // string for now, IDL later TODO
Sail: 'sail()' ':' sail=STRING; // string for now, IDL later TODO
DataIndependentTiming: 'data_independent_timing' ':' dataIndependentTiming=Boolean;
PseudoInstructions: 'pseudoinstructions' ':' pseudoInstructions=Array; // type TODO
Format: 'format' ':' 
	INDENT
		'$inherits' ':' inherits=InheritType
		'opcodes' ':' opcodes=OpcodeType 
	DEDENT
;
InheritType:
	INDENT
		('-' reference += STRING)+ //regex must fit yaml path
	DEDENT
;

OpcodeType:
	INDENT
		opcode += OpcodeEntry+
	DEDENT
;
OpcodeEntry:
	OpcodeField
	| OpcodeInherits
;

OpcodeField: // ex) funct7 
	name=ID ':' // must fit regex ('a'..'z') ('a'..'z'|'0'..'9')*, example of opcode name: "function7"
	INDENT
		(opcodeProperties += OpcodeProps)+
	DEDENT
	
;

OpcodeProps: 
	'display_name' ':' displayName=ID 
	| 'value' ':' value=JsonIntLike
;
JsonIntLike:
	intVal=INT
	| bin=BIN
	| hex=Hex
;
OpcodeInherits: 
	'opcode' ':' '{' '$inherits' ':' inheritsAddress=STRING '}'// must fit regex 'inst_opcode/' INST_OPCODE_FILE '.yaml#/data'
;


Encoding: 
	'encoding' ':'
	(
		RvPairEncoding
		| OldEncoding
	)
;

OldEncoding:
	{OldEncoding} 
	INDENT
	    match=EncodingMatch
	    variables=EncodingVariables?
  	DEDENT
;
EncodingMatch:
	'match' ':' pattern=STRING
;

EncodingVariables:
	'variables' ':'
	  INDENT
	    (vars += EncodingTwoKeyVar+ | vars += EncodingSevenKeyVar+)
	  DEDENT
;


EncodingSevenKeyVar:
  '-' 'name' ':' name=ID
  INDENT
    (
      'location' ':' location=BitRange &
      ('$child_of' ':' childOf=STRING)? & //^common/inst_variable_types\\.yaml#/[a-zA-Z0-9_]+, Cookie crumb of the reference to variable metadata
      ('sign_extend' ':' signExtend=Boolean)? & //default is false
      ('left_shift' ':' leftShift=INT)? &
      ('alias' ':' alias=STRING)? &
      ('not' ':' not=NotRule)?
    )
  DEDENT
;

NotRule:
	{NotRule}
	INT | IntArray
;


EncodingTwoKeyVar:
	'-' 'name' ':' name=ID
	INDENT(
		'$inherits' ':' inherits=STRING // must match ^common/inst_variable_types\\.yaml#/[a-zA-Z0-9_]+
	)DEDENT
;

BitRange:
  hi=INT '-' lo=INT
;
RvPairEncoding:
	{RvPairEncoding}
	INDENT
	'RV32' ':' rv32=OldEncoding
	'RV64' ':' rv64=OldEncoding
	DEDENT
; 


/* 
 * Extension stuff (see ext_schema.json) 
 */
ExtKind: 'kind' ':' kind="extension";
ExtName: 'name' ':' name=ID;
ExtType: 'type' ':' perms=('unprivileged' | 'privileged');
ExtRviJiraIssue: 'rvi_jira_issue' ':' issue=STRING;
ExtCompany: 
	'company' ':' 
	INDENT (
		('name' ':' name=STRING) &
		 url=Url?
	) DEDENT 
;

// versions grammar (see ext_schema.json)
ExtVersions:
	"versions" ":" 
	INDENT
		elements += ExtVersionArrayElement+
	DEDENT
;

ExtVersionArrayElement:
	'-' "version" ":" version=STRING // TODO: this has to be first, is that okay?
	INDENT (
		versionState = ExtVersionState &
		repositories = ExtVersionRepositories? &
		ratificationDate = ExtVersionRatificationDate? &
		versionChanges = ExtVersionVersionChanges? &
		url = Url? &
		versionContributors = ExtVersionContributors? &
		requirements = Requirements?
	) DEDENT
;

ExtVersionState: 
	"state" ":" 
	state=("development" | "frozen" | "public-review" | 
		   "ratification-ready" | "ratified" | "nonstandard-released")
;

ExtVersionRepositories:
	"repositories" ":"
	INDENT
		repositories += ExtVersionRepoArrayElement+
	DEDENT
;
ExtVersionRepoArrayElement: // TODO: this is ordered, that okay?
	'-' url=Url
	(INDENT
		"branch" ":" branch=STRING
	DEDENT)?
;

ExtVersionRatificationDate:
	"ratification_date" ":"
	date = (
	  YEAR_MONTH			// when ratification date is known
	| "unknown"				// when ratification date is unknown
	| "null")				// when version isn't ratified			
;

ExtVersionVersionChanges:
	"changes" ":"
	INDENT
		changes += ExtVersionChangesArrayElement+
	DEDENT
;
ExtVersionChangesArrayElement:
	'-' change=STRING
;

ExtVersionContributors:
	"contributors" ":"
	INDENT
		contributors += ExtVersionContributorsArrayElement+ 
	DEDENT
;
ExtVersionContributorsArrayElement:
	'-' name=ExtVersionContributorName // TODO: is it okay that name must be the first element?
	(INDENT (
		("company" ":" company=STRING)? & // company contributor worked for or 'Individual'
		email=Email?
	) DEDENT)?
;
ExtVersionContributorName:
	"name" ":" firstName = ID lastName = ID?
;



/* Conditions */
Condition: cond=STRING; // placeholder
//Condition: yamlCond=YAMLCondition | idlCond=IDLCondition;

//YAMLCondition:
//	yaml = YAMLCondition (TODO: implement)
//	  extensionCond = ExtensionCondition
//	| paramCond = ParamCondition
//	| xlenCond = XLenCondition
//;

//IDLCondition:
//	"idl()" ":" idl=IDL
//	reason?=Reason
//;
//
//ExtensionCondition:
//	STRING /* TODO */
//;
//
//ParamCondition:
//	STRING /* TODO */
//;

//XLenCondition: xlen=INT; /* can be 32 or 64 (TODO: implement in validator) */

//Reason: "reason" ":" reasonStr=STRING;



/* IDL Grammar */
IDL: idl=STRING;





/*
 * Keywords
 */
UndefinedLegal: "UNDEFINED_LEGAL";
Boolean returns ecore::EBoolean: "true" | "false";



/*
 * Helpers
 */
Array: '[' names+=ID (',' names+=ID)+ ']';

IntArray: '[' element+=INT (',' element+=INT) + ']';


/*
 * Hex
 */

Hex: value=HEX_VALUE;
terminal HEX_VALUE returns ecore::EInt:
	('0x' | '0X')
	('0'..'9' | 'A'..'F' | 'a'..'f')
	(('0'..'9' | 'A'..'F' | 'a'..'f' | '_')*('0'..'9' | 'A'..'F' | 'a'..'f'))?
;

terminal BIN: 
	'0b' ('0'|'1')+ // "0111", "00010", etc.
;

/*
 * Terminals
 */
terminal YEAR_MONTH:
	(('20')('0'..'9')('0'..'9')'-'    
	  ('0'('1'..'9') | '1'('0'..'2')))
;

// For whitespace awareness
terminal INDENT: 'synthetic:INDENT';
terminal DEDENT: 'synthetic:DEDENT';

@Override
terminal SL_COMMENT: '#' !('\n'|'\r')*;

@Override
terminal WS: ('\r'|'\n'|'\t'|' ')+;

@Override
terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'.')*;


