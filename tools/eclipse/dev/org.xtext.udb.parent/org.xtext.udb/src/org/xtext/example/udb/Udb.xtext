grammar org.xtext.example.udb.Udb with org.eclipse.xtext.common.Terminals
hidden(WS, SL_COMMENT)
generate udb "http://www.xtext.org/example/udb/Udb"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	kind = Kind &
	csrName = Name &
	base = Base? &
	longName = LongName &
	description = Description &
	definedBy = DefinedBy &
	address = Address &
	indirectAddress = IndirectAddress? &
	indirectSlot = IndirectSlot? &
	writable = Writable &
	privmode = PrivMode &
	virtualAddress = VirtualAddress? &
	length = Length &
	requires = Requires? &
	fields = Fields? &
	swRead = SwRead? &
	source = Source? &
	certNormativeRules = CertNormativeRules? &
	certTestProcedures = CertTestProcedures?
;

/* Required fields for the CSR schema */
Kind: 'kind' ':' kind=KindType NL;
Name: 'name' ':' name=NameType NL;
LongName: 'long_name' ':' longName=STRING NL;
Address: 'address' ':' address=Hex NL; /* need to make this only accept 3 digit hex */
Writable: 'writable' ':' writable=Boolean NL;
PrivMode:'priv_mode' ':' privMode=PrivType NL;
Length: 'length' ':' length=LengthType NL;
Description: 'description' ':' description=STRING NL;
DefinedBy:'definedBy' ':'extensionName=STRING NL;

/* Optional fields for the CSR schema */
Base: 'base' ':' base=INT NL;
IndirectAddress:'indirect_address' ':' indirectAddress=Hex NL; /* TODO: max 64 bits */
IndirectSlot:'indirect_slot' ':' indirectSlot=INT NL; /* TODO: validator: min:1 max:6 */


VirtualAddress:'virtual_address' ':' virtualAddress=Hex NL; /* TODO: validator: up to 12 bits */
CertNormativeRules: 'cert_normative_rules' ':' certNormativeRules=CNRType NL;
CertTestProcedures: 'cert_test_procedures' ':' certTestProcedures=CTPType NL;

// implement in validator?
Requires:'requires' ':' requires=STRING NL;
SwRead:'sw_read()' ':' swRead=STRING NL;
Source:'$source' ':' source=STRING NL;


/* CSR Schema Types */
KindType: type=('csr'|'extension');
NameType: type=(CSR_NAME);
PrivType: type=('M'|'S'|'U'|'VS'|'D');
LengthType: type=LengthTypeValue;
LengthTypeValue: (INT|'MXLEN'|'SXLEN'|'VSXLEN'|'XLEN');
CNRType: '[' id=STRING ',' name=STRING ',' docLinks=StringArray ','
			 description=STRING ']';
CTPType: '[' id=STRING ',' name=STRING ',' description=STRING ',' 
			 normativeRules=StringArray ',' list=STRING?']';





/* Grammar for fields */
Fields:
	{Fields} 'fields' ':' NL
    fields += FieldDef+
;

FieldDef:
	name=FIELD_NAME ':' NL
		properties+=FieldProperty*
;


FieldProperty:
      FieldDisplayName
    | LongName
    | LocationType
    | ResetValueType
    | SWWriteFunc
    | LegalFunc
    | Base
    | Description
    | Type
    | Alias
    | DefinedBy
    | AffectedBy
    | CertNormativeRules
    | CertTestProcedures
;

FieldDisplayName: 'name' ':' fieldName=STRING NL;



/* fields for Fields */
StaticLocation: 'location' ':' locValue=FieldLocation NL;
LocationRV32: "location_rv32" ":" locationRV32=FieldLocation NL;
LocationRV64: "location_rv64" ":" locationRV64=FieldLocation NL;


ResetValue: "reset_value" ":" resetValue=ResetValueValue NL; 
ResetValueFunc: "reset_value()" ":" resetValueFunc=IDL NL;
SWWriteFunc: "sw_write(csr_value)" ":" swWriteFunc=IDL NL;
LegalFunc: "legal?(csr_value)" ":" legalFunc=IDL NL;
Type: "type" ":" perms=("RO"|"RO-H"|"RW"|"RW-R"|"RW-H"|"RW-RH") NL;
TypeFunc: "type()" ":" idl=IDL NL;
Alias: "alias" ":" alias=AliasType NL; 
AffectedBy: "affectedBy" ":" affectedBy=AffectedByType NL;

/* Types for Fields */

LocationType: staticLoc = StaticLocation | funcLoc = FuncLocation;
FuncLocation: 
	locationRV32=LocationRV32 
	locationRV64=LocationRV64
;
FieldLocation: value=INT | range=Range;
Range: upper=INT '-' lower=INT;
ResetValueType: value=ResetValue | function=ResetValueFunc;
ResetValueValue: value=INT | undefinedLegal=UndefinedLegal;
TypeType: typeVal=Type | typeFunc=TypeFunc;
AliasType: alias+=(CSR_FIELD | CSR_FIELD_BITS)+;
AffectedByType: affectedBy += AFFECTED_BY_NAME | AffectedByArray;
AffectedByArray:
    '[' names+=AFFECTED_BY_NAME (',' names+=AFFECTED_BY_NAME)* ']'
;

/* Conditions */
//Condition: YAMLCondition | IDLCondition;
//YAMLCondition:
//	
//;



/* IDL Grammar */
IDL: idl=STRING;





/* Keywords */
UndefinedLegal: "UNDEFINED_LEGAL";
Boolean returns ecore::EBoolean: "true" | "false";

/* Array Types */
StringArray: '[' items+=STRING ']';

/* Terminals */
terminal CSR_NAME:  
	('a'..'z')('a'..'z' | '0'..'9' | '_' | '.')+ /* .? */
;
terminal FIELD_NAME: 
	('a'..'z' | 'A'..'Z')+
;
terminal CSR_FIELD:
	('a'..'z')('a'..'z' | '0'..'9' | '_' | '.')+  /* .? */
	('.')('A'..'Z' | '0'..'9')+
;
terminal CSR_FIELD_BITS:
	('a'..'z')('a'..'z' | '0'..'9' | '_' | '.')+ /* .? */
	'.'('A'..'Z' | '0'..'9')+
	'[' ('0'..'9')+(':'('0'..'9')+)? ']'
;
terminal AFFECTED_BY_NAME:
	 "RV64" | ('A'..'W' | 'Y') 
	| ('Z' | 'S') ('a'..'z')+
;
		
Hex: value=HEX_VALUE;
terminal HEX_VALUE returns ecore::EInt:
	('0x' | '0X')
	('0'..'9' | 'A'..'F' | 'a'..'f')
	(('0'..'9' | 'A'..'F' | 'a'..'f' | '_')*('0'..'9' | 'A'..'F' | 'a'..'f'))?
;


terminal SL_COMMENT: '#' !('\n'|'\r')*;
terminal NL: '\r'? '\n';
terminal WS: (' ' | '\t')+;

